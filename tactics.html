<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>证明策略 - Lean 4 定理证明</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme && theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar && sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title_page.html">Lean 4 定理证明</a></li><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> 简介</a></li><li class="chapter-item expanded "><a href="dependent_type_theory.html"><strong aria-hidden="true">2.</strong> 依值类型论</a></li><li class="chapter-item expanded "><a href="propositions_and_proofs.html"><strong aria-hidden="true">3.</strong> 命题与证明</a></li><li class="chapter-item expanded "><a href="quantifiers_and_equality.html"><strong aria-hidden="true">4.</strong> 量词与等价</a></li><li class="chapter-item expanded "><a href="tactics.html" class="active"><strong aria-hidden="true">5.</strong> 证明策略</a></li><li class="chapter-item expanded "><a href="interacting_with_lean.html"><strong aria-hidden="true">6.</strong> 与 Lean 交互</a></li><li class="chapter-item expanded "><a href="inductive_types.html"><strong aria-hidden="true">7.</strong> 归纳类型</a></li><li class="chapter-item expanded "><a href="induction_and_recursion.html"><strong aria-hidden="true">8.</strong> 归纳与递归</a></li><li class="chapter-item expanded "><a href="structures_and_records.html"><strong aria-hidden="true">9.</strong> 结构体与记录</a></li><li class="chapter-item expanded "><a href="type_classes.html"><strong aria-hidden="true">10.</strong> 类型类</a></li><li class="chapter-item expanded "><a href="conv.html"><strong aria-hidden="true">11.</strong> 转换策略模式</a></li><li class="chapter-item expanded "><a href="axioms_and_computation.html"><strong aria-hidden="true">12.</strong> 公理与计算</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Lean 4 定理证明</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Lean-zh/tp-lean-zh" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/Lean-zh/tp-lean-zh/edit/master/./tactics.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
Tactics
=======
-->
<h1 id="证明策略"><a class="header" href="#证明策略">证明策略</a></h1>
<!--
In this chapter, we describe an alternative approach to constructing
proofs, using *tactics*.  A proof term is a representation of a
mathematical proof; tactics are commands, or instructions, that
describe how to build such a proof. Informally, you might begin a
mathematical proof by saying "to prove the forward direction, unfold
the definition, apply the previous lemma, and simplify." Just as these
are instructions that tell the reader how to find the relevant proof,
tactics are instructions that tell Lean how to construct a proof
term. They naturally support an incremental style of writing proofs,
in which you decompose a proof and work on goals one step at a time.

We will describe proofs that consist of sequences of tactics as
"tactic-style" proofs, to contrast with the ways of writing proof
terms we have seen so far, which we will call "term-style"
proofs. Each style has its own advantages and disadvantages. For
example, tactic-style proofs can be harder to read, because they
require the reader to predict or guess the results of each
instruction. But they can also be shorter and easier to
write. Moreover, tactics offer a gateway to using Lean's automation,
since automated procedures are themselves tactics.
-->
<p>在本章中，我们描述了另一种构建证明的方法，即使用 <strong>策略（Tactic）</strong> 。 一个证明项代表一个数学证明；策略是描述如何建立这样一个证明的命令或指令。你可以在数学证明开始时非正式地说：「为了证明条件的必要性，展开定义，应用前面的定理，并进行简化。」就像这些指令告诉读者如何构建证明一样，策略告诉 Lean 如何构建证明。它们自然而然地支持增量式的证明书写，在这种写作方式中，你将分解一个证明，并一步步地实现目标。</p>
<blockquote>
<p>译者注：tactic 和 strategy 都有策略的意思，其中 tactic 侧重细节，如排兵布阵，
strategy 面向整体，如大规模战略。试译 strategy 为「要略」，与 tactic 相区分。</p>
</blockquote>
<p>我们将把由策略序列组成的证明描述为「策略式」(tactic-style)证明，前几章的证明我们称为「项式」(term-style)证明。每种风格都有自己的优点和缺点。例如，项式证明可能更难读，因为它们要求读者预测或猜测每条指令的结果。但它们一般更短，更容易写。此外，策略提供了一个使用 Lean 自动化的途径，因为自动化程序本身就是策略。</p>
<!--
Entering Tactic Mode
--------------------
-->
<h2 id="进入策略模式"><a class="header" href="#进入策略模式">进入策略模式</a></h2>
<!--
Conceptually, stating a theorem or introducing a ``have`` statement
creates a goal, namely, the goal of constructing a term with the
expected type. For example, the following creates the goal of
constructing a term of type ``p ∧ q ∧ p``, in a context with constants
``p q : Prop``, ``hp : p`` and ``hq : q``:
-->
<p>从概念上讲，陈述一个定理或引入一个 <code>have</code> 的声明会产生一个目标，即构造一个具有预期类型的项的目标。例如, 下面创建的目标是构建一个类型为 <code>p ∧ q ∧ p</code> 的项，条件有常量 <code>p q : Prop</code>，<code>hp : p</code> 和 <code>hq : q</code>。</p>
<pre><code class="language-lean">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p :=
  sorry
</code></pre>
<!--
You can write this goal as follows:
-->
<p>写成目标如下：</p>
<pre><code>    p : Prop, q : Prop, hp : p, hq : q ⊢ p ∧ q ∧ p
</code></pre>
<!--
Indeed, if you replace the "sorry" by an underscore in the example
above, Lean will report that it is exactly this goal that has been
left unsolved.

Ordinarily, you meet such a goal by writing an explicit term. But
wherever a term is expected, Lean allows us to insert instead a ``by
<tactics>`` block, where ``<tactics>`` is a sequence of commands,
separated by semicolons or line breaks. You can prove the theorem above
in that way:
-->
<p>事实上，如果你把上面的例子中的「sorry」换成下划线，Lean 会报告说，正是这个目标没有得到解决。</p>
<p>通常情况下，你会通过写一个明确的项来满足这样的目标。但在任何需要项的地方，Lean 允许我们插入一个 <code>by &lt;tactics&gt;</code> 块，其中 <code>&lt;tactics&gt;</code> 是一串命令，用分号或换行符分开。你可以用下面这种方式来证明上面的定理：</p>
<pre><code class="language-lean">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p :=
  by apply And.intro
     exact hp
     apply And.intro
     exact hq
     exact hp
</code></pre>
<!--
We often put the ``by`` keyword on the preceding line, and write the
example above as:
-->
<p>我们经常将 <code>by</code> 关键字放在前一行，并将上面的例子写为</p>
<pre><code class="language-lean">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p := by
  apply And.intro
  exact hp
  apply And.intro
  exact hq
  exact hp
</code></pre>
<!--
The ``apply`` tactic applies an expression, viewed as denoting a
function with zero or more arguments. It unifies the conclusion with
the expression in the current goal, and creates new goals for the
remaining arguments, provided that no later arguments depend on
them. In the example above, the command ``apply And.intro`` yields two
subgoals:
-->
<p><code>apply</code> 策略应用于一个表达式，被视为表示一个有零或多个参数的函数。它将结论与当前目标中的表达式统一起来，并为剩余的参数创建新的目标，只要后面的参数不依赖于它们。在上面的例子中，命令 <code>apply And.intro</code> 产生了两个子目标：</p>
<pre><code>    case left
    p q : Prop
    hp : p
    hq : q
    ⊢ p

    case right
    p q : Prop
    hp : p
    hq : q
    ⊢ q ∧ p
</code></pre>
<!--
The first goal is met with the command ``exact hp``. The ``exact``
command is just a variant of ``apply`` which signals that the
expression given should fill the goal exactly. It is good form to use
it in a tactic proof, since its failure signals that something has
gone wrong. It is also more robust than ``apply``, since the
elaborator takes the expected type, given by the target of the goal,
into account when processing the expression that is being applied. In
this case, however, ``apply`` would work just as well.

You can see the resulting proof term with the ``#print`` command:
-->
<p>第一个目标是通过 <code>exact hp</code> 命令来实现的。<code>exact</code> 命令只是 <code>apply</code> 的一个变体，它表示所给的表达式应该准确地填充目标。在策略证明中使用它很有益，因为它如果失败那么表明出了问题。它也比 <code>apply</code> 更稳健，因为繁饰器在处理被应用的表达式时，会考虑到目标所预期的类型。然而，在这种情况下，<code>apply</code> 也可以很好地工作。</p>
<p>你可以用<code>#print</code>命令查看所产生的证明项。</p>
<pre><code class="language-lean"><span class="boring">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p := by
</span><span class="boring"> apply And.intro
</span><span class="boring"> exact hp
</span><span class="boring"> apply And.intro
</span><span class="boring"> exact hq
</span><span class="boring"> exact hp
</span>#print test
</code></pre>
<!--
You can write a tactic script incrementally. In VS Code, you can open
a window to display messages by pressing ``Ctrl-Shift-Enter``, and
that window will then show you the current goal whenever the cursor is
in a tactic block. In Emacs, you can see the goal at the end of any
line by pressing ``C-c C-g``, or see the remaining goal in an
incomplete proof by putting the cursor after the first character of
the last tactic. If the proof is incomplete, the token ``by`` is
decorated with a red squiggly line, and the error message contains the
remaining goals.

Tactic commands can take compound expressions, not just single
identifiers. The following is a shorter version of the preceding
proof:
-->
<p>你可以循序渐进地写一个策略脚本。在VS Code中，你可以通过按<code>Ctrl-Shift-Enter</code>打开一个窗口来显示信息，然后只要光标在策略块中，该窗口就会显示当前的目标。在 Emacs 中，你可以通过按<code>C-c C-g</code>看到任何一行末尾的目标，或者通过把光标放在最后一个策略的第一个字符之后，看到一个不完整的证明中的剩余目标。如果证明是不完整的，标记 <code>by</code> 会被装饰成一条红色的斜线，错误信息中包含剩余的目标。</p>
<p>策略命令可以接受复合表达式，而不仅仅是单一标识符。下面是前面证明的一个简短版本。</p>
<pre><code class="language-lean">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p := by
  apply And.intro hp
  exact And.intro hq hp
</code></pre>
<!--
Unsurprisingly, it produces exactly the same proof term.
-->
<p>它产生了相同的证明项。</p>
<pre><code class="language-lean"><span class="boring">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p := by
</span><span class="boring"> apply And.intro hp
</span><span class="boring"> exact And.intro hq hp
</span>#print test
</code></pre>
<!--
Multiple tactic applications can be written in a single line by concatenating with a semicolon.
-->
<p>应用多个策略可以通过用分号连接写在一行中。</p>
<pre><code class="language-lean">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p := by
  apply And.intro hp; exact And.intro hq hp
</code></pre>
<!--
Tactics that may produce multiple subgoals often tag them. For
example, the tactic ``apply And.intro`` tagged the first subgoal as
``left``, and the second as ``right``. In the case of the ``apply``
tactic, the tags are inferred from the parameters' names used in the
``And.intro`` declaration. You can structure your tactics using the
notation ``case <tag> => <tactics>``. The following is a structured
version of our first tactic proof in this chapter.
-->
<p>可能产生多个子目标的策略通常对子目标进行标记。例如，<code>apply And.intro</code> 策略将第一个目标标记为 <code>left</code>，将第二个目标标记为 <code>right</code>。在 <code>apply</code> 策略的情况下，标签是从 <code>And.intro</code> 声明中使用的参数名称推断出来的。你可以使用符号 <code>case &lt;tag&gt; =&gt; &lt;tactics&gt;</code> 来结构化你的策略。下面是本章中第一个策略证明的结构化版本。</p>
<pre><code class="language-lean">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p := by
  apply And.intro
  case left =&gt; exact hp
  case right =&gt;
    apply And.intro
    case left =&gt; exact hq
    case right =&gt; exact hp
</code></pre>
<!--
You can solve the subgoal ``right`` before ``left`` using the ``case``
notation:
-->
<p>使用 <code>case</code> 标记，你也可以在 <code>left</code> 之前先解决子目标 <code>right</code>：</p>
<pre><code class="language-lean">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p := by
  apply And.intro
  case right =&gt;
    apply And.intro
    case left =&gt; exact hq
    case right =&gt; exact hp
  case left =&gt; exact hp
</code></pre>
<!--
Note that Lean hides the other goals inside the ``case`` block. We say
it is "focusing" on the selected goal.  Moreover, Lean flags an error
if the selected goal is not fully solved at the end of the ``case``
block.

For simple subgoals, it may not be worth selecting a subgoal using its
tag, but you may still want to structure the proof. Lean also provides
the "bullet" notation ``. <tactics>`` (or ``· <tactics>``) for
structuring proof.
-->
<p>注意，Lean 将其他目标隐藏在 <code>case</code> 块内。我们说它「专注」于选定的目标。 此外，如果所选目标在 <code>case</code> 块的末尾没有完全解决，Lean 会标记一个错误。</p>
<p>对于简单的子目标，可能不值得使用其标签来选择一个子目标，但你可能仍然想要结构化证明。Lean 还提供了「子弹」符号 <code>. &lt;tactics&gt;</code> 或 <code>· &lt;tactics&gt;</code>。</p>
<pre><code class="language-lean">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p := by
  apply And.intro
  . exact hp
  . apply And.intro
    . exact hq
    . exact hp
</code></pre>
<!--
Basic Tactics
-------------
-->
<h2 id="基本策略"><a class="header" href="#基本策略">基本策略</a></h2>
<!--
In addition to ``apply`` and ``exact``, another useful tactic is
``intro``, which introduces a hypothesis. What follows is an example
of an identity from propositional logic that we proved in a previous
chapter, now proved using tactics.
-->
<p>除了 <code>apply</code> 和 <code>exact</code> 之外，另一个有用的策略是 <code>intro</code>，它引入了一个假设。下面是我们在前一章中证明的命题逻辑中的一个等价性的例子，现在用策略来证明。</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := by
  apply Iff.intro
  . intro h
    apply Or.elim (And.right h)
    . intro hq
      apply Or.inl
      apply And.intro
      . exact And.left h
      . exact hq
    . intro hr
      apply Or.inr
      apply And.intro
      . exact And.left h
      . exact hr
  . intro h
    apply Or.elim h
    . intro hpq
      apply And.intro
      . exact And.left hpq
      . apply Or.inl
        exact And.right hpq
    . intro hpr
      apply And.intro
      . exact And.left hpr
      . apply Or.inr
        exact And.right hpr
</code></pre>
<!--
The ``intro`` command can more generally be used to introduce a variable of any type:
-->
<p><code>intro</code> 命令可以更普遍地用于引入任何类型的变量。</p>
<pre><code class="language-lean">example (α : Type) : α → α := by
  intro a
  exact a

example (α : Type) : ∀ x : α, x = x := by
  intro x
  exact Eq.refl x
</code></pre>
<!--
You can use it to introduce several variables:
-->
<p>你可以同时引入好几个变量：</p>
<pre><code class="language-lean">example : ∀ a b c : Nat, a = b → a = c → c = b := by
  intro a b c h₁ h₂
  exact Eq.trans (Eq.symm h₂) h₁
</code></pre>
<!--
As the ``apply`` tactic is a command for constructing function
applications interactively, the ``intro`` tactic is a command for
constructing function abstractions interactively (i.e., terms of the
form ``fun x => e``).  As with lambda abstraction notation, the
``intro`` tactic allows us to use an implicit ``match``.
-->
<p>由于 <code>apply</code> 策略是一个用于交互式构造函数应用的命令，<code>intro</code> 策略是一个用于交互式构造函数抽象的命令（即 <code>fun x =&gt; e</code> 形式的项）。 与 lambda 抽象符号一样，<code>intro</code> 策略允许我们使用隐式的 <code>match</code>。</p>
<pre><code class="language-lean">example (α : Type) (p q : α → Prop) : (∃ x, p x ∧ q x) → ∃ x, q x ∧ p x := by
  intro ⟨w, hpw, hqw⟩
  exact ⟨w, hqw, hpw⟩
</code></pre>
<!--
You can also provide multiple alternatives like in the ``match`` expression.
-->
<p>就像 <code>match</code> 表达式一样，你也可以提供多个选项。</p>
<pre><code class="language-lean">example (α : Type) (p q : α → Prop) : (∃ x, p x ∨ q x) → ∃ x, q x ∨ p x := by
  intro
  | ⟨w, Or.inl h⟩ =&gt; exact ⟨w, Or.inr h⟩
  | ⟨w, Or.inr h⟩ =&gt; exact ⟨w, Or.inl h⟩
</code></pre>
<!--
The ``intros`` tactic can be used without any arguments, in which
case, it chooses names and introduces as many variables as it can. You
will see an example of this in a moment.

The ``assumption`` tactic looks through the assumptions in context of
the current goal, and if there is one matching the conclusion, it
applies it.
-->
<p><code>intros</code> 策略可以在没有任何参数的情况下使用，在这种情况下，它选择名字并尽可能多地引入变量。稍后你会看到一个例子。</p>
<p><code>assumption</code> 策略在当前目标的背景下查看假设，如果有一个与结论相匹配的假设，它就会应用这个假设。</p>
<!--
```lean
example (x y z w : Nat) (h₁ : x = y) (h₂ : y = z) (h₃ : z = w) : x = w := by
  apply Eq.trans h₁
  apply Eq.trans h₂
  assumption   -- applied h₃
```
-->
<pre><code class="language-lean">example (x y z w : Nat) (h₁ : x = y) (h₂ : y = z) (h₃ : z = w) : x = w := by
  apply Eq.trans h₁
  apply Eq.trans h₂
  assumption   -- 应用h₃
</code></pre>
<!--
It will unify metavariables in the conclusion if necessary:
-->
<p>若有必要，它会在结论中统一元变量。</p>
<!--
```lean
example (x y z w : Nat) (h₁ : x = y) (h₂ : y = z) (h₃ : z = w) : x = w := by
  apply Eq.trans
  assumption      -- solves x = ?b with h₁
  apply Eq.trans
  assumption      -- solves y = ?h₂.b with h₂
  assumption      -- solves z = w with h₃
```
-->
<pre><code class="language-lean">example (x y z w : Nat) (h₁ : x = y) (h₂ : y = z) (h₃ : z = w) : x = w := by
  apply Eq.trans
  assumption      -- 求解了 x = ?b with h₁
  apply Eq.trans
  assumption      -- 求解了 y = ?h₂.b with h₂
  assumption      -- 求解了 z = w with h₃
</code></pre>
<!--
The following example uses the ``intros`` command to introduce the three variables and two hypotheses automatically:
-->
<p>下面的例子使用 <code>intros</code> 命令来自动引入三个变量和两个假设：</p>
<pre><code class="language-lean">example : ∀ a b c : Nat, a = b → a = c → c = b := by
  intros
  apply Eq.trans
  apply Eq.symm
  assumption
  assumption
</code></pre>
<!--
Note that names automatically generated by Lean are inaccessible by default. The motivation is to
ensure your tactic proofs do not rely on automatically generated names, and are consequently more robust.
However, you can use the combinator ``unhygienic`` to disable this restriction.
-->
<p>请注意，由 Lean 自动生成的名称在默认情况下是不可访问的。其动机是为了确保你的策略证明不依赖于自动生成的名字，并因此而更加强大。然而，你可以使用组合器 <code>unhygienic</code> 来禁用这一限制。</p>
<pre><code class="language-lean">example : ∀ a b c : Nat, a = b → a = c → c = b := by unhygienic
  intros
  apply Eq.trans
  apply Eq.symm
  exact a_2
  exact a_1
</code></pre>
<!--
You can also use the ``rename_i`` tactic to rename the most recent inaccessible names in your context.
In the following example, the tactic ``rename_i h1 _ h2`` renames two of the last three hypotheses in
your context.
-->
<p>你也可以使用 <code>rename_i</code> 策略来重命名你的上下文中最近的不能访问的名字。在下面的例子中，策略 <code>rename_i h1 _ h2</code> 在你的上下文中重命名了三个假设中的两个。</p>
<pre><code class="language-lean">example : ∀ a b c d : Nat, a = b → a = d → a = c → c = b := by
  intros
  rename_i h1 _ h2
  apply Eq.trans
  apply Eq.symm
  exact h2
  exact h1
</code></pre>
<!--
The ``rfl`` tactic is syntactic sugar for ``exact rfl``.
-->
<p><code>rfl</code> 策略是 <code>exact rfl</code> 的语法糖。</p>
<pre><code class="language-lean">example (y : Nat) : (fun x : Nat =&gt; 0) y = 0 :=
  by rfl
</code></pre>
<!--
The ``repeat`` combinator can be used to apply a tactic several times.
-->
<p><code>repeat</code> 组合器可以多次使用一个策略。</p>
<pre><code class="language-lean">example : ∀ a b c : Nat, a = b → a = c → c = b := by
  intros
  apply Eq.trans
  apply Eq.symm
  repeat assumption
</code></pre>
<!--
Another tactic that is sometimes useful is the ``revert`` tactic,
which is, in a sense, an inverse to ``intro``.
-->
<p>另一个有时很有用的策略是还原 <code>revert</code> 策略，从某种意义上说，它是对 <code>intro</code> 的逆。</p>
<pre><code class="language-lean">example (x : Nat) : x = x := by
  revert x
  -- goal is ⊢ ∀ (x : Nat), x = x
  intro y
  -- goal is y : Nat ⊢ y = y
  rfl
</code></pre>
<!--
Moving a hypothesis into the goal yields an implication:
-->
<p>将一个假设还原到目标中会产生一个蕴含。</p>
<pre><code class="language-lean">example (x y : Nat) (h : x = y) : y = x := by
  revert h
  -- goal is x y : Nat ⊢ x = y → y = x
  intro h₁
  -- goal is x y : Nat, h₁ : x = y ⊢ y = x
  apply Eq.symm
  assumption
</code></pre>
<!--
But ``revert`` is even more clever, in that it will revert not only an
element of the context but also all the subsequent elements of the
context that depend on it. For example, reverting ``x`` in the example
above brings ``h`` along with it:
-->
<p>但是 <code>revert</code> 更聪明，因为它不仅会还原上下文中的一个元素，还会还原上下文中所有依赖它的后续元素。例如，在上面的例子中，还原 <code>x</code> 会带来 <code>h</code>。</p>
<pre><code class="language-lean">example (x y : Nat) (h : x = y) : y = x := by
  revert x
  -- goal is y : Nat ⊢ ∀ (x : Nat), x = y → y = x
  intros
  apply Eq.symm
  assumption
</code></pre>
<!--
You can also revert multiple elements of the context at once:
-->
<p>你还可以一次性还原多个元素：</p>
<pre><code class="language-lean">example (x y : Nat) (h : x = y) : y = x := by
  revert x y
  -- goal is ⊢ ∀ (x y : Nat), x = y → y = x
  intros
  apply Eq.symm
  assumption
</code></pre>
<!--
You can only ``revert`` an element of the local context, that is, a
local variable or hypothesis. But you can replace an arbitrary
expression in the goal by a fresh variable using the ``generalize``
tactic.
-->
<p>你只能 <code>revert</code> 局部环境中的一个元素，也就是一个局部变量或假设。但是你可以使用泛化 <code>generalize</code> 策略将目标中的任意表达式替换为新的变量。</p>
<pre><code class="language-lean">example : 3 = 3 := by
  generalize 3 = x
  -- goal is x : Nat ⊢ x = x
  revert x
  -- goal is ⊢ ∀ (x : Nat), x = x
  intro y
  -- goal is y : Nat ⊢ y = y
  rfl
</code></pre>
<!--
The mnemonic in the notation above is that you are generalizing the
goal by setting ``3`` to an arbitrary variable ``x``. Be careful: not
every generalization preserves the validity of the goal. Here,
``generalize`` replaces a goal that could be proved using
``rfl`` with one that is not provable:
-->
<p>上述符号的记忆法是，你通过将 <code>3</code> 设定为任意变量 <code>x</code> 来泛化目标。要注意：不是每一个泛化都能保留目标的有效性。这里，<code>generalize</code> 用一个无法证明的目标取代了一个可以用 <code>rfl</code> 证明的目标。</p>
<pre><code class="language-lean">example : 2 + 3 = 5 := by
  generalize 3 = x
  -- goal is x : Nat ⊢ 2 + x = 5
  admit
</code></pre>
<!--
In this example, the ``admit`` tactic is the analogue of the ``sorry``
proof term. It closes the current goal, producing the usual warning
that ``sorry`` has been used. To preserve the validity of the previous
goal, the ``generalize`` tactic allows us to record the fact that
``3`` has been replaced by ``x``. All you need to do is to provide a
label, and ``generalize`` uses it to store the assignment in the local
context:
-->
<p>在这个例子中，<code>admit</code> 策略是 <code>sorry</code> 证明项的类似物。它关闭了当前的目标，产生了通常的警告：使用了 <code>sorry</code>。为了保持之前目标的有效性，<code>generalize</code> 策略允许我们记录 <code>3</code> 已经被 <code>x</code> 所取代的事实。你所需要做的就是提供一个标签，<code>generalize</code> 使用它来存储局部上下文中的赋值。</p>
<pre><code class="language-lean">example : 2 + 3 = 5 := by
  generalize h : 3 = x
  -- goal is x : Nat, h : 3 = x ⊢ 2 + x = 5
  rw [← h]
</code></pre>
<!--
Here the ``rewrite`` tactic, abbreviated ``rw``, uses ``h`` to replace
``x`` by ``3`` again. The ``rewrite`` tactic will be discussed below.
-->
<p>这里 <code>rewrite</code> 策略，缩写为 <code>rw</code>，用 <code>h</code> 把 <code>x</code> 用 <code>3</code> 换了回来。<code>rewrite</code> 策略下文将继续讨论。</p>
<!--
More Tactics
------------
-->
<h2 id="更多策略"><a class="header" href="#更多策略">更多策略</a></h2>
<!--
Some additional tactics are useful for constructing and destructing
propositions and data. For example, when applied to a goal of the form
``p ∨ q``, you use tactics such as ``apply Or.inl`` and ``apply
Or.inr``.  Conversely, the ``cases`` tactic can be used to decompose a
disjunction.
-->
<p>一些额外的策略对于建构和析构命题以及数据很有用。例如，当应用于形式为 <code>p ∨ q</code> 的目标时，你可以使用 <code>apply Or.inl</code> 和 <code>apply Or.inr</code> 等策略。 反之，<code>cases</code> 策略可以用来分解一个析取。</p>
<pre><code class="language-lean">example (p q : Prop) : p ∨ q → q ∨ p := by
  intro h
  cases h with
  | inl hp =&gt; apply Or.inr; exact hp
  | inr hq =&gt; apply Or.inl; exact hq
</code></pre>
<!--
Note that the syntax is similar to the one used in `match` expressions.
The new subgoals can be solved in any order.
-->
<p>注意，该语法与 <code>match</code> 表达式中使用的语法相似。新的子目标可以按任何顺序解决。</p>
<pre><code class="language-lean">example (p q : Prop) : p ∨ q → q ∨ p := by
  intro h
  cases h with
  | inr hq =&gt; apply Or.inl; exact hq
  | inl hp =&gt; apply Or.inr; exact hp
</code></pre>
<!--
You can also use a (unstructured) ``cases`` without the ``with`` and a tactic
for each alternative.
-->
<p>你也可以使用一个（非结构化的）<code>cases</code>，而不使用 <code>with</code>，并为每个备选情况制定一个策略。</p>
<pre><code class="language-lean">example (p q : Prop) : p ∨ q → q ∨ p := by
  intro h
  cases h
  apply Or.inr
  assumption
  apply Or.inl
  assumption
</code></pre>
<!--
The (unstructured) ``cases`` is particularly useful when you can close several
subgoals using the same tactic.
-->
<p>（非结构化的）<code>cases</code> 在你可以用同一个策略来解决子任务时格外有用。</p>
<pre><code class="language-lean">example (p : Prop) : p ∨ p → p := by
  intro h
  cases h
  repeat assumption
</code></pre>
<!--
You can also use the combinator ``tac1 <;> tac2`` to apply ``tac2`` to each
subgoal produced by tactic ``tac1``.
-->
<p>你也可以使用组合器 <code>tac1 &lt;;&gt; tac2</code>，将 <code>tac2</code> 应用于策略 <code>tac1</code> 产生的每个子目标。</p>
<pre><code class="language-lean">example (p : Prop) : p ∨ p → p := by
  intro h
  cases h &lt;;&gt; assumption
</code></pre>
<!--
You can combine the unstructured ``cases`` tactic with the ``case`` and ``.`` notation.
-->
<p>你可以与 <code>.</code> 符号相结合使用非结构化的 <code>cases</code> 策略。</p>
<pre><code class="language-lean">example (p q : Prop) : p ∨ q → q ∨ p := by
  intro h
  cases h
  . apply Or.inr
    assumption
  . apply Or.inl
    assumption

example (p q : Prop) : p ∨ q → q ∨ p := by
  intro h
  cases h
  case inr h =&gt;
    apply Or.inl
    assumption
  case inl h =&gt;
    apply Or.inr
    assumption

example (p q : Prop) : p ∨ q → q ∨ p := by
  intro h
  cases h
  case inr h =&gt;
    apply Or.inl
    assumption
  . apply Or.inr
    assumption
</code></pre>
<!--
The ``cases`` tactic can also be used to
decompose a conjunction.
-->
<p><code>cases</code> 策略也被用来分解一个析取。</p>
<pre><code class="language-lean">example (p q : Prop) : p ∧ q → q ∧ p := by
  intro h
  cases h with
  | intro hp hq =&gt; constructor; exact hq; exact hp
</code></pre>
<!--
In this example, there is only one goal after the ``cases`` tactic is
applied, with ``h : p ∧ q`` replaced by a pair of assumptions,
``hp : p`` and ``hq : q``. The ``constructor`` tactic applies the unique
constructor for conjunction, ``And.intro``. With these tactics, an
example from the previous section can be rewritten as follows:
-->
<p>在这个例子中，应用 <code>cases</code> 策略后只有一个目标，<code>h : p ∧ q</code> 被一对假设取代，<code>hp : p</code> 和 <code>hq : q</code>。<code>constructor</code> 策略应用了唯一一个合取构造子 <code>And.intro</code>。有了这些策略，上一节的一个例子可以改写如下。</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := by
  apply Iff.intro
  . intro h
    cases h with
    | intro hp hqr =&gt;
      cases hqr
      . apply Or.inl; constructor &lt;;&gt; assumption
      . apply Or.inr; constructor &lt;;&gt; assumption
  . intro h
    cases h with
    | inl hpq =&gt;
      cases hpq with
      | intro hp hq =&gt; constructor; exact hp; apply Or.inl; exact hq
    | inr hpr =&gt;
      cases hpr with
      | intro hp hr =&gt; constructor; exact hp; apply Or.inr; exact hr
</code></pre>
<!--
You will see in [Chapter Inductive Types](./inductive_types.md) that
these tactics are quite general. The ``cases`` tactic can be used to
decompose any element of an inductively defined type; ``constructor``
always applies the first applicable constructor of an inductively defined type.
For example, you can use ``cases`` and ``constructor`` with an existential quantifier:
-->
<p>你将在<a href="./inductive_types.html">归纳类型</a>一章中看到，这些策略是相当通用的。<code>cases</code> 策略可以用来分解递归定义类型的任何元素；<code>constructor</code> 总是应用递归定义类型的第一个适用构造子。例如，你可以使用 <code>cases</code> 和 <code>constructor</code> 与一个存在量词：</p>
<pre><code class="language-lean">example (p q : Nat → Prop) : (∃ x, p x) → ∃ x, p x ∨ q x := by
  intro h
  cases h with
  | intro x px =&gt; constructor; apply Or.inl; exact px
</code></pre>
<!--
Here, the ``constructor`` tactic leaves the first component of the
existential assertion, the value of ``x``, implicit. It is represented
by a metavariable, which should be instantiated later on. In the
previous example, the proper value of the metavariable is determined
by the tactic ``exact px``, since ``px`` has type ``p x``. If you want
to specify a witness to the existential quantifier explicitly, you can
use the ``exists`` tactic instead:
-->
<p>在这里，<code>constructor</code> 策略将存在性断言的第一个组成部分，即 <code>x</code> 的值，保留为隐式的。它是由一个元变量表示的，这个元变量以后应该被实例化。在前面的例子中，元变量的正确值是由策略 <code>exact px</code> 决定的，因为 <code>px</code> 的类型是 <code>p x</code>。如果你想明确指定存在量词的存在者，你可以使用 <code>exists</code> 策略来代替。</p>
<pre><code class="language-lean">example (p q : Nat → Prop) : (∃ x, p x) → ∃ x, p x ∨ q x := by
  intro h
  cases h with
  | intro x px =&gt; exists x; apply Or.inl; exact px
</code></pre>
<!--
Here is another example:
-->
<p>另一个例子：</p>
<pre><code class="language-lean">example (p q : Nat → Prop) : (∃ x, p x ∧ q x) → ∃ x, q x ∧ p x := by
  intro h
  cases h with
  | intro x hpq =&gt;
    cases hpq with
    | intro hp hq =&gt;
      exists x
</code></pre>
<!--
These tactics can be used on data just as well as propositions. In the
next example, they are used to define functions which swap the
components of the product and sum types:
-->
<p>这些策略既可以用在命题上，也可以用在数上。在下面的两个例子中，它们被用来定义交换乘法和加法类型组件的函数：</p>
<pre><code class="language-lean">def swap_pair : α × β → β × α := by
  intro p
  cases p
  constructor &lt;;&gt; assumption

def swap_sum : Sum α β → Sum β α := by
  intro p
  cases p
  . apply Sum.inr; assumption
  . apply Sum.inl; assumption
</code></pre>
<!--
Note that up to the names we have chosen for the variables, the
definitions are identical to the proofs of the analogous propositions
for conjunction and disjunction. The ``cases`` tactic will also do a
case distinction on a natural number:
-->
<p>在我们为变量选择的名称之前，它们的定义与有关合取和析取的类似命题的证明是相同的。<code>cases</code> 策略也会对自然数进行逐情况区分：</p>
<pre><code class="language-lean">open Nat
example (P : Nat → Prop) (h₀ : P 0) (h₁ : ∀ n, P (succ n)) (m : Nat) : P m := by
  cases m with
  | zero    =&gt; exact h₀
  | succ m' =&gt; exact h₁ m'
</code></pre>
<!--
The ``cases`` tactic, and its companion, the ``induction`` tactic, are discussed in greater detail in
the [Tactics for Inductive Types](./inductive_types.md#tactics-for-inductive-types) section.

The ``contradiction`` tactic searches for a contradiction among the hypotheses of the current goal:
-->
<p><code>cases</code> 策略伙同 <code>induction</code> 策略将在<a href="./inductive_types.html#_tactics_for_inductive_types">归纳类型的策略</a>一节中详述。</p>
<p><code>contradiction</code> 策略搜索当前目标的假设中的矛盾：</p>
<pre><code class="language-lean">example (p q : Prop) : p ∧ ¬ p → q := by
  intro h
  cases h
  contradiction
</code></pre>
<!--
You can also use ``match`` in tactic blocks.
-->
<p>你也可以在策略块中使用 <code>match</code>：</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := by
  apply Iff.intro
  . intro h
    match h with
    | ⟨_, Or.inl _⟩ =&gt; apply Or.inl; constructor &lt;;&gt; assumption
    | ⟨_, Or.inr _⟩ =&gt; apply Or.inr; constructor &lt;;&gt; assumption
  . intro h
    match h with
    | Or.inl ⟨hp, hq⟩ =&gt; constructor; exact hp; apply Or.inl; exact hq
    | Or.inr ⟨hp, hr⟩ =&gt; constructor; exact hp; apply Or.inr; exact hr
</code></pre>
<!--
You can "combine" ``intro h`` with ``match h ...`` and write the previous examples as follows
-->
<p>你可以将 <code>intro h</code> 与 <code>match h ...</code> 结合起来，然后上例就可以如下地写出：</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := by
  apply Iff.intro
  . intro
    | ⟨hp, Or.inl hq⟩ =&gt; apply Or.inl; constructor &lt;;&gt; assumption
    | ⟨hp, Or.inr hr⟩ =&gt; apply Or.inr; constructor &lt;;&gt; assumption
  . intro
    | Or.inl ⟨hp, hq⟩ =&gt; constructor; assumption; apply Or.inl; assumption
    | Or.inr ⟨hp, hr⟩ =&gt; constructor; assumption; apply Or.inr; assumption
</code></pre>
<!--
Structuring Tactic Proofs
-------------------------
-->
<h2 id="结构化策略证明"><a class="header" href="#结构化策略证明">结构化策略证明</a></h2>
<!--
Tactics often provide an efficient way of building a proof, but long
sequences of instructions can obscure the structure of the
argument. In this section, we describe some means that help provide
structure to a tactic-style proof, making such proofs more readable
and robust.

One thing that is nice about Lean's proof-writing syntax is that it is
possible to mix term-style and tactic-style proofs, and pass between
the two freely. For example, the tactics ``apply`` and ``exact``
expect arbitrary terms, which you can write using ``have``, ``show``,
and so on. Conversely, when writing an arbitrary Lean term, you can
always invoke the tactic mode by inserting a ``by``
block. The following is a somewhat toy example:
-->
<p>策略通常提供了建立证明的有效方法，但一长串指令会掩盖论证的结构。在这一节中，我们将描述一些有助于为策略式证明提供结构的方法，使这种证明更易读，更稳健。</p>
<p>Lean 的证明写作语法的一个优点是，它可以混合项式和策略式证明，并在两者之间自由转换。例如，策略 <code>apply</code> 和 <code>exact</code> 可以传入任意的项，你可以用 <code>have</code>，<code>show</code> 等等来写这些项。反之，当写一个任意的 Lean 项时，你总是可以通过插入一个 <code>by</code> 块来调用策略模式。下面是一个简易例子：</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) → (p ∧ q) ∨ (p ∧ r) := by
  intro h
  exact
    have hp : p := h.left
    have hqr : q ∨ r := h.right
    show (p ∧ q) ∨ (p ∧ r) by
      cases hqr with
      | inl hq =&gt; exact Or.inl ⟨hp, hq⟩
      | inr hr =&gt; exact Or.inr ⟨hp, hr⟩
</code></pre>
<!--
The following is a more natural example:
-->
<p>更自然一点：</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := by
  apply Iff.intro
  . intro h
    cases h.right with
    | inl hq =&gt; exact Or.inl ⟨h.left, hq⟩
    | inr hr =&gt; exact Or.inr ⟨h.left, hr⟩
  . intro h
    cases h with
    | inl hpq =&gt; exact ⟨hpq.left, Or.inl hpq.right⟩
    | inr hpr =&gt; exact ⟨hpr.left, Or.inr hpr.right⟩
</code></pre>
<!--
In fact, there is a ``show`` tactic, which is similar to the
``show`` expression in a proof term. It simply declares the type of the
goal that is about to be solved, while remaining in tactic
mode.
-->
<p>事实上，有一个 <code>show</code> 策略，它类似于证明项中的 <code>show</code> 表达式。它只是简单地声明即将被解决的目标的类型，同时保持策略模式。</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := by
  apply Iff.intro
  . intro h
    cases h.right with
    | inl hq =&gt;
      show (p ∧ q) ∨ (p ∧ r)
      exact Or.inl ⟨h.left, hq⟩
    | inr hr =&gt;
      show (p ∧ q) ∨ (p ∧ r)
      exact Or.inr ⟨h.left, hr⟩
  . intro h
    cases h with
    | inl hpq =&gt;
      show p ∧ (q ∨ r)
      exact ⟨hpq.left, Or.inl hpq.right⟩
    | inr hpr =&gt;
      show p ∧ (q ∨ r)
      exact ⟨hpr.left, Or.inr hpr.right⟩
</code></pre>
<!--
The ``show`` tactic can actually be used to rewrite a goal to something definitionally equivalent:
-->
<p><code>show</code> 策略其实可以被用来重写一些定义等价的目标：</p>
<pre><code class="language-lean">example (n : Nat) : n + 1 = Nat.succ n := by
  show Nat.succ n = Nat.succ n
  rfl
</code></pre>
<!--
There is also a ``have`` tactic, which introduces a new subgoal, just as when writing proof terms:
-->
<p>还有一个 <code>have</code> 策略，它引入了一个新的子目标，就像写证明项时一样。</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) → (p ∧ q) ∨ (p ∧ r) := by
  intro ⟨hp, hqr⟩
  show (p ∧ q) ∨ (p ∧ r)
  cases hqr with
  | inl hq =&gt;
    have hpq : p ∧ q := And.intro hp hq
    apply Or.inl
    exact hpq
  | inr hr =&gt;
    have hpr : p ∧ r := And.intro hp hr
    apply Or.inr
    exact hpr
</code></pre>
<!--
As with proof terms, you can omit the label in the ``have`` tactic, in
which case, the default label ``this`` is used:
-->
<p>与证明项一样，你可以省略 <code>have</code> 策略中的标签，在这种情况下，将使用默认标签 <code>this</code>：</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) → (p ∧ q) ∨ (p ∧ r) := by
  intro ⟨hp, hqr⟩
  show (p ∧ q) ∨ (p ∧ r)
  cases hqr with
  | inl hq =&gt;
    have : p ∧ q := And.intro hp hq
    apply Or.inl
    exact this
  | inr hr =&gt;
    have : p ∧ r := And.intro hp hr
    apply Or.inr
    exact this
</code></pre>
<!--
The types in a ``have`` tactic can be omitted, so you can write ``have
hp := h.left`` and ``have hqr := h.right``.  In fact, with this
notation, you can even omit both the type and the label, in which case
the new fact is introduced with the label ``this``.
-->
<p><code>have</code> 策略中的类型可以省略，所以你可以写 <code>have hp := h.left</code> 和 <code>have hqr := h.right</code>。 事实上，使用这种符号，你甚至可以省略类型和标签，在这种情况下，新的事实是用标签 <code>this</code> 引入的。</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) → (p ∧ q) ∨ (p ∧ r) := by
  intro ⟨hp, hqr⟩
  cases hqr with
  | inl hq =&gt;
    have := And.intro hp hq
    apply Or.inl; exact this
  | inr hr =&gt;
    have := And.intro hp hr
    apply Or.inr; exact this
</code></pre>
<!--
Lean also has a ``let`` tactic, which is similar to the ``have``
tactic, but is used to introduce local definitions instead of
auxiliary facts. It is the tactic analogue of a ``let`` in a proof
term.
-->
<p>Lean 还有一个 <code>let</code> 策略，与 <code>have</code> 策略类似，但用于引入局部定义而不是辅助事实。它是证明项中 <code>let</code> 的策略版。</p>
<pre><code class="language-lean">example : ∃ x, x + 2 = 8 := by
  let a : Nat := 3 * 2
  exists a
</code></pre>
<!--
As with ``have``, you can leave the type implicit by writing ``let a
:= 3 * 2``. The difference between ``let`` and ``have`` is that
``let`` introduces a local definition in the context, so that the
definition of the local declaration can be unfolded in the proof.

We have used ``.`` to create nested tactic blocks.  In a nested block,
Lean focuses on the first goal, and generates an error if it has not
been fully solved at the end of the block. This can be helpful in
indicating the separate proofs of multiple subgoals introduced by a
tactic. The notation ``.`` is whitespace sensitive and relies on the indentation
to detect whether the tactic block ends. Alternatively, you can
define tactic blocks using curly braces and semicolons.
-->
<p>和 <code>have</code> 一样，你可以通过写 <code>let a := 3 * 2</code> 来保留类型为隐式。<code>let</code> 和 <code>have</code> 的区别在于，<code>let</code> 在上下文中引入了一个局部定义，因此局部声明的定义可以在证明中展开。</p>
<p>我们使用了<code>.</code>来创建嵌套的策略块。 在一个嵌套块中，Lean 专注于第一个目标，如果在该块结束时还没有完全解决，就会产生一个错误。这对于表明一个策略所引入的多个子目标的单独证明是有帮助的。符号 <code>.</code> 是对空格敏感的，并且依靠缩进来检测策略块是否结束。另外，你也可以用大括号和分号来定义策略块。</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := by
  apply Iff.intro
  { intro h;
    cases h.right;
    { show (p ∧ q) ∨ (p ∧ r);
      exact Or.inl ⟨h.left, ‹q›⟩ }
    { show (p ∧ q) ∨ (p ∧ r);
      exact Or.inr ⟨h.left, ‹r›⟩ } }
  { intro h;
    cases h;
    { show p ∧ (q ∨ r);
      rename_i hpq;
      exact ⟨hpq.left, Or.inl hpq.right⟩ }
    { show p ∧ (q ∨ r);
      rename_i hpr;
      exact ⟨hpr.left, Or.inr hpr.right⟩ } }
</code></pre>
<!--
It is useful to use indentation to structure proof: every time a tactic
leaves more than one subgoal, we separate the remaining subgoals by
enclosing them in blocks and indenting.  Thus if the application of
theorem ``foo`` to a single goal produces four subgoals, one would
expect the proof to look like this:
-->
<p>使用缩进来构造证明很有用：每次一个策略留下一个以上的子目标时，我们通过将它们封装在块中并缩进来分隔剩下的子目标。因此，如果将定理 <code>foo</code> 应用于一个目标产生了四个子目标，那么我们就可以期待这样的证明：</p>
<pre><code>  apply foo
  . &lt;proof of first goal&gt;
  . &lt;proof of second goal&gt;
  . &lt;proof of third goal&gt;
  . &lt;proof of final goal&gt;
</code></pre>
<!--
or
-->
<p>或</p>
<pre><code>  apply foo
  case &lt;tag of first goal&gt;  =&gt; &lt;proof of first goal&gt;
  case &lt;tag of second goal&gt; =&gt; &lt;proof of second goal&gt;
  case &lt;tag of third goal&gt;  =&gt; &lt;proof of third goal&gt;
  case &lt;tag of final goal&gt;  =&gt; &lt;proof of final goal&gt;
</code></pre>
<!--
or
-->
<p>或</p>
<pre><code>  apply foo
  { &lt;proof of first goal&gt;  }
  { &lt;proof of second goal&gt; }
  { &lt;proof of third goal&gt;  }
  { &lt;proof of final goal&gt;  }
</code></pre>
<!--
Tactic Combinators
------------------
-->
<h2 id="策略组合器"><a class="header" href="#策略组合器">策略组合器</a></h2>
<!--
*Tactic combinators* are operations that form new tactics from old
ones. A sequencing combinator is already implicit in the ``by`` block:
-->
<p><strong>策略组合器</strong> 是由旧策略形成新策略的操作。<code>by</code> 隐含了一个序列组合器：</p>
<pre><code class="language-lean">example (p q : Prop) (hp : p) : p ∨ q :=
  by apply Or.inl; assumption
</code></pre>
<!--
Here, ``apply Or.inl; assumption`` is functionally equivalent to a
single tactic which first applies ``apply Or.inl`` and then applies
``assumption``.

In ``t₁ <;> t₂``, the ``<;>`` operator provides a *parallel* version of the sequencing operation:
``t₁`` is applied to the current goal, and then ``t₂`` is applied to *all* the resulting subgoals:
-->
<p>这里，<code>apply Or.inl; assumption</code>在功能上等同于一个单独的策略，它首先应用<code>apply Or.inl</code>，然后应用 <code>assumption</code>。</p>
<p>在<code>t₁ &lt;;&gt; t₂</code>中，<code>&lt;;&gt;</code>操作符提供了一个<em>并行</em>的序列操作。<code>t₁</code>被应用于当前目标，然后<code>t₂</code>被应用于<em>所有</em>产生的子目标：</p>
<pre><code class="language-lean">example (p q : Prop) (hp : p) (hq : q) : p ∧ q :=
  by constructor &lt;;&gt; assumption
</code></pre>
<!--
This is especially useful when the resulting goals can be finished off
in a uniform way, or, at least, when it is possible to make progress
on all of them uniformly.

The ``first | t₁ | t₂ | ... | tₙ`` applies each `tᵢ` until one succeeds, or else fails:
-->
<p>当所产生的目标能够以统一的方式完成时，或者，至少，当有可能以统一的方式在所有的目标上取得进展时，这就特别有用。</p>
<p><code>first | t₁ | t₂ | ... | tₙ</code> 应用每$1 $2，直到其中一个成功，否则就失败：</p>
<pre><code class="language-lean">example (p q : Prop) (hp : p) : p ∨ q := by
  first | apply Or.inl; assumption | apply Or.inr; assumption

example (p q : Prop) (hq : q) : p ∨ q := by
  first | apply Or.inl; assumption | apply Or.inr; assumption
</code></pre>
<!--
In the first example, the left branch succeeds, whereas in the second one, it is the right one that succeeds.
In the next three examples, the same compound tactic succeeds in each case.
-->
<p>在第一个例子中，左分支成功了，而在第二个例子中，右分支成功了。在接下来的三个例子中，同样的复合策略在每种情况下都能成功。</p>
<pre><code class="language-lean">example (p q r : Prop) (hp : p) : p ∨ q ∨ r :=
  by repeat (first | apply Or.inl; assumption | apply Or.inr | assumption)

example (p q r : Prop) (hq : q) : p ∨ q ∨ r :=
  by repeat (first | apply Or.inl; assumption | apply Or.inr | assumption)

example (p q r : Prop) (hr : r) : p ∨ q ∨ r :=
  by repeat (first | apply Or.inl; assumption | apply Or.inr | assumption)
</code></pre>
<!--
The tactic tries to solve the left disjunct immediately by assumption;
if that fails, it tries to focus on the right disjunct; and if that
doesn't work, it invokes the assumption tactic.

You will have no doubt noticed by now that tactics can fail. Indeed,
it is the "failure" state that causes the *first* combinator to
backtrack and try the next tactic. The ``try`` combinator builds a
tactic that always succeeds, though possibly in a trivial way:
``try t`` executes ``t`` and reports success, even if ``t`` fails. It is
equivalent to ``first | t | skip``, where ``skip`` is a tactic that does
nothing (and succeeds in doing so). In the next example, the second
``constructor`` succeeds on the right conjunct ``q ∧ r`` (remember that
disjunction and conjunction associate to the right) but fails on the
first. The ``try`` tactic ensures that the sequential composition
succeeds.
-->
<p>该策略试图通过假设立即解决左边的析取项；如果失败，它就试图关注右边的析取项；如果不成功，它就调用假设策略。</p>
<p>毫无疑问，策略可能会失败。事实上，正是这种「失败」状态导致 <code>first</code> 组合器回溯并尝试下一个策略。<code>try</code> 组合器建立了一个总是成功的策略，尽管可能是以一种平凡的方式：<code>try t</code> 执行 <code>t</code> 并报告成功，即使 <code>t</code> 失败。它等同于 <code>first | t | skip</code>，其中 <code>skip</code> 是一个什么都不做的策略（并且成功地做到了「什么都不做」）。在下一个例子中，第二个 <code>constructor</code> 在右边的合取项 <code>q ∧ r</code> 上成功了（注意，合取和析取是右结合的），但在第一个合取项上失败。<code>try</code> 策略保证了序列组合的成功。</p>
<pre><code class="language-lean">example (p q r : Prop) (hp : p) (hq : q) (hr : r) : p ∧ q ∧ r := by
  constructor &lt;;&gt; (try constructor) &lt;;&gt; assumption
</code></pre>
<!--
Be careful: ``repeat (try t)`` will loop forever, because the inner tactic never fails.

In a proof, there are often multiple goals outstanding. Parallel
sequencing is one way to arrange it so that a single tactic is applied
to multiple goals, but there are other ways to do this. For example,
``all_goals t`` applies ``t`` to all open goals:
-->
<p>小心：<code>repeat (try t)</code> 将永远循环，因为内部策略永远不会失败。</p>
<p>在一个证明中，往往有多个目标未完成。并行序列是一种布置方式，以便将一个策略应用于多个目标，但也有其他的方式可以做到这一点。例如，<code>all_goals t</code>将 <code>t</code> 应用于所有未完成的目标：</p>
<pre><code class="language-lean">example (p q r : Prop) (hp : p) (hq : q) (hr : r) : p ∧ q ∧ r := by
  constructor
  all_goals (try constructor)
  all_goals assumption
</code></pre>
<!--
In this case, the ``any_goals`` tactic provides a more robust solution.
It is similar to ``all_goals``, except it succeeds if its argument
succeeds on at least one goal.
-->
<p>在这种情况下，<code>any_goals</code> 策略提供了一个更稳健的解决方案。它与 <code>all_goals</code> 类似，只是除非它的参数至少在一个目标上成功，否则就会失败。</p>
<pre><code class="language-lean">example (p q r : Prop) (hp : p) (hq : q) (hr : r) : p ∧ q ∧ r := by
  constructor
  any_goals constructor
  any_goals assumption
</code></pre>
<!--
The first tactic in the ``by`` block below repeatedly splits
conjunctions:
-->
<p>下面 <code>by</code> 块中的第一个策略是反复拆分合取：</p>
<pre><code class="language-lean">example (p q r : Prop) (hp : p) (hq : q) (hr : r) :
      p ∧ ((p ∧ q) ∧ r) ∧ (q ∧ r ∧ p) := by
  repeat (any_goals constructor)
  all_goals assumption
</code></pre>
<!--
In fact, we can compress the full tactic down to one line:
-->
<p>其实可以将整个策略压缩成一行：</p>
<pre><code class="language-lean">example (p q r : Prop) (hp : p) (hq : q) (hr : r) :
      p ∧ ((p ∧ q) ∧ r) ∧ (q ∧ r ∧ p) := by
  repeat (any_goals (first | constructor | assumption))
</code></pre>
<!--
The combinator ``focus t`` ensures that ``t`` only effects the current
goal, temporarily hiding the others from the scope. So, if ``t``
ordinarily only effects the current goal, ``focus (all_goals t)`` has
the same effect as ``t``.
-->
<p>组合器 <code>focus t</code> 确保 <code>t</code> 只影响当前的目标，暂时将其他目标从作用范围中隐藏。因此，如果 <code>t</code> 通常只影响当前目标，<code>focus (all_goals t)</code>与 <code>t</code> 具有相同的效果。</p>
<!--
Rewriting
---------
-->
<h2 id="重写"><a class="header" href="#重写">重写</a></h2>
<!--
The ``rewrite`` tactic (abbreviated ``rw``) and the ``simp`` tactic
were introduced briefly in [Calculational Proofs](./quantifiers_and_equality.md#calculational-proofs). In this
section and the next, we discuss them in greater detail.

The ``rewrite`` tactic provides a basic mechanism for applying
substitutions to goals and hypotheses, providing a convenient and
efficient way of working with equality. The most basic form of the
tactic is ``rewrite [t]``, where ``t`` is a term whose type asserts an
equality. For example, ``t`` can be a hypothesis ``h : x = y`` in the
context; it can be a general lemma, like
``add_comm : ∀ x y, x + y = y + x``, in which the rewrite tactic tries to find suitable
instantiations of ``x`` and ``y``; or it can be any compound term
asserting a concrete or general equation. In the following example, we
use this basic form to rewrite the goal using a hypothesis.
-->
<p>在<a href="./quantifiers_and_equality.html#%E8%AE%A1%E7%AE%97%E5%BC%8F%E8%AF%81%E6%98%8E">计算式证明</a>一节中简要介绍了 <code>rewrite</code> 策略（简称 <code>rw</code>）和 <code>simp</code> 策略。在本节和下一节中，我们将更详细地讨论它们。</p>
<p><code>rewrite</code> 策略提供了一种基本的机制，可以将替换应用于目标和假设，在处理等式时非常方便。该策略的最基本形式是 <code>rewrite [t]</code>，其中 <code>t</code> 是一个类型断定为等式的项。例如，<code>t</code> 可以是上下文中的一个假设<code>h : x = y</code>；可以是一个一般的法则，如<code>add_comm : ∀ x y, x + y = y + x</code>，在这个法则中，重写策略试图找到 <code>x</code> 和 <code>y</code> 的合适实例；或者可以是任何断言具体或一般等式的复合项。在下面的例子中，我们使用这种基本形式，用一个假设重写目标。</p>
<!--
```lean
example (f : Nat → Nat) (k : Nat) (h₁ : f 0 = 0) (h₂ : k = 0) : f k = 0 := by
  rw [h₂] -- replace k with 0
  rw [h₁] -- replace f 0 with 0
```
-->
<pre><code class="language-lean">example (f : Nat → Nat) (k : Nat) (h₁ : f 0 = 0) (h₂ : k = 0) : f k = 0 := by
  rw [h₂] -- 用 0 换掉 k
  rw [h₁] -- 用 0 换掉 f 0
</code></pre>
<!--
In the example above, the first use of ``rw`` replaces ``k`` with
``0`` in the goal ``f k = 0``. Then, the second one replaces ``f 0``
with ``0``. The tactic automatically closes any goal of the form
``t = t``. Here is an example of rewriting using a compound expression:
-->
<p>在上面的例子中，第一次使用 <code>rw</code> 将目标 <code>f k = 0</code> 中的 <code>k</code> 替换成 <code>0</code>。然后，第二次用 <code>0</code> 替换 <code>f 0</code>。该策略自动关闭任何形式的目标<code>t = t</code>。下面是一个使用复合表达式进行重写的例子。</p>
<pre><code class="language-lean">example (x y : Nat) (p : Nat → Prop) (q : Prop) (h : q → x = y)
        (h' : p y) (hq : q) : p x := by
  rw [h hq]; assumption
</code></pre>
<!--
Here, ``h hq`` establishes the equation ``x = y``.

Multiple rewrites can be combined using the notation ``rw [t_1, ..., t_n]``,
which is just shorthand for ``rw [t_1]; ...; rw [t_n]``. The previous example can be written as follows:
-->
<p>这里，<code>h hq</code> 建立了等式 <code>x = y</code>。<code>h hq</code> 周围的括号是不必要的，但为了清楚起见，还是加上了括号。</p>
<p>多个重写可以使用符号<code>rw [t_1, ..., t_n]</code>来组合，这只是<code>rw t_1; ...; rw t_n</code>的缩写。前面的例子可以写成如下：</p>
<pre><code class="language-lean">example (f : Nat → Nat) (k : Nat) (h₁ : f 0 = 0) (h₂ : k = 0) : f k = 0 := by
  rw [h₂, h₁]
</code></pre>
<!--
By default, ``rw`` uses an equation in the forward direction, matching
the left-hand side with an expression, and replacing it with the
right-hand side. The notation ``←t`` can be used to instruct the
tactic to use the equality ``t`` in the reverse direction.
-->
<p>默认情况下，<code>rw</code> 正向使用一个等式，用一个表达式匹配左边的等式，然后用右边的等式替换它。符号 <code>←t</code> 可以用来指示策略在反方向上使用等式 <code>t</code>。</p>
<pre><code class="language-lean">example (f : Nat → Nat) (a b : Nat) (h₁ : a = b) (h₂ : f a = 0) : f b = 0 := by
  rw [←h₁, h₂]
</code></pre>
<!--
In this example, the term ``←h₁`` instructs the rewriter to replace
``b`` with ``a``. In the editors, you can type the backwards arrow as
``\l``. You can also use the ascii equivalent, ``<-``.

Sometimes the left-hand side of an identity can match more than one
subterm in the pattern, in which case the ``rw`` tactic chooses the
first match it finds when traversing the term. If that is not the one
you want, you can use additional arguments to specify the appropriate
subterm.
-->
<p>在这个例子中，项 <code>←h₁</code> 指示重写器用 <code>a</code> 替换 <code>b</code>。在编辑器中，你可以用 <code>\l</code> 输入反箭头。你也可以使用 ascii 替代品 <code>&lt;-</code>。</p>
<p>有时一个等式的左侧可以匹配模式中的多个子项，在这种情况下，<code>rw</code> 策略会在遍历项时选择它发现的第一个匹配。如果这不是你想要的，你可以使用附加参数来指定适当的子项。</p>
<pre><code class="language-lean">example (a b c : Nat) : a + b + c = a + c + b := by
  rw [Nat.add_assoc, Nat.add_comm b, ← Nat.add_assoc]

example (a b c : Nat) : a + b + c = a + c + b := by
  rw [Nat.add_assoc, Nat.add_assoc, Nat.add_comm b]

example (a b c : Nat) : a + b + c = a + c + b := by
  rw [Nat.add_assoc, Nat.add_assoc, Nat.add_comm _ b]
</code></pre>
<!--
In the first example above, the first step rewrites ``a + b + c`` to
``a + (b + c)``. The next step applies commutativity to the term
``b + c``; without specifying the argument, the tactic would instead rewrite
``a + (b + c)`` to ``(b + c) + a``. Finally, the last step applies
associativity in the reverse direction, rewriting ``a + (c + b)`` to
``a + c + b``. The next two examples instead apply associativity to
move the parenthesis to the right on both sides, and then switch ``b``
and ``c``. Notice that the last example specifies that the rewrite
should take place on the right-hand side by specifying the second
argument to ``Nat.add_comm``.

By default, the ``rewrite`` tactic affects only the goal. The notation
``rw [t] at h`` applies the rewrite ``t`` at hypothesis ``h``.
-->
<p>在上面的第一个例子中，第一步将 <code>a + b + c</code> 重写为 <code>a + (b + c)</code>。然后，接下来对项 <code>b + c</code> 使用交换律；如果不指定参数，该策略将把 <code>a + (b + c)</code> 重写为 <code>(b + c) + a</code>。最后一步以相反的方向应用结合律，将<code>a + (c + b)</code>改写为 <code>a + c + b</code>。接下来的两个例子则是应用结合律将两边的小括号移到右边，然后将 <code>b</code> 和 <code>c</code> 调换。注意最后一个例子通过指定 <code>Nat.add_comm</code> 的第二个参数来指定重写应该在右侧进行。</p>
<p>默认情况下，<code>rewrite</code> 策略只影响目标。符号 <code>rw [t] at h</code> 在假设 <code>h</code> 处应用重写 <code>t</code>。</p>
<pre><code class="language-lean">example (f : Nat → Nat) (a : Nat) (h : a + 0 = 0) : f a = f 0 := by
  rw [Nat.add_zero] at h
  rw [h]
</code></pre>
<!--
The first step, ``rw [Nat.add_zero] at h``, rewrites the hypothesis ``a + 0 = 0`` to ``a = 0``.
Then the new hypothesis ``a = 0`` is used to rewrite the goal to ``f 0 = f 0``.

The ``rewrite`` tactic is not restricted to propositions.
In the following example, we use ``rw [h] at t`` to rewrite the hypothesis ``t : Tuple α n`` to ``t : Tuple α 0``.
-->
<p>第一步，<code>rw [Nat.add_zero] at h</code> 将假设 <code>a + 0 = 0</code> 改写为 <code>a = 0</code>。然后，新的假设<code>a = 0</code>被用来把目标重写为<code>f 0 = f 0</code>。</p>
<p><code>rewrite</code> 策略不限于命题。在下面的例子中，我们用<code>rw [h] at t</code>来重写假设<code>t : Tuple α n</code>为<code>t : Tuple α 0</code>。</p>
<pre><code class="language-lean">def Tuple (α : Type) (n : Nat) :=
  { as : List α // as.length = n }

example (n : Nat) (h : n = 0) (t : Tuple α n) : Tuple α 0 := by
  rw [h] at t
  exact t
</code></pre>
<!--
Using the Simplifier
--------------------
-->
<h2 id="简化"><a class="header" href="#简化">简化</a></h2>
<!--
Whereas ``rewrite`` is designed as a surgical tool for manipulating a
goal, the simplifier offers a more powerful form of automation. A
number of identities in Lean's library have been tagged with the
``[simp]`` attribute, and the ``simp`` tactic uses them to iteratively
rewrite subterms in an expression.
-->
<p><code>rewrite</code> 被设计为操纵目标的手术刀，而简化器提供了一种更强大的自动化形式。Lean 库中的一些特性已经被标记为<code>[simp]</code>属性，<code>simp</code> 策略使用它们来反复重写表达式中的子项。</p>
<pre><code class="language-lean">example (x y z : Nat) : (x + 0) * (0 + y * 1 + z * 0) = x * y := by
  simp

example (x y z : Nat) (p : Nat → Prop) (h : p (x * y))
        : p ((x + 0) * (0 + y * 1 + z * 0)) := by
  simp; assumption
</code></pre>
<!--
In the first example, the left-hand side of the equality in the goal
is simplified using the usual identities involving 0 and 1, reducing
the goal to ``x * y = x * y``. At that point, ``simp`` applies
reflexivity to finish it off. In the second example, ``simp`` reduces
the goal to ``p (x * y)``, at which point the assumption ``h``
finishes it off. Here are some more examples
with lists:
-->
<p>在第一个例子中，目标中等式的左侧被简化，使用涉及0和1的通常的同义词，将目标简化为<code>x * y = x * y'</code>。此时<code>simp'</code>应用反身性（rfl）来完成它。在第二个例子中，<code>simp</code> 将目标化简为<code>p (x * y)</code>，这时假设 <code>h</code> 完成了它。下面是一些关于列表的例子。</p>
<pre><code class="language-lean">open List

example (xs : List Nat)
        : reverse (xs ++ [1, 2, 3]) = [3, 2, 1] ++ reverse xs := by
  simp

example (xs ys : List α)
        : length (reverse (xs ++ ys)) = length xs + length ys := by
  simp [Nat.add_comm]
</code></pre>
<!--
As with ``rw``, you can use the keyword ``at`` to simplify a hypothesis:
-->
<p>就像 <code>rw</code>，你也可以用关键字 <code>at</code> 来简化一个假设：</p>
<pre><code class="language-lean">example (x y z : Nat) (p : Nat → Prop)
        (h : p ((x + 0) * (0 + y * 1 + z * 0))) : p (x * y) := by
  simp at h; assumption
</code></pre>
<!--
Moreover, you can use a "wildcard" asterisk to simplify all the hypotheses and the goal:
-->
<p>此外，你可以使用一个「通配符」星号来简化所有的假设和目标：</p>
<pre><code class="language-lean">attribute [local simp] Nat.mul_comm Nat.mul_assoc Nat.mul_left_comm
attribute [local simp] Nat.add_assoc Nat.add_comm Nat.add_left_comm

example (w x y z : Nat) (p : Nat → Prop)
        (h : p (x * y + z * w * x)) : p (x * w * z + y * x) := by
  simp at *; assumption

example (x y z : Nat) (p : Nat → Prop)
        (h₁ : p (1 * x + y)) (h₂ : p (x * z * 1))
        : p (y + 0 + x) ∧ p (z * x) := by
  simp at * &lt;;&gt; constructor &lt;;&gt; assumption
</code></pre>
<!--
For operations that are commutative and associative, like
multiplication on the natural numbers, the simplifier uses these two
facts to rewrite an expression, as well as *left commutativity*. In
the case of multiplication the latter is expressed as follows:
``x * (y * z) = y * (x * z)``. The ``local`` modifier tells the simplifier
to use these rules in the current file (or section or namespace, as
the case may be). It may seem that commutativity and
left-commutativity are problematic, in that repeated application of
either causes looping. But the simplifier detects identities that
permute their arguments, and uses a technique known as *ordered
rewriting*. This means that the system maintains an internal ordering
of terms, and only applies the identity if doing so decreases the
order. With the three identities mentioned above, this has the effect
that all the parentheses in an expression are associated to the right,
and the expressions are ordered in a canonical (though somewhat
arbitrary) way. Two expressions that are equivalent up to
associativity and commutativity are then rewritten to the same
canonical form.
-->
<p>上例中前两行的意思是，对于具有交换律和结合律的运算（如自然数的加法和乘法），简化器使用这两个定律来重写表达式，同时还使用<em>左交换律</em>。在乘法的情况下，左交换律表达如下：<code>x * (y * z) = y * (x * z)</code>。<code>local</code> 修饰符告诉简化器在当前文件（或小节或命名空间，视情况而定）中使用这些规则。交换律和左交换律是有一个问题是，重复应用其中一个会导致循环。但是简化器检测到了对其参数进行置换的特性，并使用了一种被称为<em>有序重写</em>的技术。这意味着系统保持着项的内部次序，只有在这样做会降低次序的情况下才会应用等式。对于上面提到的三个等式，其效果是表达式中的所有小括号都被结合到右边，并且表达式以一种规范的（尽管有些随意）方式排序。两个在交换律和结合律上等价的表达式然后被改写成相同的规范形式。</p>
<pre><code class="language-lean"><span class="boring">attribute [local simp] Nat.mul_comm Nat.mul_assoc Nat.mul_left_comm
</span><span class="boring">attribute [local simp] Nat.add_assoc Nat.add_comm Nat.add_left_comm
</span>example (w x y z : Nat) (p : Nat → Prop)
        : x * y + z * w * x = x * w * z + y * x := by
  simp

example (w x y z : Nat) (p : Nat → Prop)
        (h : p (x * y + z * w * x)) : p (x * w * z + y * x) := by
  simp; simp at h; assumption
</code></pre>
<!--
As with ``rewrite``, you can send ``simp`` a list of facts to use,
including general lemmas, local hypotheses, definitions to unfold, and
compound expressions. The ``simp`` tactic also recognizes the ``←t``
syntax that ``rewrite`` does. In any case, the additional rules are
added to the collection of identities that are used to simplify a
term.
-->
<p>与 <code>rewrite</code> 一样，你可以向 <code>simp</code> 提供一个要使用的事实列表，包括一般引理、局部假设、要展开的定义和复合表达式。<code>simp</code> 策略也能识别 <code>rewrite</code> 的<code>←t</code>语法。在任何情况下，额外的规则都会被添加到用于简化项的等式集合中。</p>
<pre><code class="language-lean">def f (m n : Nat) : Nat :=
  m + n + m

example {m n : Nat} (h : n = 1) (h' : 0 = m) : (f m n) = n := by
  simp [h, ←h', f]
</code></pre>
<!--
A common idiom is to simplify a goal using local hypotheses:
-->
<p>一个常见的习惯是用局部假设来简化一个目标：</p>
<pre><code class="language-lean">example (f : Nat → Nat) (k : Nat) (h₁ : f 0 = 0) (h₂ : k = 0) : f k = 0 := by
  simp [h₁, h₂]
</code></pre>
<!--
To use all the hypotheses present in the local context when
simplifying, we can use the wildcard symbol, ``*``:
-->
<p>为了在简化时使用局部环境中存在的所有假设，我们可以使用通配符 <code>*</code>：</p>
<pre><code class="language-lean">example (f : Nat → Nat) (k : Nat) (h₁ : f 0 = 0) (h₂ : k = 0) : f k = 0 := by
  simp [*]
</code></pre>
<!--
Here is another example:
-->
<p>另一例：</p>
<pre><code class="language-lean">example (u w x y z : Nat) (h₁ : x = y + z) (h₂ : w = u + x)
        : w = z + y + u := by
  simp [*, Nat.add_assoc, Nat.add_comm, Nat.add_left_comm]
</code></pre>
<!--
The simplifier will also do propositional rewriting. For example,
using the hypothesis ``p``, it rewrites ``p ∧ q`` to ``q`` and ``p ∨
q`` to ``true``, which it then proves trivially. Iterating such
rewrites produces nontrivial propositional reasoning.
-->
<p>简化器也会进行命题重写。例如，使用假设 <code>p</code>，它把 <code>p ∧ q</code> 改写为 <code>q</code>，把 <code>p ∨ q</code> 改写为 <code>true</code>，然后以普通方式证明。迭代这样的重写，会生成非平凡的命题推理。</p>
<pre><code class="language-lean">example (p q : Prop) (hp : p) : p ∧ q ↔ q := by
  simp [*]

example (p q : Prop) (hp : p) : p ∨ q := by
  simp [*]

example (p q r : Prop) (hp : p) (hq : q) : p ∧ (q ∨ r) := by
  simp [*]
</code></pre>
<!--
The next example simplifies all the hypotheses, and then uses them to prove the goal.
-->
<p>下一个例子简化了所有的假设，然后用这些假设来证明目标。</p>
<pre><code class="language-lean">example (u w x x' y y' z : Nat) (p : Nat → Prop)
        (h₁ : x + 0 = x') (h₂ : y + 0 = y')
        : x + y + 0 = x' + y' := by
  simp at *
  simp [*]
</code></pre>
<!--
One thing that makes the simplifier especially useful is that its
capabilities can grow as a library develops. For example, suppose we
define a list operation that symmetrizes its input by appending its
reversal:
-->
<p>使得简化器特别有用的一点是，它的能力可以随着规则库的发展而增强。例如，假设我们定义了一个列表操作，该操作通过拼接其反转来对称其输入：</p>
<pre><code class="language-lean">def mk_symm (xs : List α) :=
  xs ++ xs.reverse
</code></pre>
<!--
Then for any list ``xs``, ``reverse (mk_symm xs)`` is equal to ``mk_symm xs``,
which can easily be proved by unfolding the definition:
-->
<p>那么对于任何列表 <code>xs</code>，<code>reverse (mk_symm xs)</code> 等于 <code>mk_symm xs</code>，这可以通过展开定义轻松证明：</p>
<pre><code class="language-lean"><span class="boring">def mk_symm (xs : List α) :=
</span><span class="boring"> xs ++ xs.reverse
</span>theorem reverse_mk_symm (xs : List α)
        : (mk_symm xs).reverse = mk_symm xs := by
  simp [mk_symm]
</code></pre>
<!--
We can now use this theorem to prove new results:
-->
<p>你可以使用这个定理来证明一些新结果：</p>
<pre><code class="language-lean"><span class="boring">def mk_symm (xs : List α) :=
</span><span class="boring"> xs ++ xs.reverse
</span><span class="boring">theorem reverse_mk_symm (xs : List α)
</span><span class="boring">       : (mk_symm xs).reverse = mk_symm xs := by
</span><span class="boring"> simp [mk_symm]
</span>example (xs ys : List Nat)
        : (xs ++ mk_symm ys).reverse = mk_symm ys ++ xs.reverse := by
  simp [reverse_mk_symm]

example (xs ys : List Nat) (p : List Nat → Prop)
        (h : p (xs ++ mk_symm ys).reverse)
        : p (mk_symm ys ++ xs.reverse) := by
  simp [reverse_mk_symm] at h; assumption
</code></pre>
<!--
But using ``reverse_mk_symm`` is generally the right thing to do, and
it would be nice if users did not have to invoke it explicitly. You can
achieve that by marking it as a simplification rule when the theorem
is defined:
-->
<p>但是使用 <code>reverse_mk_symm</code> 通常是正确的，如果用户不需要明确地调用它，那就更好了。你可以通过在定义该定理时将其标记为简化规则来实现这一点：</p>
<pre><code class="language-lean"><span class="boring">def mk_symm (xs : List α) :=
</span><span class="boring"> xs ++ xs.reverse
</span>@[simp] theorem reverse_mk_symm (xs : List α)
        : (mk_symm xs).reverse = mk_symm xs := by
  simp [mk_symm]

example (xs ys : List Nat)
        : (xs ++ mk_symm ys).reverse = mk_symm ys ++ xs.reverse := by
  simp

example (xs ys : List Nat) (p : List Nat → Prop)
        (h : p (xs ++ mk_symm ys).reverse)
        : p (mk_symm ys ++ xs.reverse) := by
  simp at h; assumption
</code></pre>
<!--
The notation ``@[simp]`` declares ``reverse_mk_symm`` to have the
``[simp]`` attribute, and can be spelled out more explicitly:
-->
<p>符号 <code>@[simp]</code> 声明 <code>reverse_mk_symm</code> 具有 <code>[simp]</code> 属性，可以更明确地说明：</p>
<pre><code class="language-lean"><span class="boring">def mk_symm (xs : List α) :=
</span><span class="boring"> xs ++ xs.reverse
</span>theorem reverse_mk_symm (xs : List α)
        : (mk_symm xs).reverse = mk_symm xs := by
  simp [mk_symm]

attribute [simp] reverse_mk_symm

example (xs ys : List Nat)
        : (xs ++ mk_symm ys).reverse = mk_symm ys ++ xs.reverse := by
  simp

example (xs ys : List Nat) (p : List Nat → Prop)
        (h : p (xs ++ mk_symm ys).reverse)
        : p (mk_symm ys ++ xs.reverse) := by
  simp at h; assumption
</code></pre>
<!--
The attribute can also be applied any time after the theorem is declared:
-->
<p>该属性也可以在定理声明后的任何时候应用：</p>
<pre><code class="language-lean"><span class="boring">def mk_symm (xs : List α) :=
</span><span class="boring"> xs ++ xs.reverse
</span>theorem reverse_mk_symm (xs : List α)
        : (mk_symm xs).reverse = mk_symm xs := by
  simp [mk_symm]

example (xs ys : List Nat)
        : (xs ++ mk_symm ys).reverse = mk_symm ys ++ xs.reverse := by
  simp [reverse_mk_symm]

attribute [simp] reverse_mk_symm

example (xs ys : List Nat) (p : List Nat → Prop)
        (h : p (xs ++ mk_symm ys).reverse)
        : p (mk_symm ys ++ xs.reverse) := by
  simp at h; assumption
</code></pre>
<!--
Once the attribute is applied, however, there is no way to permanently
remove it; it persists in any file that imports the one where the
attribute is assigned. As we will discuss further in
[Attributes](./interacting_with_lean.md#attributes), one can limit the scope of an attribute to the
current file or section using the ``local`` modifier:
-->
<p>然而，一旦属性被应用，就没有办法永久地删除它；它将在任何导入该属性的文件中持续存在。正如我们将在<a href="./interacting_with_lean.html#%E5%B1%9E%E6%80%A7">属性</a>一章中进一步讨论的那样，我们可以使用 <code>local</code> 修饰符将属性的范围限制在当前文件或章节中：</p>
<pre><code class="language-lean"><span class="boring">def mk_symm (xs : List α) :=
</span><span class="boring"> xs ++ xs.reverse
</span>theorem reverse_mk_symm (xs : List α)
        : (mk_symm xs).reverse = mk_symm xs := by
  simp [mk_symm]

section
attribute [local simp] reverse_mk_symm

example (xs ys : List Nat)
        : (xs ++ mk_symm ys).reverse = mk_symm ys ++ xs.reverse := by
  simp

example (xs ys : List Nat) (p : List Nat → Prop)
        (h : p (xs ++ mk_symm ys).reverse)
        : p (mk_symm ys ++ xs.reverse) := by
  simp at h; assumption
end
</code></pre>
<!--
Outside the section, the simplifier will no longer use
``reverse_mk_symm`` by default.

Note that the various ``simp`` options we have discussed --- giving an
explicit list of rules, and using ``at`` to specify the location --- can be combined,
but the order they are listed is rigid. You can see the correct order
in an editor by placing the cursor on the ``simp`` identifier to see
the documentation string that is associated with it.

There are two additional modifiers that are useful. By default,
``simp`` includes all theorems that have been marked with the
attribute ``[simp]``. Writing ``simp only`` excludes these defaults,
allowing you to use a more explicitly crafted list of
rules. In the examples below, the minus sign and
``only`` are used to block the application of ``reverse_mk_symm``.
-->
<p>在该部分之外，简化器将不再默认使用 <code>reverse_mk_symm</code>。</p>
<p>请注意，我们讨论过的各种 <code>simp</code> 选项----给出一个明确的规则列表，并使用 <code>at</code> 指定位置----可以合并，但它们的排列顺序是严格的。你可以在编辑器中看到正确的顺序，把光标放在 <code>simp</code> 标识符上，查看与之相关的文档。</p>
<p>有两个额外的修饰符是有用的。默认情况下，<code>simp</code> 包括所有被标记为 <code>[simp]</code> 属性的定理。写<code>simp only</code>排除了这些默认值，允许你使用一个更明确的规则列表。在下面的例子中，减号和 <code>only</code> 被用来阻止 <code>reverse_mk_symm</code> 的应用：</p>
<pre><code class="language-lean">def mk_symm (xs : List α) :=
  xs ++ xs.reverse
@[simp] theorem reverse_mk_symm (xs : List α)
        : (mk_symm xs).reverse = mk_symm xs := by
  simp [mk_symm]

example (xs ys : List Nat) (p : List Nat → Prop)
        (h : p (xs ++ mk_symm ys).reverse)
        : p (mk_symm ys ++ xs.reverse) := by
  simp at h; assumption

example (xs ys : List Nat) (p : List Nat → Prop)
        (h : p (xs ++ mk_symm ys).reverse)
        : p ((mk_symm ys).reverse ++ xs.reverse) := by
  simp [-reverse_mk_symm] at h; assumption

example (xs ys : List Nat) (p : List Nat → Prop)
        (h : p (xs ++ mk_symm ys).reverse)
        : p ((mk_symm ys).reverse ++ xs.reverse) := by
  simp only [List.reverse_append] at h; assumption
</code></pre>
<!--
The `simp` tactic has many configuration options. For example, we can enable contextual simplifications as follows.
-->
<p><code>simp</code> 策略有很多配置选项，例如，我们可以启用语境简化：</p>
<pre><code class="language-lean">example : if x = 0 then y + x = y else x ≠ 0 := by
  simp (config := { contextual := true })
</code></pre>
<!--
when `contextual := true`, `simp` uses the fact that `x = 0` when simplifying `y + x = y`, and
`x ≠ 0` when simplifying the other branch. Here is another example.
-->
<p>当<code>contextual := true</code>，<code>simp</code> 简化<code>y + x = y</code>时会使用<code>x = 0</code>，同时会用<code>x ≠ 0</code>来简化另一侧。另一个例子：</p>
<pre><code class="language-lean">example : ∀ (x : Nat) (h : x = 0), y + x = y := by
  simp (config := { contextual := true })
</code></pre>
<!--
Another useful configuration option is `arith := true` which enables arithmetical simplifications. It is so useful
that `simp_arith` is a shorthand for `simp (config := { arith := true })`.
-->
<p>另一个有用的配置是<code>arith := true</code>，它会简化算术表达式。因为这太常用了所以用 <code>simp_arith</code> 作为<code>simp (config := { arith := true })</code>的缩写。</p>
<pre><code class="language-lean">example : 0 &lt; 1 + x ∧ x + y + 2 ≥ y + 1 := by
  simp_arith
</code></pre>
<!--
Split Tactic
------------
-->
<h2 id="拆分"><a class="header" href="#拆分">拆分</a></h2>
<!--
The ``split`` tactic is useful for breaking nested `if-then-else` and `match` expressions in cases.
For a `match` expression with `n` cases, the `split` tactic generates at most `n` subgoals. Here is an example.
-->
<p><code>split</code> 策略对于在多情形分支结构中打破嵌套的<code>if-then-else</code>和 <code>match</code> 表达式很有用。
对于包含 <code>n</code> 种情形的 <code>match</code> 表达式，<code>split</code> 策略最多生成 <code>n</code> 个子目标。例子：</p>
<pre><code class="language-lean">def f (x y z : Nat) : Nat :=
  match x, y, z with
  | 5, _, _ =&gt; y
  | _, 5, _ =&gt; y
  | _, _, 5 =&gt; y
  | _, _, _ =&gt; 1

example (x y z : Nat) : x ≠ 5 → y ≠ 5 → z ≠ 5 → z = w → f x y w = 1 := by
  intros
  simp [f]
  split
  . contradiction
  . contradiction
  . contradiction
  . rfl
</code></pre>
<!--
We can compress the tactic proof above as follows.
-->
<p>可以压缩成一行：</p>
<pre><code class="language-lean"><span class="boring">def f (x y z : Nat) : Nat :=
</span><span class="boring"> match x, y, z with
</span><span class="boring"> | 5, _, _ =&gt; y
</span><span class="boring"> | _, 5, _ =&gt; y
</span><span class="boring"> | _, _, 5 =&gt; y
</span><span class="boring"> | _, _, _ =&gt; 1
</span>example (x y z : Nat) : x ≠ 5 → y ≠ 5 → z ≠ 5 → z = w → f x y w = 1 := by
  intros; simp [f]; split &lt;;&gt; first | contradiction | rfl
</code></pre>
<!--
The tactic `split <;> first | contradiction | rfl` first applies the `split` tactic,
and then for each generated goal it tries `contradiction`, and then `rfl` if `contradiction` fails.
Like `simp`, we can apply `split` to a particular hypothesis.
-->
<p>策略<code>split &lt;;&gt; first | contradiction | rfl</code>首先应用 <code>split</code> 策略，接着对每个生成出的目标尝试 <code>contradiction</code>，如果失败那么最后 <code>rfl</code>。</p>
<p>类似 <code>simp</code>，我们对一个特定的假设也可以使用 <code>split</code>。</p>
<pre><code class="language-lean">def g (xs ys : List Nat) : Nat :=
  match xs, ys with
  | [a, b], _ =&gt; a+b+1
  | _, [b, c] =&gt; b+1
  | _, _      =&gt; 1

example (xs ys : List Nat) (h : g xs ys = 0) : False := by
  simp [g] at h; split at h &lt;;&gt; simp_arith at h
</code></pre>
<!--
Extensible Tactics
-----------------
-->
<h2 id="扩展策略"><a class="header" href="#扩展策略">扩展策略</a></h2>
<!--
In the following example, we define the notation `triv` using the command `syntax`.
Then, we use the command `macro_rules` to specify what should
be done when `triv` is used. You can provide different expansions, and the tactic
interpreter will try all of them until one succeeds.
-->
<p>在下面的例子中，我们使用 <code>syntax</code> 命令定义符号 <code>triv</code>。然后，我们使用 <code>macro_rules</code> 命令来指定使用 <code>triv</code> 时应该做什么。你可以提供不同的扩展，策略解释器将尝试所有的扩展，直到有一个成功。</p>
<!--
```lean
-- Define a new tactic notation
syntax "triv" : tactic

macro_rules
  | `(tactic| triv) => `(tactic| assumption)

example (h : p) : p := by
  triv

-- You cannot prove the following theorem using `triv`
-- example (x : α) : x = x := by
--  triv

-- Let's extend `triv`. The tactic interpreter
-- tries all possible macro extensions for `triv` until one succeeds
macro_rules
  | `(tactic| triv) => `(tactic| rfl)

example (x : α) : x = x := by
  triv

example (x : α) (h : p) : x = x ∧ p := by
  apply And.intro <;> triv

-- We now add a (recursive) extension
macro_rules | `(tactic| triv) => `(tactic| apply And.intro <;> triv)

example (x : α) (h : p) : x = x ∧ p := by
  triv
```
-->
<pre><code class="language-lean">-- 定义一个新策略符号
syntax &quot;triv&quot; : tactic

macro_rules
  | `(tactic| triv) =&gt; `(tactic| assumption)

example (h : p) : p := by
  triv

-- 你不能用 `triv` 解决下面的定理：
-- example (x : α) : x = x := by
--  triv

-- 扩展 `triv`。策略解释器会尝试所有可能的扩展宏，直到有一个成功。
macro_rules
  | `(tactic| triv) =&gt; `(tactic| rfl)

example (x : α) : x = x := by
  triv

example (x : α) (h : p) : x = x ∧ p := by
  apply And.intro &lt;;&gt; triv

-- 加一个递归扩展
macro_rules | `(tactic| triv) =&gt; `(tactic| apply And.intro &lt;;&gt; triv)

example (x : α) (h : p) : x = x ∧ p := by
  triv
</code></pre>
<!--
Exercises
---------
-->
<h2 id="练习"><a class="header" href="#练习">练习</a></h2>
<!--
1. Go back to the exercises in [Chapter Propositions and
Proofs](./propositions_and_proofs.md) and
[Chapter Quantifiers and Equality](./quantifiers_and_equality.md) and
redo as many as you can now with tactic proofs, using also ``rw``
and ``simp`` as appropriate.

1. Use tactic combinators to obtain a one line proof of the following:
-->
<ol>
<li>
<p>用策略式证明重做<a href="./propositions_and_proofs.html">命题与证明</a>和<a href="./quantifiers_and_equality.html">量词与等价</a>两章的练习。适当使用 <code>rw</code> 和 <code>simp</code>。</p>
</li>
<li>
<p>用策略组合器给下面的例子用一行写一个证明：</p>
</li>
</ol>
<pre><code class="language-lean">example (p q r : Prop) (hp : p)
        : (p ∨ q ∨ r) ∧ (q ∨ p ∨ r) ∧ (q ∨ r ∨ p) := by
  admit
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="quantifiers_and_equality.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="interacting_with_lean.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="quantifiers_and_equality.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="interacting_with_lean.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="custom.js"></script>
    </body>
</html>

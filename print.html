<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Lean 4 定理证明</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme && theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar && sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title_page.html">Lean 4 定理证明</a></li><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> 简介</a></li><li class="chapter-item expanded "><a href="dependent_type_theory.html"><strong aria-hidden="true">2.</strong> 依值类型论</a></li><li class="chapter-item expanded "><a href="propositions_and_proofs.html"><strong aria-hidden="true">3.</strong> 命题与证明</a></li><li class="chapter-item expanded "><a href="quantifiers_and_equality.html"><strong aria-hidden="true">4.</strong> 量词与等价</a></li><li class="chapter-item expanded "><a href="tactics.html"><strong aria-hidden="true">5.</strong> 证明策略</a></li><li class="chapter-item expanded "><a href="interacting_with_lean.html"><strong aria-hidden="true">6.</strong> 与 Lean 交互</a></li><li class="chapter-item expanded "><a href="inductive_types.html"><strong aria-hidden="true">7.</strong> 归纳类型</a></li><li class="chapter-item expanded "><a href="induction_and_recursion.html"><strong aria-hidden="true">8.</strong> 归纳与递归</a></li><li class="chapter-item expanded "><a href="structures_and_records.html"><strong aria-hidden="true">9.</strong> 结构体与记录</a></li><li class="chapter-item expanded "><a href="type_classes.html"><strong aria-hidden="true">10.</strong> 类型类</a></li><li class="chapter-item expanded "><a href="conv.html"><strong aria-hidden="true">11.</strong> 转换策略模式</a></li><li class="chapter-item expanded "><a href="axioms_and_computation.html"><strong aria-hidden="true">12.</strong> 公理与计算</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Lean 4 定理证明</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Lean-zh/tp-lean-zh" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
# Theorem Proving in Lean 4
-->
<h1 id="lean-4-定理证明"><a class="header" href="#lean-4-定理证明">Lean 4 定理证明</a></h1>
<p>作者：<em>Jeremy Avigad, Leonardo de Moura, Soonho Kong and Sebastian Ullrich, 以及来自 Lean 社区的贡献者</em></p>
<p><strong><a href="https://github.com/Lean-zh">Lean-zh 项目组</a> 译</strong></p>
<!--
This version of the text assumes you’re using Lean 4. See the
[Quickstart section](https://lean-lang.org/lean4/doc/quickstart.html) of
the [Lean 4 Manual](https://lean-lang.org/lean4/doc/) to install Lean. The first version of this book was
written for Lean 2, and the Lean 3 version is available
[here](https://leanprover.github.io/theorem_proving_in_lean/).
-->
<p>本书假定你使用 Lean 4。安装方式参见 <a href="https://www.leanprover.cn/lean4/doc/">Lean 4 手册</a>
中的 <a href="https://www.leanprover.cn/lean4/doc/quickstart.html">快速开始</a> 一节。
本书的第一版为 Lean 2 编写，Lean 3 版请访问 <a href="https://leanprover.github.io/theorem_proving_in_lean/">此处</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
Introduction
-->
<h1 id="简介"><a class="header" href="#简介">简介</a></h1>
<!--
Computers and Theorem Proving
-->
<h2 id="计算机和定理证明"><a class="header" href="#计算机和定理证明">计算机和定理证明</a></h2>
<!--
*Formal verification* involves the use of logical and computational methods to establish claims that are expressed in
precise mathematical terms. These can include ordinary mathematical theorems, as well as claims that pieces of hardware
or software, network protocols, and mechanical and hybrid systems meet their specifications. In practice, there is not a
sharp distinction between verifying a piece of mathematics and verifying the correctness of a system: formal
verification requires describing hardware and software systems in mathematical terms, at which point establishing claims
as to their correctness becomes a form of theorem proving. Conversely, the proof of a mathematical theorem may require a
lengthy computation, in which case verifying the truth of the theorem requires verifying that the computation does what
it is supposed to do.
-->
<p><strong>形式验证（Formal Verification）</strong> 是指使用逻辑和计算方法来验证用精确的数学术语表达的命题。
这包括普通的数学定理，以及硬件或软件、网络协议、机械和混合系统中的形式命题。
在实践中，验证数学命题和验证系统的正确性之间很类似：形式验证用数学术语描述硬件和软件系统，
在此基础上验证其命题的正确性，这就像定理证明的过程。相反，一个数学定理的证明可能需要冗长的计算，
在这种情况下，验证定理的真实性需要验证计算过程是否出错。</p>
<!--
The gold standard for supporting a mathematical claim is to provide a proof, and twentieth-century developments in logic
show most if not all conventional proof methods can be reduced to a small set of axioms and rules in any of a number of
foundational systems. With this reduction, there are two ways that a computer can help establish a claim: it can help
find a proof in the first place, and it can help verify that a purported proof is correct.
-->
<p>二十世纪的逻辑学发展表明，绝大多数传统证明方法可以化为若干基础系统中的一小套公理和规则。
有了这种简化，计算机能以两种方式帮助建立命题：1）它可以帮助寻找一个证明，
2）可以帮助验证一个所谓的证明是正确的。</p>
<!--
*Automated theorem proving* focuses on the "finding" aspect. Resolution theorem provers, tableau theorem provers, fast
satisfiability solvers, and so on provide means of establishing the validity of formulas in propositional and
first-order logic. Other systems provide search procedures and decision procedures for specific languages and domains,
such as linear or nonlinear expressions over the integers or the real numbers. Architectures like SMT ("satisfiability
modulo theories") combine domain-general search methods with domain-specific procedures. Computer algebra systems and
specialized mathematical software packages provide means of carrying out mathematical computations, establishing
mathematical bounds, or finding mathematical objects. A calculation can be viewed as a proof as well, and these systems,
too, help establish mathematical claims.
-->
<p><strong>自动定理证明（Automated theorem proving）</strong> 着眼于「寻找」证明。
<strong>归结原理（Resolution）</strong> 定理证明器、<strong>表格法（tableau）</strong> 定理证明器、
<strong>快速可满足性求解器（Fast satisfiability solvers）</strong>
等提供了在命题逻辑和一阶逻辑中验证公式有效性的方法；
还有些系统为特定的语言和问题提供搜索和决策程序，
例如整数或实数上的线性或非线性表达式；
像 <strong>SMT（Satisfiability modulo theories，可满足性模理论）</strong>
这样的架构将通用的搜索方法与特定领域的程序相结合；
计算机代数系统和专门的数学软件包提供了进行数学计算或寻找数学对象的手段，
这些系统中的计算也可以被看作是一种证明，而这些系统也可以帮助建立数学命题。</p>
<!--
Automated reasoning systems strive for power and efficiency, often at the expense of guaranteed soundness. Such systems
can have bugs, and it can be difficult to ensure that the results they deliver are correct. In contrast, *interactive
theorem proving* focuses on the "verification" aspect of theorem proving, requiring that every claim is supported by a
proof in a suitable axiomatic foundation. This sets a very high standard: every rule of inference and every step of a
calculation has to be justified by appealing to prior definitions and theorems, all the way down to basic axioms and
rules. In fact, most such systems provide fully elaborated "proof objects" that can be communicated to other systems and
checked independently. Constructing such proofs typically requires much more input and interaction from users, but it
allows you to obtain deeper and more complex proofs.
-->
<p>自动推理系统努力追求能力和效率，但往往牺牲稳定性。这样的系统可能会有 bug，
而且很难保证它们所提供的结果是正确的。相比之下，<strong>交互式定理证明器（Interactive theorem proving）</strong>
侧重于「验证」证明，要求每个命题都有合适的公理基础的证明来支持。
这就设定了非常高的标准：每一条推理规则和每一步计算都必须通过求助于先前的定义和定理来证明，
一直到基本公理和规则。事实上，大多数这样的系统提供了精心设计的「证明对象」，
可以传给其他系统并独立检查。构建这样的证明通常需要用户更多的输入和交互，
但它可以让你获得更深入、更复杂的证明。</p>
<!--
The *Lean Theorem Prover* aims to bridge the gap between interactive and automated theorem proving, by situating
automated tools and methods in a framework that supports user interaction and the construction of fully specified
axiomatic proofs. The goal is to support both mathematical reasoning and reasoning about complex systems, and to verify
claims in both domains.
-->
<p><strong>Lean 定理证明器</strong> 旨在融合交互式和自动定理证明，
它将自动化工具和方法置于一个支持用户交互和构建完整公理化证明的框架中。
它的目标是支持数学推理和复杂系统的推理，并验证这两个领域的命题。</p>
<!--
Lean's underlying logic has a computational interpretation, and Lean can be viewed equally well as a programming
language. More to the point, it can be viewed as a system for writing programs with a precise semantics, as well as
reasoning about the functions that the programs compute. Lean also has mechanisms to serve as its own *metaprogramming
language*, which means that you can implement automation and extend the functionality of Lean using Lean itself. These
aspects of Lean are described in the free online book, [Functional Programming in Lean](https://lean-lang.org/functional_programming_in_lean/), though computational
aspects of the system will make an appearance here.
-->
<p>Lean 的底层逻辑有一个计算的解释，与此同时 Lean 可以被视为一种编程语言。
更重要的是，它可以被看作是一个编写具有精确语义的程序的系统，
以及对程序所表示的计算功能进行推理。Lean 中也有机制使它能够作为它自己的 <strong>元编程语言</strong>，
这意味着你可以使用 Lean 本身实现自动化和扩展 Lean 的功能。
Lean 的这些方面将在本教程的配套教程
<a href="https://www.leanprover.cn/fp-lean-zh/">Lean 4函数式编程</a>中进行探讨，本书只介绍计算方面。</p>
<!--
About Lean
-->
<h2 id="关于-lean"><a class="header" href="#关于-lean">关于 Lean</a></h2>
<!--
The *Lean* project was launched by Leonardo de Moura at Microsoft Research Redmond in 2013. It is an ongoing, long-term
effort, and much of the potential for automation will be realized only gradually over time. Lean is released under the
[Apache 2.0 license](LICENSE), a permissive open source license that permits others to use and extend the code and
mathematical libraries freely.
-->
<p><em>Lean</em> 项目由微软 Redmond 研究院的 Leonardo de Moura 在 2013 年发起，这是个长期项目，
自动化方法的潜力会在未来逐步被挖掘。Lean 是在 <a href="LICENSE">Apache 2.0 许可协议</a> 下发布的，
这是一个允许他人自由使用和扩展代码和数学库的许可性开源许可证。</p>
<!--
To install Lean in your computer consider using the [Quickstart](https://github.com/leanprover/lean4/blob/master/doc/quickstart.md) instructions. The Lean source code, and instructions for building Lean, are available at
[https://github.com/leanprover/lean4/](https://github.com/leanprover/lean4/).


This tutorial describes the current version of Lean, known as Lean 4.
-->
<p>通常有两种办法来运行Lean。第一个是<a href="https://live.lean-lang.org/">网页版本</a>：
由 JavaScript 编写，包含标准定义和定理库，编辑器会下载到你的浏览器上运行。
这是个方便快捷的办法。</p>
<p>第二种是本地版本：本地版本远快于网页版本，并且非常灵活。Visual Studio Code
和 Emacs 扩展模块给编写和调试证明提供了有力支撑，因此更适合正式使用。
源代码和安装方法见<a href="https://github.com/leanprover/lean4/">https://github.com/leanprover/lean4/</a>.</p>
<p>本教程介绍的是 Lean 的当前版本：Lean 4。</p>
<!--
About this Book
-->
<h2 id="关于本书"><a class="header" href="#关于本书">关于本书</a></h2>
<!--
This book is designed to teach you to develop and verify proofs in Lean. Much of the background information you will
need in order to do this is not specific to Lean at all. To start with, you will learn the logical system that Lean is
based on, a version of *dependent type theory* that is powerful enough to prove almost any conventional mathematical
theorem, and expressive enough to do it in a natural way. More specifically, Lean is based on a version of a system
known as the Calculus of Constructions with inductive types. Lean can not only define mathematical objects and express
mathematical assertions in dependent type theory, but it also can be used as a language for writing proofs.
-->
<p>本书的目的是教你在 Lean 中编写和验证证明，并且不太需要针对 Lean 的基础知识。首先，你将学习 Lean 所基于的逻辑系统，它是 <strong>依值类型论（Dependent type theory）</strong> 的一个版本，足以证明几乎所有传统的数学定理，并且有足够的表达能力自然地表示数学定理。更具体地说，Lean 是基于具有归纳类型（Inductive type）的构造演算（Calculus of Construction）系统的类型论版本。Lean 不仅可以定义数学对象和表达依值类型论的数学断言，而且还可以作为一种语言来编写证明。</p>
<!--
Because fully detailed axiomatic proofs are so complicated, the challenge of theorem proving is to have the computer
fill in as many of the details as possible. You will learn various methods to support this in [dependent type
theory](dependent_type_theory.md). For example, term rewriting, and Lean's automated methods for simplifying terms and
expressions automatically. Similarly, methods of *elaboration* and *type inference*, which can be used to support
flexible forms of algebraic reasoning.
-->
<p>由于完全深入细节的公理证明十分复杂，定理证明的难点在于让计算机尽可能多地填补证明细节。
你将通过<a href="dependent_type_theory.html">依值类型论</a>语言来学习各种方法实现自动证明，例如项重写，
以及 Lean 中的项和表达式的自动简化方法。同样，<strong>繁饰（Elaboration）</strong>
和 <strong>类型推断（Type inference）</strong> 的方法，可以用来支持灵活的代数推理。</p>
<!--
Finally, you will learn about features that are specific to Lean, including the language you use to communicate
with the system, and the mechanisms Lean offers for managing complex theories and data.

Throughout the text you will find examples of Lean code like the one below:
-->
<p>最后，你会学到 Lean 的一些特性，包括与系统交流的语言，和 Lean 提供的对复杂理论和数据的管理机制。</p>
<p>在本书中你会见到类似下面这样的代码：</p>
<pre><code class="language-lean">theorem and_commutative (p q : Prop) : p ∧ q → q ∧ p :=
  fun hpq : p ∧ q =&gt;
  have hp : p := And.left hpq
  have hq : q := And.right hpq
  show q ∧ p from And.intro hq hp
</code></pre>
<!--
If you are reading the book inside of [VS Code](https://code.visualstudio.com/), you will see a button that reads "try it!" Pressing the button copies the example to your editor with enough surrounding context to make the code compile correctly. You can type
things into the editor and modify the examples, and Lean will check the results and provide feedback continuously as you
type. We recommend running the examples and experimenting with the code on your own as you work through the chapters
that follow. You can open this book on VS Code by using the command "Lean 4: Open Documentation View".
-->
<p>如果你在 <a href="https://code.visualstudio.com/">VS Code</a> 中阅读本书，你会看到一个按钮，
上面写着「try it!」按下按钮将示例复制到编辑器中，并带有足够的周围上下文，以使代码正确编译。
您可以在编辑器中输入内容并修改示例，Lean 将在您输入时检查结果并不断提供反馈。
我们建议您在阅读后面的章节时，自己运行示例并试验代码。你可以通过使用
「Lean 4: Open Documentation View」命令在 VS Code 中打开本书。</p>
<h2 id="致谢"><a class="header" href="#致谢">致谢</a></h2>
<!--
This tutorial is an open access project maintained on Github. Many people have contributed to the effort, providing
corrections, suggestions, examples, and text. We are grateful to Ulrik Buchholz, Kevin Buzzard, Mario Carneiro, Nathan
Carter, Eduardo Cavazos, Amine Chaieb, Joe Corneli, William DeMeo, Marcus Klaas de Vries, Ben Dyer, Gabriel Ebner,
Anthony Hart, Simon Hudon, Sean Leather, Assia Mahboubi, Gihan Marasingha, Patrick Massot, Christopher John Mazey,
Sebastian Ullrich, Floris van Doorn, Daniel Velleman, Théo Zimmerman, Paul Chisholm, Chris Lovett, and Siddhartha Gadgil for their contributions.  Please see [lean prover](https://github.com/leanprover/) and [lean community](https://github.com/leanprover-community/) for an up to date list
of our amazing contributors.
-->
<p>本教程是一项开放源代码项目，在 Github 上维护。许多人为此做出了贡献，提供了
更正、建议、示例和文本。我们要感谢 Ulrik Buchholz、Kevin Buzzard、Mario Carneiro、
Nathan Carter、Eduardo Cavazos、Amine Chaieb、Joe Corneli、William DeMeo、
Marcus Klaas de Vries、Ben Dyer、Gabriel Ebner、Anthony Hart、Simon Hudon、Sean Leather、
Assia Mahboubi、Gihan Marasingha、Patrick Massot、Christopher John Mazey、
Sebastian Ullrich、Floris van Doorn、Daniel Velleman、Théo Zimmerman、Paul Chisholm、Chris Lovett
以及 Siddhartha Gadgil 对本文做出的贡献。有关我们杰出的贡献者的最新名单，
请参见 <a href="https://github.com/leanprover/">Lean 证明器</a>和 <a href="https://github.com/leanprover-community/">Lean 社区</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
Dependent Type Theory
-->
<h1 id="依值类型论"><a class="header" href="#依值类型论">依值类型论</a></h1>
<!--
Dependent type theory is a powerful and expressive language, allowing
you to express complex mathematical assertions, write complex hardware
and software specifications, and reason about both of these in a
natural and uniform way. Lean is based on a version of dependent type
theory known as the *Calculus of Constructions*, with a countable
hierarchy of non-cumulative universes and inductive types. By the end
of this chapter, you will understand much of what this means.
-->
<p>依值类型论（Dependent type theory）是一种强大而富有表达力的语言，允许你表达复杂的数学断言，编写复杂的硬件和软件规范，并以自然和统一的方式对这两者进行推理。Lean 是基于一个被称为构造演算（Calculus of Constructions）的依值类型论的版本，它拥有一个可数的非累积性宇宙（non-cumulative universe）的层次结构以及归纳类型（Inductive type）。在本章结束时，你将学会一大部分。</p>
<!--
## Simple Type Theory
-->
<h2 id="简单类型论"><a class="header" href="#简单类型论">简单类型论</a></h2>
<!--
"Type theory" gets its name from the fact that every expression has an
associated *type*. For example, in a given context, ``x + 0`` may
denote a natural number and ``f`` may denote a function on the natural
numbers. For those who like precise definitions, a Lean natural number
is an arbitrary-precision unsigned integer.
-->
<p>「类型论」得名于其中每个表达式都有一个<em>类型</em>。举例：在一个给定的语境中，<code>x + 0</code> 可能表示一个自然数，<code>f</code> 可能表示一个定义在自然数上的函数。Lean 中的自然数是任意精度的无符号整数。</p>
<!--
Here are some examples of how you can declare objects in Lean and
check their types.
-->
<p>这里的一些例子展示了如何声明对象以及检查其类型。</p>
<!--
```lean
/- Define some constants. -/

def m : Nat := 1       -- m is a natural number
def n : Nat := 0
def b1 : Bool := true  -- b1 is a Boolean
def b2 : Bool := false

/- Check their types. -/

#check m            -- output: Nat
#check n
#check n + 0        -- Nat
#check m * (n + 0)  -- Nat
#check b1           -- Bool
#check b1 && b2     -- "&&" is the Boolean and
#check b1 || b2     -- Boolean or
#check true         -- Boolean "true"

/- Evaluate -/

#eval 5 * 4         -- 20
#eval m + 2         -- 3
#eval b1 && b2      -- false
```
-->
<pre><code class="language-lean">/- 定义一些常数 -/

def m : Nat := 1       -- m 是自然数
def n : Nat := 0
def b1 : Bool := true  -- b1 是布尔型
def b2 : Bool := false

/- 检查类型 -/

#check m            -- 输出: Nat
#check n
#check n + 0        -- Nat
#check m * (n + 0)  -- Nat
#check b1           -- Bool
#check b1 &amp;&amp; b2     -- &quot;&amp;&amp;&quot; is the Boolean and
#check b1 || b2     -- Boolean or
#check true         -- Boolean &quot;true&quot;

/- 求值（Evaluate） -/

#eval 5 * 4         -- 20
#eval m + 2         -- 3
#eval b1 &amp;&amp; b2      -- false
</code></pre>
<!--
Any text between ``/-`` and ``-/`` constitutes a comment block that is
ignored by Lean. Similarly, two dashes `--` indicate that the rest of
the line contains a comment that is also ignored. Comment blocks can
be nested, making it possible to "comment out" chunks of code, just as
in many programming languages.
-->
<p>位于 <code>/-</code> 和 <code>-/</code> 之间的文本组成了一个注释块，会被 Lean 的编译器忽略。类似地，两条横线<code>--</code>后面也是注释。注释块可以嵌套，这样就可以「注释掉」一整块代码，这和任何程序语言都是一样的。</p>
<!--
The ``def`` keyword declares new constant symbols into the
working environment. In the example above, `def m : Nat := 1`
defines a new constant `m` of type `Nat` whose value is `1`.
The ``#check`` command asks Lean to report their
types; in Lean, auxiliary commands that query the system for
information typically begin with the hash (#) symbol.
The `#eval` command asks Lean to evaluate the given expression.
You should try
declaring some constants and type checking some expressions on your
own. Declaring new objects in this manner is a good way to experiment
with the system.
-->
<p><code>def</code> 关键字声明工作环境中的新常量符号。在上面的例子中，<code>def m : Nat := 1</code>定义了一个 <code>Nat</code> 类型的新常量 <code>m</code>，其值为 <code>1</code>。<code>#check</code> 命令要求 Lean 给出它的类型，用于向系统询问信息的辅助命令都以井号(#)开头。<code>#eval</code>命令让 Lean 计算给出的表达式。你应该试试自己声明一些常量和检查一些表达式的类型。</p>
<!--
What makes simple type theory powerful is that you can build new types
out of others. For example, if ``a`` and ``b`` are types, ``a -> b``
denotes the type of functions from ``a`` to ``b``, and ``a × b``
denotes the type of pairs consisting of an element of ``a`` paired
with an element of ``b``, also known as the *Cartesian product*. Note
that `×` is a Unicode symbol. The judicious use of Unicode improves
legibility, and all modern editors have great support for it. In the
Lean standard library, you often see Greek letters to denote types,
and the Unicode symbol `→` as a more compact version of `->`.
-->
<p>简单类型论的强大之处在于，你可以从其他类型中构建新的类型。例如，如果 <code>a</code> 和 <code>b</code> 是类型，<code>a -&gt; b</code> 表示从 <code>a</code> 到 <code>b</code> 的函数类型，<code>a × b</code> 表示由 <code>a</code> 元素与 <code>b</code> 元素配对构成的类型，也称为<em>笛卡尔积</em>。注意<code>×</code>是一个 Unicode 符号，可以使用 <code>\times</code> 或简写 <code>\tim</code> 来输入。合理使用 Unicode 提高了易读性，所有现代编辑器都支持它。在 Lean 标准库中，你经常看到希腊字母表示类型，Unicode符号<code>→</code>是<code>-&gt;</code>的更紧凑版本。</p>
<!--
```lean
#check Nat → Nat      -- type the arrow as "\to" or "\r"
#check Nat -> Nat     -- alternative ASCII notation

#check Nat × Nat      -- type the product as "\times"
#check Prod Nat Nat   -- alternative notation

#check Nat → Nat → Nat
#check Nat → (Nat → Nat)  --  same type as above

#check Nat × Nat → Nat
#check (Nat → Nat) → Nat -- a "functional"

#check Nat.succ     -- Nat → Nat
#check (0, 1)       -- Nat × Nat
#check Nat.add      -- Nat → Nat → Nat

#check Nat.succ 2   -- Nat
#check Nat.add 3    -- Nat → Nat
#check Nat.add 5 2  -- Nat
#check (5, 9).1     -- Nat
#check (5, 9).2     -- Nat

#eval Nat.succ 2   -- 3
#eval Nat.add 5 2  -- 7
#eval (5, 9).1     -- 5
#eval (5, 9).2     -- 9
```
-->
<pre><code class="language-lean">#check Nat → Nat      -- 用&quot;\to&quot; or &quot;\r&quot;来打出这个箭头
#check Nat -&gt; Nat     -- 也可以用 ASCII 符号

#check Nat × Nat      -- 用&quot;\times&quot;打出乘号
#check Prod Nat Nat   -- 换成ASCII 符号

#check Nat → Nat → Nat
#check Nat → (Nat → Nat)  --  结果和上一个一样

#check Nat × Nat → Nat
#check (Nat → Nat) → Nat -- 一个「泛函」

#check Nat.succ     -- Nat → Nat
#check (0, 1)       -- Nat × Nat
#check Nat.add      -- Nat → Nat → Nat

#check Nat.succ 2   -- Nat
#check Nat.add 3    -- Nat → Nat
#check Nat.add 5 2  -- Nat
#check (5, 9).1     -- Nat
#check (5, 9).2     -- Nat

#eval Nat.succ 2   -- 3
#eval Nat.add 5 2  -- 7
#eval (5, 9).1     -- 5
#eval (5, 9).2     -- 9
</code></pre>
<!--
Once again, you should try some examples on your own.

Let's take a look at some basic syntax. You can enter the unicode
arrow ``→`` by typing ``\to`` or ``\r`` or ``\->``. You can also use the
ASCII alternative ``->``, so the expressions ``Nat -> Nat`` and ``Nat →
Nat`` mean the same thing. Both expressions denote the type of
functions that take a natural number as input and return a natural
number as output. The unicode symbol ``×`` for the Cartesian product
is entered as ``\times``. You will generally use lower-case Greek
letters like ``α``, ``β``, and ``γ`` to range over types. You can
enter these particular ones with ``\a``, ``\b``, and ``\g``.

There are a few more things to notice here. First, the application of
a function ``f`` to a value ``x`` is denoted ``f x`` (e.g., `Nat.succ 2`).
Second, when writing type expressions, arrows associate to the *right*; for
example, the type of ``Nat.add`` is ``Nat → Nat → Nat`` which is equivalent
to `Nat → (Nat → Nat)`. Thus you can
view ``Nat.add`` as a function that takes a natural number and returns
another function that takes a natural number and returns a natural
number. In type theory, this is generally more convenient than
writing ``Nat.add`` as a function that takes a pair of natural numbers as
input and returns a natural number as output. For example, it allows
you to "partially apply" the function ``Nat.add``.  The example above shows
that ``Nat.add 3`` has type ``Nat → Nat``, that is, ``Nat.add 3`` returns a
function that "waits" for a second argument, ``n``, which is then
equivalent to writing ``Nat.add 3 n``.
-->
<p>同样，你应该自己尝试一些例子。</p>
<p>让我们看一些基本语法。你可以通过输入 <code>\to</code> 或者 <code>\r</code> 或者 <code>\-&gt;</code> 来输入 <code>→</code>。你也可以就用 ASCII 码 <code>-&gt;</code>，所以表达式 <code>Nat -&gt; Nat</code> 和 <code>Nat → Nat</code> 意思是一样的，都表示以一个自然数作为输入并返回一个自然数作为输出的函数类型。Unicode符号 <code>×</code> 是笛卡尔积，用 <code>\times</code> 输入。小写的希腊字母 <code>α</code>，<code>β</code>，和 <code>γ</code> 等等常用来表示类型变量，可以用 <code>\a</code>，<code>\b</code>，和 <code>\g</code> 来输入。</p>
<p>这里还有一些需要注意的事情。第一，函数 <code>f</code> 应用到值 <code>x</code> 上写为 <code>f x</code>(例：<code>Nat.succ 2</code>)。第二，当写类型表达式时，箭头是<em>右结合</em>的；例如，<code>Nat.add</code> 的类型是 <code>Nat → Nat → Nat</code>，等价于 <code>Nat → (Nat → Nat)</code>。</p>
<p>因此你可以把 <code>Nat.add</code> 看作一个函数，它接受一个自然数并返回另一个函数，该函数接受一个自然数并返回一个自然数。在类型论中，把 <code>Nat.add</code> 函数看作接受一对自然数作为输入并返回一个自然数作为输出的函数通常会更方便。系统允许你「部分应用」函数 <code>Nat.add</code>，比如 <code>Nat.add 3</code> 具有类型 <code>Nat → Nat</code>，即 <code>Nat.add 3</code> 返回一个「等待」第二个参数 <code>n</code> 的函数，然后可以继续写 <code>Nat.add 3 n</code>。</p>
<!-- Taking a function ``h`` of type ``Nat
× Nat → Nat`` and "redefining" it to look like ``g`` is a process
known as *currying*. -->
<blockquote>
<p>注：取一个类型为 <code>Nat × Nat → Nat</code> 的函数，然后「重定义」它，让它变成 <code>Nat → Nat → Nat</code> 类型，这个过程被称作<em>柯里化</em>（currying）。</p>
</blockquote>
<!--
You have seen that if you have ``m : Nat`` and ``n : Nat``, then
``(m, n)`` denotes the ordered pair of ``m`` and ``n`` which is of
type ``Nat × Nat``. This gives you a way of creating pairs of natural
numbers. Conversely, if you have ``p : Nat × Nat``, then you can write
``p.1 : Nat`` and ``p.2 : Nat``. This gives you a way of extracting
its two components.
-->
<p>如果你有 <code>m : Nat</code> 和 <code>n : Nat</code>，那么 <code>(m, n)</code> 表示 <code>m</code> 和 <code>n</code> 组成的有序对，其类型为 <code>Nat × Nat</code>。这个方法可以制造自然数对。反过来，如果你有 <code>p : Nat × Nat</code>，之后你可以写 <code>p.1 : Nat</code> 和 <code>p.2 : Nat</code>。这个方法用于提取它的两个组件。</p>
<!--
## Types as objects
-->
<h2 id="类型作为对象"><a class="header" href="#类型作为对象">类型作为对象</a></h2>
<!--
One way in which Lean's dependent type theory extends simple type
theory is that types themselves --- entities like ``Nat`` and ``Bool``
--- are first-class citizens, which is to say that they themselves are
objects. For that to be the case, each of them also has to have a
type.
-->
<p>Lean 所依据的依值类型论对简单类型论的其中一项升级是，类型本身（如 <code>Nat</code> 和 <code>Bool</code> 这些东西）也是对象，因此也具有类型。</p>
<pre><code class="language-lean">#check Nat               -- Type
#check Bool              -- Type
#check Nat → Bool        -- Type
#check Nat × Bool        -- Type
#check Nat → Nat         -- ...
#check Nat × Nat → Nat
#check Nat → Nat → Nat
#check Nat → (Nat → Nat)
#check Nat → Nat → Bool
#check (Nat → Nat) → Nat
</code></pre>
<!--
You can see that each one of the expressions above is an object of
type ``Type``. You can also declare new constants for types:
-->
<p>上面的每个表达式都是类型为 <code>Type</code> 的对象。你也可以为类型声明新的常量:</p>
<pre><code class="language-lean">def α : Type := Nat
def β : Type := Bool
def F : Type → Type := List
def G : Type → Type → Type := Prod

#check α        -- Type
#check F α      -- Type
#check F Nat    -- Type
#check G α      -- Type → Type
#check G α β    -- Type
#check G α Nat  -- Type
</code></pre>
<!--
As the example above suggests, you have already seen an example of a function of type
``Type → Type → Type``, namely, the Cartesian product `Prod`:
-->
<p>正如上面所示，你已经看到了一个类型为 <code>Type → Type → Type</code> 的函数例子，即笛卡尔积 <code>Prod</code>：</p>
<pre><code class="language-lean">def α : Type := Nat
def β : Type := Bool

#check Prod α β       -- Type
#check α × β          -- Type

#check Prod Nat Nat   -- Type
#check Nat × Nat      -- Type
</code></pre>
<!--
Here is another example: given any type ``α``, the type ``List α``
denotes the type of lists of elements of type ``α``.
-->
<p>这里有另一个例子：给出任意类型 <code>α</code>，那么类型 <code>List α</code> 是类型为 <code>α</code> 的元素的列表的类型。</p>
<pre><code class="language-lean">def α : Type := Nat

#check List α    -- Type
#check List Nat  -- Type
</code></pre>
<!--
Given that every expression in Lean has a type, it is natural to ask:
what type does ``Type`` itself have?
-->
<p>看起来 Lean 中任何表达式都有一个类型，因此你可能会想到：<code>Type</code> 自己的类型是什么？</p>
<pre><code class="language-lean">#check Type      -- Type 1
</code></pre>
<!--
You have actually come up against one of the most subtle aspects of
Lean's typing system. Lean's underlying foundation has an infinite
hierarchy of types:
-->
<p>实际上，这是 Lean 系统的一个最微妙的方面：Lean 的底层基础有无限的类型层次：</p>
<pre><code class="language-lean">#check Type     -- Type 1
#check Type 1   -- Type 2
#check Type 2   -- Type 3
#check Type 3   -- Type 4
#check Type 4   -- Type 5
</code></pre>
<!--
Think of ``Type 0`` as a universe of "small" or "ordinary" types.
``Type 1`` is then a larger universe of types, which contains ``Type
0`` as an element, and ``Type 2`` is an even larger universe of types,
which contains ``Type 1`` as an element. The list is indefinite, so
that there is a ``Type n`` for every natural number ``n``. ``Type`` is
an abbreviation for ``Type 0``:
-->
<p>可以将 <code>Type 0</code> 看作是一个由「小」或「普通」类型组成的宇宙。然后，<code>Type 1</code> 是一个更大的类型范围，其中包含 <code>Type 0</code> 作为一个元素，而 <code>Type 2</code> 是一个更大的类型范围，其中包含 <code>Type 1</code> 作为一个元素。这个列表是无限的，所以对于每个自然数 <code>n</code> 都有一个 <code>Type n</code>。<code>Type</code> 是 <code>Type 0</code> 的缩写：</p>
<pre><code class="language-lean">#check Type
#check Type 0
</code></pre>
<!--
The following table may help concretize the relationships being discussed.
Movement along the x-axis represents a change in the universe, while movement
along the y-axis represents a change in what is sometimes referred to as
"degree".
-->
<p>下表可能有助于具体说明所讨论的关系。行方向代表宇宙的变化，列方向代表有时被称为「度」的变化。</p>
<table><thead><tr><th style="text-align: center"></th><th style="text-align: center"></th><th style="text-align: center"></th><th style="text-align: center"></th><th style="text-align: center"></th><th style="text-align: center"></th></tr></thead><tbody>
<tr><td style="text-align: center">sort</td><td style="text-align: center">Prop (Sort 0)</td><td style="text-align: center">Type (Sort 1)</td><td style="text-align: center">Type 1 (Sort 2)</td><td style="text-align: center">Type 2 (Sort 3)</td><td style="text-align: center">...</td></tr>
<tr><td style="text-align: center">type</td><td style="text-align: center">True</td><td style="text-align: center">Bool</td><td style="text-align: center">Nat -&gt; Type</td><td style="text-align: center">Type -&gt; Type 1</td><td style="text-align: center">...</td></tr>
<tr><td style="text-align: center">term</td><td style="text-align: center">trivial</td><td style="text-align: center">true</td><td style="text-align: center">fun n =&gt; Fin n</td><td style="text-align: center">fun (_ : Type) =&gt; Type</td><td style="text-align: center">...</td></tr>
</tbody></table>
<!--
Some operations, however, need to be *polymorphic* over type
universes. For example, ``List α`` should make sense for any type
``α``, no matter which type universe ``α`` lives in. This explains the
type signature of the function ``List``:
-->
<p>然而，有些操作需要在类型宇宙上具有 <strong>多态（Polymorphic）</strong> 。例如，<code>List α</code> 应该对任何类型的 <code>α</code> 都有意义，无论 <code>α</code> 存在于哪种类型的宇宙中。所以函数 <code>List</code> 有如下的类型：</p>
<pre><code class="language-lean">#check List    -- List.{u} (α : Type u) : Type u
</code></pre>
<!--
Here ``u`` is a variable ranging over type levels. The output of the
``#check`` command means that whenever ``α`` has type ``Type n``,
``List α`` also has type ``Type n``. The function ``Prod`` is
similarly polymorphic:
-->
<p>这里 <code>u</code> 是一个遍取类型级别的变量。<code>#check</code> 命令的输出意味着当 <code>α</code> 有类型 <code>Type n</code> 时，<code>List α</code> 也有类型 <code>Type n</code>。函数 <code>Prod</code> 具有类似的多态性：</p>
<pre><code class="language-lean">#check Prod    -- Prod.{u, v} (α : Type u) (β : Type v) : Type (max u v)
</code></pre>
<!--
To define polymorphic constants, Lean allows you to
declare universe variables explicitly using the `universe` command:
-->
<p>你可以使用 <code>universe</code> 命令来声明宇宙变量，这样就可以定义多态常量：</p>
<pre><code class="language-lean">universe u

def F (α : Type u) : Type u := Prod α α

#check F    -- Type u → Type u
</code></pre>
<!--
You can avoid the universe command by providing the universe parameters when defining F.
-->
<p>可以通过在定义 F 时提供 universe 参数来避免使用 <code>universe</code> 命令：</p>
<pre><code class="language-lean">def F.{u} (α : Type u) : Type u := Prod α α

#check F    -- Type u → Type u
</code></pre>
<!--
## Function Abstraction and Evaluation
-->
<h2 id="函数抽象和求值"><a class="header" href="#函数抽象和求值">函数抽象和求值</a></h2>
<p>Lean 提供 <code>fun</code> (或 <code>λ</code>)关键字用于从给定表达式创建函数，如下所示：</p>
<!--
```lean
#check fun (x : Nat) => x + 5   -- Nat → Nat
#check λ (x : Nat) => x + 5     -- λ and fun mean the same thing
#check fun x => x + 5     -- Nat inferred
#check λ x => x + 5       -- Nat inferred
```
-->
<pre><code class="language-lean">#check fun (x : Nat) =&gt; x + 5   -- Nat → Nat
#check λ (x : Nat) =&gt; x + 5     -- λ 和 fun 是同义词
#check fun x : Nat =&gt; x + 5     -- 同上
#check λ x : Nat =&gt; x + 5       -- 同上
</code></pre>
<!--
You can evaluate a lambda function by passing the required parameters:
-->
<p>你可以通过传递所需的参数来计算 lambda 函数：</p>
<pre><code class="language-lean">#eval (λ x : Nat =&gt; x + 5) 10    -- 15
</code></pre>
<!--
Creating a function from another expression is a process known as
*lambda abstraction*. Suppose you have the variable ``x : α`` and you can
construct an expression ``t : β``, then the expression ``fun (x : α)
=> t``, or, equivalently, ``λ (x : α) => t``, is an object of type ``α
→ β``. Think of this as the function from ``α`` to ``β`` which maps
any value ``x`` to the value ``t``.

Here are some more examples
-->
<p>从另一个表达式创建函数的过程称为 <strong>lambda 抽象</strong> 。假设你有一个变量 <code>x : α</code> 和一个表达式 <code>t : β</code>，那么表达式 <code>fun (x : α) =&gt; t</code> 或者 <code>λ (x : α) =&gt; t</code> 是一个类型为 <code>α → β</code> 的对象。这个从 <code>α</code> 到 <code>β</code> 的函数把任意 <code>x</code> 映射到 <code>t</code>。</p>
<p>这有些例子：</p>
<pre><code class="language-lean">#check fun x : Nat =&gt; fun y : Bool =&gt; if not y then x + 1 else x + 2
#check fun (x : Nat) (y : Bool) =&gt; if not y then x + 1 else x + 2
#check fun x y =&gt; if not y then x + 1 else x + 2   -- Nat → Bool → Nat
</code></pre>
<!--
Lean interprets the final three examples as the same expression; in
the last expression, Lean infers the type of ``x`` and ``y`` from the
expression `if not y then x + 1 else x + 2`.

Some mathematically common examples of operations of functions can be
described in terms of lambda abstraction:
-->
<p>Lean 将这三个例子解释为相同的表达式；在最后一个表达式中，Lean 可以从表达式<code>if not y then x + 1 else x + 2</code>推断 <code>x</code> 和 <code>y</code> 的类型。</p>
<p>一些数学上常见的函数运算的例子可以用 lambda 抽象的项来描述:</p>
<pre><code class="language-lean">def f (n : Nat) : String := toString n
def g (s : String) : Bool := s.length &gt; 0

#check fun x : Nat =&gt; x        -- Nat → Nat
#check fun x : Nat =&gt; true     -- Nat → Bool
#check fun x : Nat =&gt; g (f x)  -- Nat → Bool
#check fun x =&gt; g (f x)        -- Nat → Bool
</code></pre>
<!--
Think about what these expressions mean. The expression
``fun x : Nat => x`` denotes the identity function on ``Nat``, the
expression ``fun x : Nat => true`` denotes the constant function that
always returns ``true``, and ``fun x : Nat => g (f x)`` denotes the
composition of ``f`` and ``g``.  You can, in general, leave off the
type annotation and let Lean infer it for you.  So, for example, you
can write ``fun x => g (f x)`` instead of ``fun x : Nat => g (f x)``.

You can pass functions as parameters and by giving them names `f`
and `g` you can then use those functions in the implementation:
-->
<p>看看这些表达式的意思。表达式 <code>fun x : Nat =&gt; x</code> 代表 <code>Nat</code> 上的恒等函数，表达式 <code>fun x : Nat =&gt; true</code> 表示一个永远输出 <code>true</code> 的常值函数，表达式 <code>fun x : Nat =&gt; g (f x)</code> 表示 <code>f</code> 和 <code>g</code> 的复合。一般来说，你可以省略类型注释，让 Lean 自己推断它。因此你可以写 <code>fun x =&gt; g (f x)</code> 来代替 <code>fun x : Nat =&gt; g (f x)</code>。</p>
<p>你可以以函数作为参数，通过给它们命名 <code>f</code> 和 <code>g</code>，你可以在实现中使用这些函数：</p>
<pre><code class="language-lean">#check fun (g : String → Bool) (f : Nat → String) (x : Nat) =&gt; g (f x)
-- (String → Bool) → (Nat → String) → Nat → Bool
</code></pre>
<!--
You can also pass types as parameters:
-->
<p>你还可以以类型作为参数：</p>
<pre><code class="language-lean">#check fun (α β γ : Type) (g : β → γ) (f : α → β) (x : α) =&gt; g (f x)
</code></pre>
<!--
The last expression, for example, denotes the function that takes
three types, ``α``, ``β``, and ``γ``, and two functions, ``g : β → γ``
and ``f : α → β``, and returns the composition of ``g`` and ``f``.
(Making sense of the type of this function requires an understanding
of dependent products, which will be explained below.)

The general form of a lambda expression is ``fun x : α => t``, where
the variable ``x`` is a "bound variable": it is really a placeholder,
whose "scope" does not extend beyond the expression ``t``.  For
example, the variable ``b`` in the expression ``fun (b : β) (x : α) => b``
has nothing to do with the constant ``b`` declared earlier.  In fact,
the expression denotes the same function as ``fun (u : β) (z : α) => u``.

Formally, expressions that are the same up to a renaming of bound
variables are called *alpha equivalent*, and are considered "the
same." Lean recognizes this equivalence.

Notice that applying a term ``t : α → β`` to a term ``s : α`` yields
an expression ``t s : β``. Returning to the previous example and
renaming bound variables for clarity, notice the types of the
following expressions:
-->
<p>这个表达式表示一个接受三个类型 <code>α</code>，<code>β</code> 和 <code>γ</code> 和两个函数 <code>g : β → γ</code> 和 <code>f : α → β</code>，并返回的 <code>g</code> 和 <code>f</code> 的复合的函数。(理解这个函数的类型需要理解依值积类型，下面将对此进行解释。)</p>
<p>lambda表达式的一般形式是 <code>fun x : α =&gt; t</code>，其中变量 <code>x</code> 是一个 <strong>绑定变量（Bound Variable）</strong> ：它实际上是一个占位符，其「作用域」没有扩展到表达式 <code>t</code> 之外。例如，表达式 <code>fun (b : β) (x : α) =&gt; b</code> 中的变量 <code>b</code> 与前面声明的常量 <code>b</code> 没有任何关系。事实上，这个表达式表示的函数与 <code>fun (u : β) (z : α) =&gt; u</code> 是一样的。形式上，可以通过给绑定变量重命名来使形式相同的表达式被看作是 <strong>alpha等价</strong> 的，也就是被认为是「一样的」。Lean 认识这种等价性。</p>
<p>注意到项 <code>t : α → β</code> 应用到项 <code>s : α</code> 上导出了表达式 <code>t s : β</code>。回到前面的例子，为清晰起见给绑定变量重命名，注意以下表达式的类型:</p>
<pre><code class="language-lean">#check (fun x : Nat =&gt; x) 1     -- Nat
#check (fun x : Nat =&gt; true) 1  -- Bool

def f (n : Nat) : String := toString n
def g (s : String) : Bool := s.length &gt; 0

#check
  (fun (α β γ : Type) (u : β → γ) (v : α → β) (x : α) =&gt; u (v x)) Nat String Bool g f 0
  -- Bool
</code></pre>
<!--
As expected, the expression ``(fun x : Nat =>  x) 1`` has type ``Nat``.
In fact, more should be true: applying the expression ``(fun x : Nat
=> x)`` to ``1`` should "return" the value ``1``. And, indeed, it does:
-->
<p>表达式 <code>(fun x : Nat =&gt;  x) 1</code> 的类型是 <code>Nat</code>。实际上，应用 <code>(fun x : Nat =&gt; x)</code> 到 <code>1</code> 上返回的值是 <code>1</code>。</p>
<pre><code class="language-lean">#eval (fun x : Nat =&gt; x) 1     -- 1
#eval (fun x : Nat =&gt; true) 1  -- true
</code></pre>
<!--
You will see later how these terms are evaluated. For now, notice that
this is an important feature of dependent type theory: every term has
a computational behavior, and supports a notion of *normalization*. In
principle, two terms that reduce to the same value are called
*definitionally equal*. They are considered "the same" by Lean's type
checker, and Lean does its best to recognize and support these
identifications.

Lean is a complete programming language. It has a compiler that
generates a binary executable and an interactive interpreter. You can
use the command `#eval` to execute expressions, and it is the
preferred way of testing your functions.
-->
<p>稍后你将看到这些项是如何计算的。现在，请注意这是依值类型论的一个重要特征：每个项都有一个计算行为，并支持「标准化」的概念。从原则上讲，两个可以化约为相同形式的项被称为「定义等价」。它们被 Lean 的类型检查器认为是「相同的」，并且 Lean 尽其所能地识别和支持这些识别结果。</p>
<p>Lean 是个完备的编程语言。它有一个生成二进制可执行文件的编译器，和一个交互式解释器。你可以用<code>#eval</code>命令执行表达式，这也是测试你的函数的好办法。</p>
<!--
Note that `#eval` and
`#reduce` are *not* equivalent. The command `#eval` first compiles
Lean expressions into an intermediate representation (IR) and then
uses an interpreter to execute the generated IR. Some builtin types
(e.g., `Nat`, `String`, `Array`) have a more efficient representation
in the IR. The IR has support for using foreign functions that are
opaque to Lean.

In contrast, the ``#reduce`` command relies on a reduction engine
similar to the one used in Lean's trusted kernel, the part of Lean
that is responsible for checking and verifying the correctness of
expressions and proofs. It is less efficient than ``#eval``, and
treats all foreign functions as opaque constants. You will learn later
that there are some other differences between the two commands.
-->
<blockquote>
<p>注意到<code>#eval</code>和<code>#reduce</code><em>不是</em>等价的。<code>#eval</code>命令首先把 Lean 表达式编译成中间表示（intermediate representation, IR）然后用一个解释器来执行这个IR。某些内建类型（例如，<code>Nat</code>、<code>String</code>、<code>Array</code>）在 IR 中有更有效率的表示。IR支持使用对 Lean 不透明的外部函数。
<code>#reduce</code> 命令建立在一个规约引擎上，类似于在 Lean 的可信内核中使用的那个，它是负责检查和验证表达式和证明正确性的那一部分。它的效率不如 <code>#eval</code>，且将所有外部函数视为不透明的常量。之后你将了解到这两个命令之间还有其他一些差异。</p>
</blockquote>
<!--
## Definitions
-->
<h2 id="定义"><a class="header" href="#定义">定义</a></h2>
<!--
Recall that the ``def`` keyword provides one important way of declaring new named
objects.
-->
<p><code>def</code> 关键字提供了一个声明新对象的重要方式。</p>
<pre><code class="language-lean">def double (x : Nat) : Nat :=
  x + x
</code></pre>
<!--
This might look more familiar to you if you know how functions work in
other programming languages. The name `double` is defined as a
function that takes an input parameter `x` of type `Nat`, where the
result of the call is `x + x`, so it is returning type `Nat`. You
can then invoke this function using:
-->
<p>这很类似其他编程语言中的函数。名字 <code>double</code> 被定义为一个函数，它接受一个类型为 <code>Nat</code> 的输入参数 <code>x</code>，其结果是<code>x + x</code>，因此它返回类型 <code>Nat</code>。然后你可以调用这个函数:</p>
<pre><code class="language-lean"><span class="boring">def double (x : Nat) : Nat :=
</span><span class="boring"> x + x
</span>#eval double 3    -- 6
</code></pre>
<!--
In this case you can think of `def` as a kind of named `lambda`.
The following yields the same result:
-->
<p>在这种情况下你可以把 <code>def</code> 想成一种 <code>lambda</code>。下面给出了相同的结果：</p>
<pre><code class="language-lean">def double : Nat → Nat :=
  fun x =&gt; x + x

#eval double 3    -- 6
</code></pre>
<!--
You can omit the type declarations when Lean has enough information to
infer it.  Type inference is an important part of Lean:
-->
<p>当 Lean 有足够的信息来推断时，你可以省略类型声明。类型推断是 Lean 的重要组成部分:</p>
<pre><code class="language-lean">def double :=
  fun (x : Nat) =&gt; x + x
</code></pre>
<!--
The general form of a definition is ``def foo : α := bar`` where
``α`` is the type returned from the expression ``bar``.  Lean can
usually infer the type ``α``, but it is often a good idea to write it
explicitly.  This clarifies your intention, and Lean will flag an
error if the right-hand side of the definition does not have a matching
type.

The right hand side `bar` can be any expression, not just a lambda.
So `def` can also be used to simply name a value like this:
-->
<p>定义的一般形式是 <code>def foo : α := bar</code>，其中 <code>α</code> 是表达式 <code>bar</code> 返回的类型。Lean 通常可以推断类型 <code>α</code>，但是精确写出它可以澄清你的意图，并且如果定义的右侧没有匹配你的类型，Lean 将标记一个错误。</p>
<p><code>bar</code> 可以是任何一个表达式，不只是一个 lambda 表达式。因此 <code>def</code> 也可以用于给一些值命名，例如：</p>
<pre><code class="language-lean">def pi := 3.141592654
</code></pre>
<!--
`def` can take multiple input parameters.  Let's create one
that adds two natural numbers:
-->
<p><code>def</code> 可以接受多个输入参数。比如定义两自然数之和：</p>
<pre><code class="language-lean">def add (x y : Nat) :=
  x + y

#eval add 3 2               -- 5
</code></pre>
<!--
The parameter list can be separated like this:
-->
<p>参数列表可以像这样分开写：</p>
<pre><code class="language-lean"><span class="boring">def double (x : Nat) : Nat :=
</span><span class="boring"> x + x
</span>def add (x : Nat) (y : Nat) :=
  x + y

#eval add (double 3) (7 + 9)  -- 22
</code></pre>
<!--
Notice here we called the `double` function to create the first
parameter to `add`.

You can use other more interesting expressions inside a `def`:
-->
<p>注意到这里我们使用了 <code>double</code> 函数来创建 <code>add</code> 函数的第一个参数。</p>
<p>你还可以在 <code>def</code> 中写一些更有趣的表达式：</p>
<pre><code class="language-lean">def greater (x y : Nat) :=
  if x &gt; y then x
  else y
</code></pre>
<!--
You can probably guess what this one will do.

You can also define a function that takes another function as input.
The following calls a given function twice passing the output of the
first invocation to the second:
-->
<p>猜猜这个可以做什么。</p>
<p>还可以定义一个函数，该函数接受另一个函数作为输入。下面调用一个给定函数两次，将第一次调用的输出传递给第二次:</p>
<pre><code class="language-lean"><span class="boring">def double (x : Nat) : Nat :=
</span><span class="boring"> x + x
</span>def doTwice (f : Nat → Nat) (x : Nat) : Nat :=
  f (f x)

#eval doTwice double 2   -- 8
</code></pre>
<!--
Now to get a bit more abstract, you can also specify arguments that
are like type parameters:
-->
<p>现在为了更抽象一点，你也可以指定类型参数等：</p>
<pre><code class="language-lean">def compose (α β γ : Type) (g : β → γ) (f : α → β) (x : α) : γ :=
  g (f x)
</code></pre>
<!--
This means `compose` is a function that takes any two functions as input
arguments, so long as those functions each take only one input.
The type algebra `β → γ` and `α → β` means it is a requirement
that the type of the output of the second function must match the
type of the input to the first function - which makes sense, otherwise
the two functions would not be composable.

`compose` also takes a 3rd argument of type `α` which
it uses to invoke the second function (locally named `f`) and it
passes the result of that function (which is type `β`) as input to the
first function (locally named `g`).  The first function returns a type
`γ` so that is also the return type of the `compose` function.

`compose` is also very general in that it works over any type
`α β γ`.  This means `compose` can compose just about any 2 functions
so long as they each take one parameter, and so long as the type of
output of the second matches the input of the first.  For example:
-->
<p>这句代码的意思是：函数 <code>compose</code> 首先接受任何两个函数作为参数，这其中两个函数各自接受一个输入。类型<code>β → γ</code>和<code>α → β</code>意思是要求第二个函数的输出类型必须与第一个函数的输入类型匹配，否则这两个函数将无法复合。</p>
<p><code>compose</code> 再接受一个类型为<code>compose</code> 再参数作为第二个函数（这里叫做 <code>f</code>）的输入，通过这个函数之后的返回结果类型为<code>β</code>，再作为第一个函数（这里叫做 <code>g</code>）的输入。第一个函数返回类型为<code>γ</code>，这就是 <code>compose</code> 函数最终返回的类型。</p>
<p><code>compose</code> 可以在任意的类型<code>α β γ</code>上使用，它可以复合任意两个函数，只要前一个的输出类型是后一个的输入类型。举例：</p>
<pre><code class="language-lean"><span class="boring">def compose (α β γ : Type) (g : β → γ) (f : α → β) (x : α) : γ :=
</span><span class="boring"> g (f x)
</span><span class="boring">def double (x : Nat) : Nat :=
</span><span class="boring"> x + x
</span>def square (x : Nat) : Nat :=
  x * x

#eval compose Nat Nat Nat double square 3  -- 18
</code></pre>
<!--
Local Definitions
-----------------
-->
<h2 id="局部定义"><a class="header" href="#局部定义">局部定义</a></h2>
<!--
Lean also allows you to introduce "local" definitions using the
``let`` keyword. The expression ``let a := t1; t2`` is
definitionally equal to the result of replacing every occurrence of
``a`` in ``t2`` by ``t1``.
-->
<p>Lean 还允许你使用 <code>let</code> 关键字来引入「局部定义」。表达式 <code>let a := t1; t2</code> 定义等价于把 <code>t2</code> 中所有的 <code>a</code> 替换成 <code>t1</code> 的结果。</p>
<pre><code class="language-lean">#check let y := 2 + 2; y * y   -- Nat
#eval  let y := 2 + 2; y * y   -- 16

def twice_double (x : Nat) : Nat :=
  let y := x + x; y * y

#eval twice_double 2   -- 16
</code></pre>
<!--
Here, ``twice_double x`` is definitionally equal to the term ``(x + x) * (x + x)``.

You can combine multiple assignments by chaining ``let`` statements:
-->
<p>这里 <code>twice_double x</code> 定义等价于 <code>(x + x) * (x + x)</code>。</p>
<p>你可以连续使用多个 <code>let</code> 命令来进行多次替换：</p>
<pre><code class="language-lean">#check let y := 2 + 2; let z := y + y; z * z   -- Nat
#eval  let y := 2 + 2; let z := y + y; z * z   -- 64
</code></pre>
<!--
The ``;`` can be omitted when a line break is used.
-->
<p>换行可以省略分号 <code>;</code>。</p>
<pre><code class="language-lean">def t (x : Nat) : Nat :=
  let y := x + x
  y * y
</code></pre>
<!--
Notice that the meaning of the expression ``let a := t1; t2`` is very
similar to the meaning of ``(fun a => t2) t1``, but the two are not
the same. In the first expression, you should think of every instance
of ``a`` in ``t2`` as a syntactic abbreviation for ``t1``. In the
second expression, ``a`` is a variable, and the expression
``fun a => t2`` has to make sense independently of the value of ``a``.
The ``let`` construct is a stronger means of abbreviation, and there
are expressions of the form ``let a := t1; t2`` that cannot be
expressed as ``(fun a => t2) t1``. As an exercise, try to understand
why the definition of ``foo`` below type checks, but the definition of
``bar`` does not.
-->
<p>表达式 <code>let a := t1; t2</code> 的意思很类似 <code>(fun a =&gt; t2) t1</code>，但是这两者并不一样。前者中你要把 <code>t2</code> 中每一个 <code>a</code> 的实例考虑成 <code>t1</code> 的一个缩写。后者中 <code>a</code> 是一个变量，表达式 <code>fun a =&gt; t2</code> 不依赖于 <code>a</code> 的取值而可以单独具有意义。作为一个对照，考虑为什么下面的 <code>foo</code> 定义是合法的，但 <code>bar</code> 不行（因为在确定了 <code>x</code> 所属的 <code>a</code> 是什么之前，是无法让它 <code>+ 2</code> 的）。</p>
<pre><code class="language-lean">def foo := let a := Nat; fun x : a =&gt; x + 2
/-
  def bar := (fun a =&gt; fun x : a =&gt; x + 2) Nat
-/
</code></pre>
<!--
# Variables and Sections
-->
<h2 id="变量和小节"><a class="header" href="#变量和小节">变量和小节</a></h2>
<!--
Consider the following three function definitions:
-->
<p>考虑下面这三个函数定义：</p>
<pre><code class="language-lean">def compose (α β γ : Type) (g : β → γ) (f : α → β) (x : α) : γ :=
  g (f x)

def doTwice (α : Type) (h : α → α) (x : α) : α :=
  h (h x)

def doThrice (α : Type) (h : α → α) (x : α) : α :=
  h (h (h x))
</code></pre>
<!--
Lean provides you with the ``variable`` command to make such
declarations look more compact:
-->
<p>Lean 提供 <code>variable</code> 指令来让这些声明变得紧凑：</p>
<pre><code class="language-lean">variable (α β γ : Type)

def compose (g : β → γ) (f : α → β) (x : α) : γ :=
  g (f x)

def doTwice (h : α → α) (x : α) : α :=
  h (h x)

def doThrice (h : α → α) (x : α) : α :=
  h (h (h x))
</code></pre>
<!--
You can declare variables of any type, not just ``Type`` itself:
-->
<p>你可以声明任意类型的变量，不只是 <code>Type</code> 类型：</p>
<pre><code class="language-lean">variable (α β γ : Type)
variable (g : β → γ) (f : α → β) (h : α → α)
variable (x : α)

def compose := g (f x)
def doTwice := h (h x)
def doThrice := h (h (h x))

#print compose
#print doTwice
#print doThrice
</code></pre>
<!--
Printing them out shows that all three groups of definitions have
exactly the same effect.

The ``variable`` command instructs Lean to insert the declared
variables as bound variables in definitions that refer to them by
name. Lean is smart enough to figure out which variables are used
explicitly or implicitly in a definition. You can therefore proceed as
though ``α``, ``β``, ``γ``, ``g``, ``f``, ``h``, and ``x`` are fixed
objects when you write your definitions, and let Lean abstract the
definitions for you automatically.

When declared in this way, a variable stays in scope until the end of
the file you are working on. Sometimes, however, it is useful to limit
the scope of a variable. For that purpose, Lean provides the notion of
a ``section``:
-->
<p>输出结果表明所有三组定义具有完全相同的效果。</p>
<p><code>variable</code> 命令指示 Lean 将声明的变量作为绑定变量插入定义中，这些定义通过名称引用它们。Lean 足够聪明，它能找出定义中显式或隐式使用哪些变量。因此在写定义时，你可以将 <code>α</code>、<code>β</code>、<code>γ</code>、<code>g</code>、<code>f</code>、<code>h</code> 和 <code>x</code> 视为固定的对象，并让 Lean 自动抽象这些定义。</p>
<p>当以这种方式声明时，变量将一直保持存在，直到所处理的文件结束。然而，有时需要限制变量的作用范围。Lean 提供了小节标记 <code>section</code> 来实现这个目的：</p>
<pre><code class="language-lean">section useful
  variable (α β γ : Type)
  variable (g : β → γ) (f : α → β) (h : α → α)
  variable (x : α)

  def compose := g (f x)
  def doTwice := h (h x)
  def doThrice := h (h (h x))
end useful
</code></pre>
<!--
When the section is closed, the variables go out of scope, and cannot
be referenced any more.

You do not have to indent the lines within a section. Nor do you have
to name a section, which is to say, you can use an anonymous
``section`` / ``end`` pair. If you do name a section, however, you
have to close it using the same name. Sections can also be nested,
which allows you to declare new variables incrementally.
-->
<p>当一个小节结束后，变量不再发挥作用。</p>
<p>你不需要缩进一个小节中的行。你也不需要命名一个小节，也就是说，你可以使用一个匿名的 <code>section</code> /<code>end</code> 对。但是，如果你确实命名了一个小节，你必须使用相同的名字关闭它。小节也可以嵌套，这允许你逐步增加声明新变量。</p>
<!--
# Namespaces
-->
<h2 id="命名空间"><a class="header" href="#命名空间">命名空间</a></h2>
<!--
Lean provides you with the ability to group definitions into nested,
hierarchical *namespaces*:
-->
<p>Lean 可以让你把定义放进一个「命名空间」（<code>namespace</code>）里，并且命名空间也是层次化的：</p>
<pre><code class="language-lean">namespace Foo
  def a : Nat := 5
  def f (x : Nat) : Nat := x + 7

  def fa : Nat := f a
  def ffa : Nat := f (f a)

  #check a
  #check f
  #check fa
  #check ffa
  #check Foo.fa
end Foo

-- #check a  -- error
-- #check f  -- error
#check Foo.a
#check Foo.f
#check Foo.fa
#check Foo.ffa

open Foo

#check a
#check f
#check fa
#check Foo.fa
</code></pre>
<!--
When you declare that you are working in the namespace ``Foo``, every
identifier you declare has a full name with prefix "``Foo.``". Within
the namespace, you can refer to identifiers by their shorter names,
but once you end the namespace, you have to use the longer names.
Unlike `section`, namespaces require a name. There is only one
anonymous namespace at the root level.

The ``open`` command brings the shorter names into the current
context. Often, when you import a module, you will want to open one or
more of the namespaces it contains, to have access to the short
identifiers. But sometimes you will want to leave this information
protected by a fully qualified name, for example, when they conflict
with identifiers in another namespace you want to use. Thus namespaces
give you a way to manage names in your working environment.

For example, Lean groups definitions and theorems involving lists into
a namespace ``List``.
-->
<p>当你声明你在命名空间 <code>Foo</code> 中工作时，你声明的每个标识符都有一个前缀 <code>Foo.</code>。在打开的命名空间中，可以通过较短的名称引用标识符，但是关闭命名空间后，必须使用较长的名称。与 <code>section</code> 不同，命名空间需要一个名称。只有一个匿名命名空间在根级别上。</p>
<p><code>open</code> 命令使你可以在当前使用较短的名称。通常，当你导入一个模块时，你会想打开它包含的一个或多个命名空间，以访问短标识符。但是，有时你希望将这些信息保留在一个完全限定的名称中，例如，当它们与你想要使用的另一个命名空间中的标识符冲突时。因此，命名空间为你提供了一种在工作环境中管理名称的方法。</p>
<p>例如，Lean 把和列表相关的定义和定理都放在了命名空间 <code>List</code> 之中。</p>
<pre><code class="language-lean">#check List.nil
#check List.cons
#check List.map
</code></pre>
<!--
The command ``open List`` allows you to use the shorter names:
-->
<p><code>open List</code> 命令允许你使用短一点的名字：</p>
<pre><code class="language-lean">open List

#check nil
#check cons
#check map
</code></pre>
<!--
Like sections, namespaces can be nested:
-->
<p>像小节一样，命名空间也是可以嵌套的：</p>
<pre><code class="language-lean">namespace Foo
  def a : Nat := 5
  def f (x : Nat) : Nat := x + 7

  def fa : Nat := f a

  namespace Bar
    def ffa : Nat := f (f a)

    #check fa
    #check ffa
  end Bar

  #check fa
  #check Bar.ffa
end Foo

#check Foo.fa
#check Foo.Bar.ffa

open Foo

#check fa
#check Bar.ffa
</code></pre>
<!--
Namespaces that have been closed can later be reopened, even in another file:
-->
<p>关闭的命名空间可以之后重新打开，甚至是在另一个文件里：</p>
<pre><code class="language-lean">namespace Foo
  def a : Nat := 5
  def f (x : Nat) : Nat := x + 7

  def fa : Nat := f a
end Foo

#check Foo.a
#check Foo.f

namespace Foo
  def ffa : Nat := f (f a)
end Foo
</code></pre>
<!--
Like sections, nested namespaces have to be closed in the order they
are opened. Namespaces and sections serve different purposes:
namespaces organize data and sections declare variables for insertion
in definitions. Sections are also useful for delimiting the scope of
commands such as ``set_option`` and ``open``.

In many respects, however, a ``namespace ... end`` block behaves the
same as a ``section ... end`` block. In particular, if you use the
``variable`` command within a namespace, its scope is limited to the
namespace. Similarly, if you use an ``open`` command within a
namespace, its effects disappear when the namespace is closed.
-->
<p>与小节一样，嵌套的名称空间必须按照打开的顺序关闭。命名空间和小节有不同的用途：命名空间组织数据，小节声明变量，以便在定义中插入。小节对于分隔 <code>set_option</code> 和 <code>open</code> 等命令的范围也很有用。</p>
<p>然而，在许多方面，<code>namespace ... end</code> 结构块和 <code>section ... end</code> 表现出来的特征是一样的。尤其是你在命名空间中使用 <code>variable</code> 命令时，它的作用范围被限制在命名空间里。类似地，如果你在命名空间中使用 <code>open</code> 命令，它的效果在命名空间关闭后消失。</p>
<!--
## What makes dependent type theory dependent?
-->
<h2 id="依值类型论依赖着什么"><a class="header" href="#依值类型论依赖着什么">依值类型论「依赖」着什么?</a></h2>
<!--
The short explanation is that types can depend on parameters. You
have already seen a nice example of this: the type ``List α`` depends
on the argument ``α``, and this dependence is what distinguishes
``List Nat`` and ``List Bool``. For another example, consider the
type ``Vector α n``, the type of vectors of elements of ``α`` of
length ``n``.  This type depends on *two* parameters: the type of the
elements in the vector (``α : Type``) and the length of the vector
``n : Nat``.

Suppose you wish to write a function ``cons`` which inserts a new
element at the head of a list. What type should ``cons`` have? Such a
function is *polymorphic*: you expect the ``cons`` function for
``Nat``, ``Bool``, or an arbitrary type ``α`` to behave the same way.
So it makes sense to take the type to be the first argument to
``cons``, so that for any type, ``α``, ``cons α`` is the insertion
function for lists of type ``α``. In other words, for every ``α``,
``cons α`` is the function that takes an element ``a : α`` and a list
``as : List α``, and returns a new list, so you have ``cons α a as : List α``.

It is clear that ``cons α`` should have type ``α → List α → List α``.
But what type should ``cons`` have?  A first guess might be
``Type → α → List α → List α``, but, on reflection, this does not make
sense: the ``α`` in this expression does not refer to anything,
whereas it should refer to the argument of type ``Type``.  In other
words, *assuming* ``α : Type`` is the first argument to the function,
the type of the next two elements are ``α`` and ``List α``. These
types vary depending on the first argument, ``α``.
-->
<p>简单地说，类型可以依赖于参数。你已经看到了一个很好的例子：类型 <code>List α</code> 依赖于参数 <code>α</code>，而这种依赖性是区分 <code>List Nat</code> 和 <code>List Bool</code> 的关键。另一个例子，考虑类型 <code>Vector α n</code>，即长度为 <code>n</code> 的 <code>α</code> 元素的向量类型。这个类型取决于<em>两个</em>参数：向量中元素的类型 <code>α : Type</code> 和向量的长度 <code>n : Nat</code>。</p>
<p>假设你希望编写一个函数 <code>cons</code>，它在列表的开头插入一个新元素。<code>cons</code> 应该有什么类型？这样的函数是<em>多态的</em>（polymorphic）：你期望 <code>Nat</code>，<code>Bool</code> 或任意类型 <code>α</code> 的 <code>cons</code> 函数表现相同的方式。因此，将类型作为 <code>cons</code> 的第一个参数是有意义的，因此对于任何类型 <code>α</code>，<code>cons α</code> 是类型 <code>α</code> 列表的插入函数。换句话说，对于每个 <code>α</code>，<code>cons α</code> 是将元素 <code>a : α</code> 插入列表 <code>as : List α</code> 的函数，并返回一个新的列表，因此有 <code>cons α a as : List α</code>。</p>
<p>很明显，<code>cons α</code> 具有类型 <code>α → List α → List α</code>，但是 <code>cons</code> 具有什么类型？如果我们假设是 <code>Type → α → list α → list α</code>，那么问题在于，这个类型表达式没有意义：<code>α</code> 没有任何的所指，但它实际上指的是某个类型 <code>Type</code>。换句话说，<em>假设</em><code>α : Type</code> 是函数的首个参数，之后的两个参数的类型是 <code>α</code> 和 <code>List α</code>，它们依赖于首个参数 <code>α</code>。</p>
<pre><code class="language-lean">def cons (α : Type) (a : α) (as : List α) : List α :=
  List.cons a as

#check cons Nat        -- Nat → List Nat → List Nat
#check cons Bool       -- Bool → List Bool → List Bool
#check cons            -- (α : Type) → α → List α → List α
</code></pre>
<!--
This is an instance of a *dependent function type*, or *dependent
arrow type*. Given ``α : Type`` and ``β : α → Type``, think of ``β``
as a family of types over ``α``, that is, a type ``β a`` for each
``a : α``. In that case, the type ``(a : α) → β a`` denotes the type
of functions ``f`` with the property that, for each ``a : α``, ``f a``
is an element of ``β a``. In other words, the type of the value
returned by ``f`` depends on its input.

Notice that ``(a : α) → β`` makes sense for any expression ``β :
Type``. When the value of ``β`` depends on ``a`` (as does, for
example, the expression ``β a`` in the previous paragraph),
``(a : α) → β`` denotes a dependent function type. When ``β`` doesn't
depend on ``a``, ``(a : α) → β`` is no different from the type
``α → β``.  Indeed, in dependent type theory (and in Lean), ``α → β``
is just notation for ``(a : α) → β`` when ``β`` does not depend on ``a``.

Returning to the example of lists, you can use the command `#check` to
inspect the type of the following `List` functions.  The ``@`` symbol
and the difference between the round and curly braces will be
explained momentarily.
-->
<p>这就是<em>依值函数类型</em>，或者<em>依值箭头类型</em>的一个例子。给定 <code>α : Type</code> 和 <code>β : α → Type</code>，把 <code>β</code> 考虑成 <code>α</code> 之上的类型类，也就是说，对于每个 <code>a : α</code> 都有类型 <code>β a</code>。在这种情况下，类型 <code>(a : α) → β a</code> 表示的是具有如下性质的函数 <code>f</code> 的类型：对于每个 <code>a : α</code>，<code>f a</code> 是 <code>β a</code> 的一个元素。换句话说，<code>f</code> 返回值的类型取决于其输入。</p>
<p>注意到 <code>(a : α) → β</code> 对于任意表达式 <code>β : Type</code> 都有意义。当 <code>β</code> 的值依赖于 <code>a</code>（例如，在前一段的表达式 <code>β a</code>），<code>(a : α) → β</code> 表示一个依值函数类型。当 <code>β</code> 的值不依赖于 <code>a</code>，<code>(a : α) → β</code> 与类型 <code>α → β</code> 无异。实际上，在依值类型论（以及Lean）中，<code>α → β</code> 表达的意思就是当 <code>β</code> 的值不依赖于 <code>a</code> 时的 <code>(a : α) → β</code>。【注】</p>
<blockquote>
<p>译者注：在依值类型论的数学符号体系中，依值类型是用 <code>Π</code> 符号来表达的，在Lean 3中还使用这种表达，例如 <code>Π x : α, β x</code>。Lean 4抛弃了这种不友好的写法。<code>(x : α) → β x</code> 这种写法在引入「构造子」之后意义会更明朗一些（见下一个注释），对于来自数学背景的读者可以把它类比于 <code>forall x : α, β x</code> 这种写法（这也是合法的 Lean 语句），关于前一种符号在<a href="./quantifiers_and_equality.html">量词与等价</a>一章中有更详细的说明。同时，依值类型有着更丰富的引入动机，推荐读者寻找一些拓展读物。</p>
</blockquote>
<p>回到列表的例子，你可以使用<code>#check</code>命令来检查下列的 <code>List</code> 函数。<code>@</code> 符号以及圆括号和花括号之间的区别将在后面解释。</p>
<pre><code class="language-lean">#check @List.cons    -- {α : Type u_1} → α → List α → List α
#check @List.nil     -- {α : Type u_1} → List α
#check @List.length  -- {α : Type u_1} → List α → Nat
#check @List.append  -- {α : Type u_1} → List α → List α → List α
</code></pre>
<!--
Just as dependent function types ``(a : α) → β a`` generalize the
notion of a function type ``α → β`` by allowing ``β`` to depend on
``α``, dependent Cartesian product types ``(a : α) × β a`` generalize
the Cartesian product ``α × β`` in the same way. Dependent products
are also called *sigma* types, and you can also write them as
`Σ a : α, β a`. You can use `⟨a, b⟩` or `Sigma.mk a b` to create a
dependent pair.  The `⟨` and `⟩` characters may be typed with
`\langle` and `\rangle` or `\<` and `\>`, respectively.
-->
<p>就像依值函数类型 <code>(a : α) → β a</code> 通过允许 <code>β</code> 依赖 <code>α</code> 从而推广了函数类型 <code>α → β</code>，依值笛卡尔积类型 <code>(a : α) × β a</code> 同样推广了笛卡尔积 <code>α × β</code>。依值积类型又称为<em>sigma</em>类型，可写成<code>Σ a : α, β a</code>。你可以用<code>⟨a, b⟩</code>或者<code>Sigma.mk a b</code>来创建依值对。 <code>⟨</code>和<code>⟩</code>符号可以用<code>\langle</code>和<code>\rangle</code>或者<code>\&lt;</code>和<code>\&gt;</code>来输入.</p>
<pre><code class="language-lean">universe u v

def f (α : Type u) (β : α → Type v) (a : α) (b : β a) : (a : α) × β a :=
  ⟨a, b⟩

def g (α : Type u) (β : α → Type v) (a : α) (b : β a) : Σ a : α, β a :=
  Sigma.mk a b

def h1 (x : Nat) : Nat :=
  (f Type (fun α =&gt; α) Nat x).2

#eval h1 5 -- 5

def h2 (x : Nat) : Nat :=
  (g Type (fun α =&gt; α) Nat x).2

#eval h2 5 -- 5
</code></pre>
<!--
The functions `f` and `g` above denote the same function.
-->
<p>函数 <code>f</code> 和 <code>g</code> 表达的是同样的函数。</p>
<!--
Implicit Arguments
------------------
-->
<h2 id="隐参数"><a class="header" href="#隐参数">隐参数</a></h2>
<!--
Suppose we have an implementation of lists as:
-->
<p>假设我们有一个列表的实现如下：</p>
<pre><code class="language-lean"><span class="boring">universe u
</span><span class="boring">def Lst (α : Type u) : Type u := List α
</span><span class="boring">def Lst.cons (α : Type u) (a : α) (as : Lst α) : Lst α := List.cons a as
</span><span class="boring">def Lst.nil (α : Type u) : Lst α := List.nil
</span><span class="boring">def Lst.append (α : Type u) (as bs : Lst α) : Lst α := List.append as bs
</span>#check Lst          -- Lst.{u} (α : Type u) : Type u
#check Lst.cons     -- Lst.cons.{u} (α : Type u) (a : α) (as : Lst α) : Lst α
#check Lst.nil      -- Lst.nil.{u} (α : Type u) : Lst α
#check Lst.append   -- Lst.append.{u} (α : Type u) (as bs : Lst α) : Lst α
</code></pre>
<!--
Then, you can construct lists of `Nat` as follows.
-->
<p>然后，你可以建立一个自然数列表如下：</p>
<pre><code class="language-lean"><span class="boring">universe u
</span><span class="boring">def Lst (α : Type u) : Type u := List α
</span><span class="boring">def Lst.cons (α : Type u) (a : α) (as : Lst α) : Lst α := List.cons a as
</span><span class="boring">def Lst.nil (α : Type u) : Lst α := List.nil
</span><span class="boring">def Lst.append (α : Type u) (as bs : Lst α) : Lst α := List.append as bs
</span><span class="boring">#check Lst          -- Type u_1 → Type u_1
</span><span class="boring">#check Lst.cons     -- (α : Type u_1) → α → Lst α → Lst α
</span><span class="boring">#check Lst.nil      -- (α : Type u_1) → Lst α
</span><span class="boring">#check Lst.append   -- (α : Type u_1) → Lst α → Lst α → Lst α
</span>#check Lst.cons Nat 0 (Lst.nil Nat)

def as : Lst Nat := Lst.nil Nat
def bs : Lst Nat := Lst.cons Nat 5 (Lst.nil Nat)

#check Lst.append Nat as bs
</code></pre>
<!--
Because the constructors are polymorphic over types, we have to insert
the type ``Nat`` as an argument repeatedly. But this information is
redundant: one can infer the argument ``α`` in
``Lst.cons Nat 5 (Lst.nil Nat)`` from the fact that the second argument, ``5``, has
type ``Nat``. One can similarly infer the argument in ``Lst.nil Nat``, not
from anything else in that expression, but from the fact that it is
sent as an argument to the function ``Lst.cons``, which expects an element
of type ``Lst α`` in that position.

This is a central feature of dependent type theory: terms carry a lot
of information, and often some of that information can be inferred
from the context. In Lean, one uses an underscore, ``_``, to specify
that the system should fill in the information automatically. This is
known as an "implicit argument."
-->
<p>由于构造子对类型是多态的【注】，我们需要重复插入类型 <code>Nat</code> 作为一个参数。但是这个信息是多余的：我们可以推断表达式 <code>Lst.cons Nat 5 (Lst.nil Nat)</code> 中参数 <code>α</code> 的类型，这是通过第二个参数 <code>5</code> 的类型是 <code>Nat</code> 来实现的。类似地，我们可以推断 <code>Lst.nil Nat</code> 中参数的类型，这是通过它作为函数 <code>Lst.cons</code> 的一个参数，且这个函数在这个位置需要接收的是一个具有 <code>Lst α</code> 类型的参数来实现的。</p>
<blockquote>
<p>译者注：「构造子」（Constructor）的概念前文未加解释，对类型论不熟悉的读者可能会困惑。它指的是一种「依值类型的类型」，也可以看作「类型的构造子」，例如 <code>λ α : α -&gt; α</code> 甚至可看成 <code>⋆ -&gt; ⋆</code>。当给 <code>α</code> 或者 <code>⋆</code> 赋予一个具体的类型时，这个表达式就成为了一个类型。前文中 <code>(x : α) → β x</code> 中的 <code>β</code> 就可以看成一个构造子，<code>(x : α)</code> 就是传进的类型参数。原句「构造子对类型是多态的」意为给构造子中放入不同类型时它会变成不同类型。</p>
</blockquote>
<p>这是依值类型论的一个主要特征：项包含大量信息，而且通常可以从上下文推断出一些信息。在 Lean 中，我们使用下划线 <code>_</code> 来指定系统应该自动填写信息。这就是所谓的「隐参数」。</p>
<pre><code class="language-lean"><span class="boring">universe u
</span><span class="boring">def Lst (α : Type u) : Type u := List α
</span><span class="boring">def Lst.cons (α : Type u) (a : α) (as : Lst α) : Lst α := List.cons a as
</span><span class="boring">def Lst.nil (α : Type u) : Lst α := List.nil
</span><span class="boring">def Lst.append (α : Type u) (as bs : Lst α) : Lst α := List.append as bs
</span><span class="boring">#check Lst          -- Type u_1 → Type u_1
</span><span class="boring">#check Lst.cons     -- (α : Type u_1) → α → Lst α → Lst α
</span><span class="boring">#check Lst.nil      -- (α : Type u_1) → Lst α
</span><span class="boring">#check Lst.append   -- (α : Type u_1) → Lst α → Lst α → Lst α
</span>#check Lst.cons _ 0 (Lst.nil _)

def as : Lst Nat := Lst.nil _
def bs : Lst Nat := Lst.cons _ 5 (Lst.nil _)

#check Lst.append _ as bs
</code></pre>
<!--
It is still tedious, however, to type all these underscores. When a
function takes an argument that can generally be inferred from
context, Lean allows you to specify that this argument should, by
default, be left implicit. This is done by putting the arguments in
curly braces, as follows:
-->
<p>然而，敲这么多下划线仍然很无聊。当一个函数接受一个通常可以从上下文推断出来的参数时，Lean 允许你指定该参数在默认情况下应该保持隐式。这是通过将参数放入花括号来实现的，如下所示:</p>
<pre><code class="language-lean">universe u
def Lst (α : Type u) : Type u := List α

def Lst.cons {α : Type u} (a : α) (as : Lst α) : Lst α := List.cons a as
def Lst.nil {α : Type u} : Lst α := List.nil
def Lst.append {α : Type u} (as bs : Lst α) : Lst α := List.append as bs

#check Lst.cons 0 Lst.nil

def as : Lst Nat := Lst.nil
def bs : Lst Nat := Lst.cons 5 Lst.nil

#check Lst.append as bs
</code></pre>
<!--
All that has changed are the braces around ``α : Type u`` in the
declaration of the variables. We can also use this device in function
definitions:
-->
<p>唯一改变的是变量声明中 <code>α : Type u</code> 周围的花括号。我们也可以在函数定义中使用这个技巧：</p>
<pre><code class="language-lean">universe u
def ident {α : Type u} (x : α) := x

#check ident         -- ?m → ?m
#check ident 1       -- Nat
#check ident &quot;hello&quot; -- String
#check @ident        -- {α : Type u_1} → α → α
</code></pre>
<!--
This makes the first argument to ``ident`` implicit. Notationally,
this hides the specification of the type, making it look as though
``ident`` simply takes an argument of any type. In fact, the function
``id`` is defined in the standard library in exactly this way. We have
chosen a nontraditional name here only to avoid a clash of names.

Variables can also be specified as implicit when they are declared with
the ``variable`` command:
-->
<p>这使得 <code>ident</code> 的第一个参数是隐式的。从符号上讲，这隐藏了类型的说明，使它看起来好像 <code>ident</code> 只是接受任何类型的参数。事实上，函数 <code>id</code> 在标准库中就是以这种方式定义的。我们在这里选择一个非传统的名字只是为了避免名字的冲突。</p>
<p><code>variable</code> 命令也可以用这种技巧来来把变量变成隐式的：</p>
<pre><code class="language-lean">universe u

section
  variable {α : Type u}
  variable (x : α)
  def ident := x
end

#check ident
#check ident 4
#check ident &quot;hello&quot;
</code></pre>
<!--
This definition of ``ident`` here has the same effect as the one
above.

Lean has very complex mechanisms for instantiating implicit arguments,
and we will see that they can be used to infer function types,
predicates, and even proofs. The process of instantiating these
"holes," or "placeholders," in a term is often known as
*elaboration*. The presence of implicit arguments means that at times
there may be insufficient information to fix the meaning of an
expression precisely. An expression like ``id`` or ``List.nil`` is
said to be *polymorphic*, because it can take on different meanings in
different contexts.

One can always specify the type ``T`` of an expression ``e`` by
writing ``(e : T)``. This instructs Lean's elaborator to use the value
``T`` as the type of ``e`` when trying to resolve implicit
arguments. In the second pair of examples below, this mechanism is
used to specify the desired types of the expressions ``id`` and
``List.nil``:
-->
<p>此处定义的 <code>ident</code> 和上面那个效果是一样的。</p>
<p>Lean 有非常复杂的机制来实例化隐参数，我们将看到它们可以用来推断函数类型、谓词，甚至证明。实例化这些「洞」或「占位符」的过程通常被称为 <strong>繁饰（Elaboration）</strong> 。隐参数的存在意味着有时可能没有足够的信息来精确地确定表达式的含义。像 <code>id</code> 或 <code>List.nil</code> 这样的表达式被认为是「多态的」，因为它可以在不同的上下文中具有不同的含义。</p>
<p>可以通过写 <code>(e : T)</code> 来指定表达式 <code>e</code> 的类型 <code>T</code>。这就指导 Lean 的繁饰器在试图解决隐式参数时使用值 <code>T</code> 作为 <code>e</code> 的类型。在下面的第二个例子中，这种机制用于指定表达式 <code>id</code> 和 <code>List.nil</code> 所需的类型:</p>
<pre><code class="language-lean">#check List.nil               -- List ?m
#check id                     -- ?m → ?m

#check (List.nil : List Nat)  -- List Nat
#check (id : Nat → Nat)       -- Nat → Nat
</code></pre>
<!--
Numerals are overloaded in Lean, but when the type of a numeral cannot
be inferred, Lean assumes, by default, that it is a natural number. So
the expressions in the first two ``#check`` commands below are
elaborated in the same way, whereas the third ``#check`` command
interprets ``2`` as an integer.
-->
<p>Lean 中数字是重载的，但是当数字的类型不能被推断时，Lean 默认假设它是一个自然数。因此，下面的前两个 <code>#check</code> 命令中的表达式以同样的方式进行了繁饰，而第三个 <code>#check</code> 命令将 <code>2</code> 解释为整数。</p>
<pre><code class="language-lean">#check 2            -- Nat
#check (2 : Nat)    -- Nat
#check (2 : Int)    -- Int
</code></pre>
<!--
Sometimes, however, we may find ourselves in a situation where we have
declared an argument to a function to be implicit, but now want to
provide the argument explicitly. If ``foo`` is such a function, the
notation ``@foo`` denotes the same function with all the arguments
made explicit.
-->
<p>然而，有时我们可能会发现自己处于这样一种情况：我们已经声明了函数的参数是隐式的，但现在想显式地提供参数。如果 <code>foo</code> 是有隐参数的函数，符号 <code>@foo</code> 表示所有参数都是显式的该函数。</p>
<pre><code class="language-lean">#check @id        -- {α : Sort u_1} → α → α
#check @id Nat    -- Nat → Nat
#check @id Bool   -- Bool → Bool

#check @id Nat 1     -- Nat
#check @id Bool true -- Bool
</code></pre>
<p>第一个 <code>#check</code> 命令给出了标识符的类型 <code>id</code>，没有插入任何占位符。而且，输出表明第一个参数是隐式的。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
Propositions and Proofs
=======================
-->
<h1 id="命题和证明"><a class="header" href="#命题和证明">命题和证明</a></h1>
<!--
By now, you have seen some ways of defining objects and functions in
Lean. In this chapter, we will begin to explain how to write
mathematical assertions and proofs in the language of dependent type
theory as well.
-->
<p>前一章你已经看到了在 Lean 中定义对象和函数的一些方法。在本章中，我们还将开始解释如何用依值类型论的语言来编写数学命题和证明。</p>
<!--
Propositions as Types
---------------------
-->
<h2 id="命题即类型"><a class="header" href="#命题即类型">命题即类型</a></h2>
<!--
One strategy for proving assertions about objects defined in the
language of dependent type theory is to layer an assertion language
and a proof language on top of the definition language. But there is
no reason to multiply languages in this way: dependent type theory is
flexible and expressive, and there is no reason we cannot represent
assertions and proofs in the same general framework.

For example, we could introduce a new type, ``Prop``, to represent
propositions, and introduce constructors to build new propositions
from others.
-->
<p>证明在依值类型论语言中定义的对象的断言（assertion）的一种策略是在定义语言之上分层断言语言和证明语言。但是，没有理由以这种方式重复使用多种语言：依值类型论是灵活和富有表现力的，我们也没有理由不能在同一个总框架中表示断言和证明。</p>
<p>例如，我们可引入一种新类型 <code>Prop</code>，来表示命题，然后引入用其他命题构造新命题的构造子。</p>
<pre><code class="language-lean"><span class="boring">def Implies (p q : Prop) : Prop := p → q
</span>#check And     -- Prop → Prop → Prop
#check Or      -- Prop → Prop → Prop
#check Not     -- Prop → Prop
#check Implies -- Prop → Prop → Prop

variable (p q r : Prop)
#check And p q                      -- Prop
#check Or (And p q) r               -- Prop
#check Implies (And p q) (And q p)  -- Prop
</code></pre>
<!--
We could then introduce, for each element ``p : Prop``, another type
``Proof p``, for the type of proofs of ``p``.  An "axiom" would be a
constant of such a type.
-->
<p>对每个元素 <code>p : Prop</code>，可以引入另一个类型 <code>Proof p</code>，作为 <code>p</code> 的证明的类型。「公理」是这个类型中的常值。</p>
<pre><code class="language-lean"><span class="boring">def Implies (p q : Prop) : Prop := p → q
</span><span class="boring">structure Proof (p : Prop) : Type where
</span><span class="boring">  proof : p
</span>#check Proof   -- Proof : Prop → Type

axiom and_comm (p q : Prop) : Proof (Implies (And p q) (And q p))

variable (p q : Prop)
#check and_comm p q     -- Proof (Implies (And p q) (And q p))
</code></pre>
<!--
In addition to axioms, however, we would also need rules to build new
proofs from old ones. For example, in many proof systems for
propositional logic, we have the rule of modus ponens:

> From a proof of ``Implies p q`` and a proof of ``p``, we obtain a proof of ``q``.

We could represent this as follows:
-->
<p>然而，除了公理之外，我们还需要从旧证明中建立新证明的规则。例如，在许多命题逻辑的证明系统中，我们有肯定前件式（modus ponens）推理规则:</p>
<blockquote>
<p>如果能证明 <code>Implies p q</code> 和 <code>p</code>，则能证明 <code>q</code>。</p>
</blockquote>
<p>我们可以如下地表示它：</p>
<pre><code class="language-lean"><span class="boring">def Implies (p q : Prop) : Prop := p → q
</span><span class="boring">structure Proof (p : Prop) : Type where
</span><span class="boring">  proof : p
</span>axiom modus_ponens : (p q : Prop) → Proof (Implies p q) → Proof p → Proof q
</code></pre>
<!--
Systems of natural deduction for propositional logic also typically rely on the following rule:

> Suppose that, assuming ``p`` as a hypothesis, we have a proof of ``q``. Then we can "cancel" the hypothesis and obtain a proof of ``Implies p q``.

We could render this as follows:
-->
<p>命题逻辑的自然演绎系统通常也依赖于以下规则：</p>
<blockquote>
<p>当假设 <code>p</code> 成立时，如果我们能证明 <code>q</code>. 则我们能证明 <code>Implies p q</code>.</p>
</blockquote>
<p>我们可以如下地表示它：</p>
<pre><code class="language-lean"><span class="boring">def Implies (p q : Prop) : Prop := p → q
</span><span class="boring">structure Proof (p : Prop) : Type where
</span><span class="boring">  proof : p
</span>axiom implies_intro : (p q : Prop) → (Proof p → Proof q) → Proof (Implies p q)
</code></pre>
<!--
This approach would provide us with a reasonable way of building assertions and proofs.
Determining that an expression ``t`` is a correct proof of assertion ``p`` would then
simply be a matter of checking that ``t`` has type ``Proof p``.

Some simplifications are possible, however. To start with, we can
avoid writing the term ``Proof`` repeatedly by conflating ``Proof p``
with ``p`` itself. In other words, whenever we have ``p : Prop``, we
can interpret ``p`` as a type, namely, the type of its proofs. We can
then read ``t : p`` as the assertion that ``t`` is a proof of ``p``.

Moreover, once we make this identification, the rules for implication
show that we can pass back and forth between ``Implies p q`` and
``p → q``. In other words, implication between propositions ``p`` and ``q``
corresponds to having a function that takes any element of ``p`` to an
element of ``q``. As a result, the introduction of the connective
``Implies`` is entirely redundant: we can use the usual function space
constructor ``p → q`` from dependent type theory as our notion of
implication.

This is the approach followed in the Calculus of Constructions, and
hence in Lean as well. The fact that the rules for implication in a
proof system for natural deduction correspond exactly to the rules
governing abstraction and application for functions is an instance of
the *Curry-Howard isomorphism*, sometimes known as the
*propositions-as-types* paradigm. In fact, the type ``Prop`` is
syntactic sugar for ``Sort 0``, the very bottom of the type hierarchy
described in the last chapter. Moreover, ``Type u`` is also just
syntactic sugar for ``Sort (u+1)``. ``Prop`` has some special
features, but like the other type universes, it is closed under the
arrow constructor: if we have ``p q : Prop``, then ``p → q : Prop``.

There are at least two ways of thinking about propositions as
types. To some who take a constructive view of logic and mathematics,
this is a faithful rendering of what it means to be a proposition: a
proposition ``p`` represents a sort of data type, namely, a
specification of the type of data that constitutes a proof. A proof of
``p`` is then simply an object ``t : p`` of the right type.

Those not inclined to this ideology can view it, rather, as a simple
coding trick. To each proposition ``p`` we associate a type that is
empty if ``p`` is false and has a single element, say ``*``, if ``p``
is true. In the latter case, let us say that (the type associated
with) ``p`` is *inhabited*. It just so happens that the rules for
function application and abstraction can conveniently help us keep
track of which elements of ``Prop`` are inhabited. So constructing an
element ``t : p`` tells us that ``p`` is indeed true. You can think of
the inhabitant of ``p`` as being the "fact that ``p`` is true." A
proof of ``p → q`` uses "the fact that ``p`` is true" to obtain "the
fact that ``q`` is true."

Indeed, if ``p : Prop`` is any proposition, Lean's kernel treats any
two elements ``t1 t2 : p`` as being definitionally equal, much the
same way as it treats ``(fun x => t) s`` and ``t[s/x]`` as
definitionally equal. This is known as *proof irrelevance,* and is
consistent with the interpretation in the last paragraph. It means
that even though we can treat proofs ``t : p`` as ordinary objects in
the language of dependent type theory, they carry no information
beyond the fact that ``p`` is true.

The two ways we have suggested thinking about the
propositions-as-types paradigm differ in a fundamental way. From the
constructive point of view, proofs are abstract mathematical objects
that are *denoted* by suitable expressions in dependent type
theory. In contrast, if we think in terms of the coding trick
described above, then the expressions themselves do not denote
anything interesting. Rather, it is the fact that we can write them
down and check that they are well-typed that ensures that the
proposition in question is true. In other words, the expressions
*themselves* are the proofs.

In the exposition below, we will slip back and forth between these two
ways of talking, at times saying that an expression "constructs" or
"produces" or "returns" a proof of a proposition, and at other times
simply saying that it "is" such a proof. This is similar to the way
that computer scientists occasionally blur the distinction between
syntax and semantics by saying, at times, that a program "computes" a
certain function, and at other times speaking as though the program
"is" the function in question.

In any case, all that really matters is the bottom line. To formally
express a mathematical assertion in the language of dependent type
theory, we need to exhibit a term ``p : Prop``. To *prove* that
assertion, we need to exhibit a term ``t : p``. Lean's task, as a
proof assistant, is to help us to construct such a term, ``t``, and to
verify that it is well-formed and has the correct type.
-->
<p>这个功能让我们可以合理地搭建断言和证明。确定表达式 <code>t</code> 是 <code>p</code> 的证明，只需检查 <code>t</code> 具有类型 <code>Proof p</code>。</p>
<p>可以做一些简化。首先，我们可以通过将 <code>Proof p</code> 和 <code>p</code> 本身合并来避免重复地写 <code>Proof</code> 这个词。换句话说，只要我们有 <code>p : Prop</code>，我们就可以把 <code>p</code> 解释为一种类型，也就是它的证明类型。然后我们可以把 <code>t : p</code> 读作 <code>t</code> 是 <code>p</code> 的证明。</p>
<p>此外，我们可以在 <code>Implies p q</code> 和 <code>p → q</code> 之间来回切换。换句话说，命题 <code>p</code> 和 <code>q</code> 之间的含义对应于一个函数，它将 <code>p</code> 的任何元素接受为 <code>q</code> 的一个元素。因此，引入连接词 <code>Implies</code> 是完全多余的：我们可以使用依值类型论中常见的函数空间构造子 <code>p → q</code> 作为我们的蕴含概念。</p>
<p>这是在构造演算（Calculus of Constructions）中遵循的方法，因此在 Lean 中也是如此。自然演绎证明系统中的蕴含规则与控制函数抽象（abstraction）和应用（application）的规则完全一致，这是<em>Curry-Howard同构</em>的一个实例，有时也被称为<em>命题即类型</em>。事实上，类型 <code>Prop</code> 是上一章描述的类型层次结构的最底部 <code>Sort 0</code> 的语法糖。此外，<code>Type u</code> 也只是 <code>Sort (u+1)</code> 的语法糖。<code>Prop</code> 有一些特殊的特性，但像其他类型宇宙一样，它在箭头构造子下是封闭的:如果我们有 <code>p q : Prop</code>，那么 <code>p → q : Prop</code>。</p>
<p>至少有两种将命题作为类型来思考的方法。对于那些对逻辑和数学中的构造主义者来说，这是对命题含义的忠实诠释：命题 <code>p</code> 代表了一种数据类型，即构成证明的数据类型的说明。<code>p</code> 的证明就是正确类型的对象 <code>t : p</code>。</p>
<p>非构造主义者可以把它看作是一种简单的编码技巧。对于每个命题 <code>p</code>，我们关联一个类型，如果 <code>p</code> 为假，则该类型为空，如果 <code>p</code> 为真，则有且只有一个元素，比如 <code>*</code>。在后一种情况中，让我们说(与之相关的类型)<code>p</code> 被<em>占据</em>（inhabited）。恰好，函数应用和抽象的规则可以方便地帮助我们跟踪 <code>Prop</code> 的哪些元素是被占据的。所以构造一个元素 <code>t : p</code> 告诉我们 <code>p</code> 确实是正确的。你可以把 <code>p</code> 的占据者想象成「<code>p</code> 为真」的事实。对 <code>p → q</code> 的证明使用「<code>p</code> 是真的」这个事实来得到「<code>q</code> 是真的」这个事实。</p>
<p>事实上，如果 <code>p : Prop</code> 是任何命题，那么 Lean 的内核将任意两个元素 <code>t1 t2 : p</code> 看作定义相等，就像它把 <code>(fun x =&gt; t) s</code> 和 <code>t[s/x]</code> 看作定义等价。这就是所谓的「证明无关性」（proof irrelevance）。这意味着，即使我们可以把证明 <code>t : p</code> 当作依值类型论语言中的普通对象，它们除了 <code>p</code> 是真的这一事实之外，没有其他信息。</p>
<p>我们所建议的思考「命题即类型」范式的两种方式在一个根本性的方面有所不同。从构造的角度看，证明是抽象的数学对象，它被依值类型论中的合适表达式所<em>表示</em>。相反，如果我们从上述编码技巧的角度考虑，那么表达式本身并不表示任何有趣的东西。相反，是我们可以写下它们并检查它们是否有良好的类型这一事实确保了有关命题是真的。换句话说，表达式<em>本身</em>就是证明。</p>
<p>在下面的论述中，我们将在这两种说话方式之间来回切换，有时说一个表达式「构造」或「产生」或「返回」一个命题的证明，有时则简单地说它「是」这样一个证明。这类似于计算机科学家偶尔会模糊语法和语义之间的区别，有时说一个程序「计算」某个函数，有时又说该程序「是」该函数。</p>
<p>为了用依值类型论的语言正式表达一个数学断言，我们需要展示一个项 <code>p : Prop</code>。为了<em>证明</em>该断言，我们需要展示一个项 <code>t : p</code>。Lean 的任务，作为一个证明助手，是帮助我们构造这样一个项 <code>t</code>，并验证它的格式是否良好，类型是否正确。</p>
<!--
Working with Propositions as Types
----------------------------------
-->
<h2 id="以命题即类型的方式工作"><a class="header" href="#以命题即类型的方式工作">以「命题即类型」的方式工作</a></h2>
<!--
In the propositions-as-types paradigm, theorems involving only ``→``
can be proved using lambda abstraction and application. In Lean, the
``theorem`` command introduces a new theorem:
-->
<p>在「命题即类型」范式中，只涉及 <code>→</code> 的定理可以通过 lambda 抽象和应用来证明。在 Lean 中，<code>theorem</code> 命令引入了一个新的定理：</p>
<pre><code class="language-lean">variable {p : Prop}
variable {q : Prop}

theorem t1 : p → q → p := fun hp : p =&gt; fun hq : q =&gt; hp
</code></pre>
<!--
Compare this proof to the expression ``fun x : α => fun y : β => x``
of type ``α → β → α``, where ``α`` and ``β`` are data types.
This describes the function that takes arguments ``x`` and ``y``
of type ``α`` and ``β``, respectively, and returns ``x``.
The proof of ``t1`` has the same form, the only difference being that
``p`` and ``q`` are elements of ``Prop`` rather than ``Type``.
Intuitively, our proof of
``p → q → p`` assumes ``p`` and ``q`` are true, and uses the first
hypothesis (trivially) to establish that the conclusion, ``p``, is
true.

Note that the ``theorem`` command is really a version of the
``def`` command: under the propositions and types
correspondence, proving the theorem ``p → q → p`` is really the same
as defining an element of the associated type. To the kernel type
checker, there is no difference between the two.

There are a few pragmatic differences between definitions and
theorems, however. In normal circumstances, it is never necessary to
unfold the "definition" of a theorem; by proof irrelevance, any two
proofs of that theorem are definitionally equal. Once the proof of a
theorem is complete, typically we only need to know that the proof
exists; it doesn't matter what the proof is. In light of that fact,
Lean tags proofs as *irreducible*, which serves as a hint to the
parser (more precisely, the *elaborator*) that there is generally no
need to unfold it when processing a file. In fact, Lean is generally
able to process and check proofs in parallel, since assessing the
correctness of one proof does not require knowing the details of
another.

As with definitions, the ``#print`` command will show you the proof of
a theorem.
-->
<p>这与上一章中常量函数的定义完全相同，唯一的区别是参数是 <code>Prop</code> 的元素，而不是 <code>Type</code> 的元素。直观地说，我们对 <code>p → q → p</code> 的证明假设 <code>p</code> 和 <code>q</code> 为真，并使用第一个假设(平凡地)建立结论 <code>p</code> 为真。</p>
<p>请注意，<code>theorem</code> 命令实际上是 <code>def</code> 命令的一个翻版：在命题和类型对应下，证明定理 <code>p → q → p</code> 实际上与定义关联类型的元素是一样的。对于内核类型检查器，这两者之间没有区别。</p>
<p>然而，定义和定理之间有一些实用的区别。正常情况下，永远没有必要展开一个定理的「定义」；通过证明无关性，该定理的任何两个证明在定义上都是相等的。一旦一个定理的证明完成，通常我们只需要知道该证明的存在；证明是什么并不重要。鉴于这一事实，Lean 将证明标记为<em>不可还原</em>（irreducible），作为对解析器（更确切地说，是 <strong>繁饰器</strong> ）的提示，在处理文件时一般不需要展开它。事实上，Lean 通常能够并行地处理和检查证明，因为评估一个证明的正确性不需要知道另一个证明的细节。</p>
<p>和定义一样，<code>#print</code> 命令可以展示一个定理的证明。</p>
<pre><code class="language-lean"><span class="boring">variable {p : Prop}
</span><span class="boring">variable {q : Prop}
</span>theorem t1 : p → q → p := fun hp : p =&gt; fun hq : q =&gt; hp

#print t1
</code></pre>
<!--
Notice that the lambda abstractions ``hp : p`` and ``hq : q`` can be
viewed as temporary assumptions in the proof of ``t1``.  Lean also
allows us to specify the type of the final term ``hp``, explicitly,
with a ``show`` statement.
-->
<p>注意，lambda抽象 <code>hp : p</code> 和 <code>hq : q</code> 可以被视为 <code>t1</code> 的证明中的临时假设。Lean 还允许我们通过 <code>show</code> 语句明确指定最后一个项 <code>hp</code> 的类型。</p>
<pre><code class="language-lean"><span class="boring">variable {p : Prop}
</span><span class="boring">variable {q : Prop}
</span>theorem t1 : p → q → p :=
  fun hp : p =&gt;
  fun hq : q =&gt;
  show p from hp
</code></pre>
<!--
Adding such extra information can improve the clarity of a proof and
help detect errors when writing a proof. The ``show`` command does
nothing more than annotate the type, and, internally, all the
presentations of ``t1`` that we have seen produce the same term.

As with ordinary definitions, we can move the lambda-abstracted
variables to the left of the colon:
-->
<p>添加这些额外的信息可以提高证明的清晰度，并有助于在编写证明时发现错误。<code>show</code> 命令只是注释类型，而且在内部，我们看到的所有关于 <code>t1</code> 的表示都产生了相同的项。</p>
<p>与普通定义一样，我们可以将 lambda 抽象的变量移到冒号的左边：</p>
<pre><code class="language-lean"><span class="boring">variable {p : Prop}
</span><span class="boring">variable {q : Prop}
</span>theorem t1 (hp : p) (hq : q) : p := hp

#print t1    -- p → q → p
</code></pre>
<!--
Now we can apply the theorem ``t1`` just as a function application.
-->
<p>现在我们可以把定理 <code>t1</code> 作为一个函数应用。</p>
<pre><code class="language-lean"><span class="boring">variable {p : Prop}
</span><span class="boring">variable {q : Prop}
</span>theorem t1 (hp : p) (hq : q) : p := hp

axiom hp : p

theorem t2 : q → p := t1 hp
</code></pre>
<!--
Here, the ``axiom`` declaration postulates the existence of an
element of the given type and may compromise logical consistency. For
example, we can use it to postulate the empty type `False` has an
element.
-->
<p>这里，<code>axiom</code> 声明假定存在给定类型的元素，因此可能会破坏逻辑一致性。例如，我们可以使用它来假设空类型 <code>False</code> 有一个元素：</p>
<!--
```lean
axiom unsound : False
-- Everything follows from false
theorem ex : 1 = 0 :=
  False.elim unsound
```
-->
<pre><code class="language-lean">axiom unsound : False
-- false可导出一切
theorem ex : 1 = 0 :=
False.elim unsound
</code></pre>
<!--
Declaring an "axiom" ``hp : p`` is tantamount to declaring that ``p``
is true, as witnessed by ``hp``. Applying the theorem
``t1 : p → q → p`` to the fact ``hp : p`` that ``p`` is true yields the theorem
``t1 hp : q → p``.

Recall that we can also write theorem ``t1`` as follows:
-->
<p>声明「公理」<code>hp : p</code> 等同于声明 <code>p</code> 为真，正如 <code>hp</code> 所证明的那样。应用定理 <code>t1 : p → q → p</code> 到事实 <code>hp : p</code>（也就是 <code>p</code> 为真）得到定理 <code>t1 hp : q → p</code>。</p>
<p>回想一下，我们也可以这样写定理 <code>t1</code>:</p>
<pre><code class="language-lean">theorem t1 {p q : Prop} (hp : p) (hq : q) : p := hp

#print t1
</code></pre>
<!--
The type of ``t1`` is now ``∀ {p q : Prop}, p → q → p``. We can read
this as the assertion "for every pair of propositions ``p q``, we have
``p → q → p``." For example, we can move all parameters to the right
of the colon:
-->
<p><code>t1</code> 的类型现在是 <code>∀ {p q : Prop}, p → q → p</code>。我们可以把它理解为「对于每一对命题 <code>p q</code>，我们都有 <code>p → q → p</code>」。例如，我们可以将所有参数移到冒号的右边：</p>
<pre><code class="language-lean">theorem t1 : ∀ {p q : Prop}, p → q → p :=
  fun {p q : Prop} (hp : p) (hq : q) =&gt; hp
</code></pre>
<!--
If ``p`` and ``q`` have been declared as variables, Lean will
generalize them for us automatically:
-->
<p>如果 <code>p</code> 和 <code>q</code> 被声明为变量，Lean 会自动为我们推广它们：</p>
<pre><code class="language-lean">variable {p q : Prop}

theorem t1 : p → q → p := fun (hp : p) (hq : q) =&gt; hp
</code></pre>
<!--
In fact, by the propositions-as-types correspondence, we can declare
the assumption ``hp`` that ``p`` holds, as another variable:
-->
<p>事实上，通过命题即类型的对应关系，我们可以声明假设 <code>hp</code> 为 <code>p</code>，作为另一个变量:</p>
<pre><code class="language-lean">variable {p q : Prop}
variable (hp : p)

theorem t1 : q → p := fun (hq : q) =&gt; hp
</code></pre>
<!--
Lean detects that the proof uses ``hp`` and automatically adds
``hp : p`` as a premise. In all cases, the command ``#print t1`` still yields
``∀ p q : Prop, p → q → p``. Remember that this type can just as well
be written ``∀ (p q : Prop) (hp : p) (hq : q), p``, since the arrow
denotes nothing more than an arrow type in which the target does not
depend on the bound variable.

When we generalize ``t1`` in such a way, we can then apply it to
different pairs of propositions, to obtain different instances of the
general theorem.
-->
<p>Lean 检测到证明使用 <code>hp</code>，并自动添加 <code>hp : p</code> 作为前提。在所有情况下，命令 <code>#print t1</code> 仍然会产生 <code>∀ p q : Prop, p → q → p</code>。这个类型也可以写成 <code>∀ (p q : Prop) (hp : p) (hq :q), p</code>，因为箭头仅仅表示一个箭头类型，其中目标不依赖于约束变量。</p>
<p>当我们以这种方式推广 <code>t1</code> 时，我们就可以将它应用于不同的命题对，从而得到一般定理的不同实例。</p>
<pre><code class="language-lean">theorem t1 (p q : Prop) (hp : p) (hq : q) : p := hp

variable (p q r s : Prop)

#check t1 p q                -- p → q → p
#check t1 r s                -- r → s → r
#check t1 (r → s) (s → r)    -- (r → s) → (s → r) → r → s

variable (h : r → s)
#check t1 (r → s) (s → r) h  -- (s → r) → r → s
</code></pre>
<!--
Once again, using the propositions-as-types correspondence, the
variable ``h`` of type ``r → s`` can be viewed as the hypothesis, or
premise, that ``r → s`` holds.

As another example, let us consider the composition function discussed
in the last chapter, now with propositions instead of types.
-->
<p>同样，使用命题即类型对应，类型为 <code>r → s</code> 的变量 <code>h</code> 可以看作是 <code>r → s</code> 存在的假设或前提。</p>
<p>作为另一个例子，让我们考虑上一章讨论的组合函数，现在用命题代替类型。</p>
<pre><code class="language-lean">variable (p q r s : Prop)

theorem t2 (h₁ : q → r) (h₂ : p → q) : p → r :=
  fun h₃ : p =&gt;
  show r from h₁ (h₂ h₃)
</code></pre>
<!--
As a theorem of propositional logic, what does ``t2`` say?

Note that it is often useful to use numeric unicode subscripts,
entered as ``\0``, ``\1``, ``\2``, ..., for hypotheses, as we did in
this example.
-->
<p>作为一个命题逻辑定理，<code>t2</code> 是什么意思？</p>
<p>注意，数字 unicode 下标输入方式为 <code>\0</code>，<code>\1</code>，<code>\2</code>，...。</p>
<!--
Propositional Logic
-------------------
-->
<h2 id="命题逻辑"><a class="header" href="#命题逻辑">命题逻辑</a></h2>
<!--
Lean defines all the standard logical connectives and notation. The propositional connectives come with the following notation:

| Ascii             | Unicode   | Editor shortcut              | Definition   |
|-------------------|-----------|------------------------------|--------------|
| True              |           |                              | True         |
| False             |           |                              | False        |
| Not               | ¬         | ``\not``, ``\neg``           | Not          |
| /\\               | ∧         | ``\and``                     | And          |
| \\/               | ∨         | ``\or``                      | Or           |
| ->                | →         | ``\to``, ``\r``, ``\imp``    |              |
| <->               | ↔         | ``\iff``, ``\lr``            | Iff          |

They all take values in ``Prop``.
-->
<p>Lean 定义了所有标准的逻辑连接词和符号。命题连接词有以下表示法:</p>
<table><thead><tr><th>Ascii</th><th>Unicode</th><th>编辑器缩写</th><th>定义</th></tr></thead><tbody>
<tr><td>True</td><td></td><td></td><td>True</td></tr>
<tr><td>False</td><td></td><td></td><td>False</td></tr>
<tr><td>Not</td><td>¬</td><td><code>\not</code>, <code>\neg</code></td><td>Not</td></tr>
<tr><td>/\</td><td>∧</td><td><code>\and</code></td><td>And</td></tr>
<tr><td>\/</td><td>∨</td><td><code>\or</code></td><td>Or</td></tr>
<tr><td>-&gt;</td><td>→</td><td><code>\to</code>, <code>\r</code>, <code>\imp</code></td><td></td></tr>
<tr><td>&lt;-&gt;</td><td>↔</td><td><code>\iff</code>, <code>\lr</code></td><td>Iff</td></tr>
</tbody></table>
<p>它们都接收 <code>Prop</code> 值。</p>
<pre><code class="language-lean">variable (p q : Prop)

#check p → q → p ∧ q
#check ¬p → p ↔ False
#check p ∨ q → q ∨ p
</code></pre>
<!--
The order of operations is as follows: unary negation ``¬`` binds most
strongly, then ``∧``, then ``∨``, then ``→``, and finally ``↔``. For
example, ``a ∧ b → c ∨ d ∧ e`` means ``(a ∧ b) → (c ∨ (d ∧
e))``. Remember that ``→`` associates to the right (nothing changes
now that the arguments are elements of ``Prop``, instead of some other
``Type``), as do the other binary connectives. So if we have
``p q r : Prop``, the expression ``p → q → r`` reads "if ``p``, then if ``q``,
then ``r``." This is just the "curried" form of ``p ∧ q → r``.

In the last chapter we observed that lambda abstraction can be viewed
as an "introduction rule" for ``→``. In the current setting, it shows
how to "introduce" or establish an implication. Application can be
viewed as an "elimination rule," showing how to "eliminate" or use an
implication in a proof. The other propositional connectives are
defined in Lean's library in the file ``Prelude.core`` (see
[importing files](./interacting_with_lean.md#importing-files) for more information on the library
hierarchy), and each connective comes with its canonical introduction
and elimination rules.
-->
<p>操作符的优先级如下：<code>¬ &gt; ∧ &gt; ∨ &gt; → &gt; ↔</code>。举例：<code>a ∧ b → c ∨ d ∧ e</code> 意为 <code>(a ∧ b) → (c ∨ (d ∧ e))</code>。<code>→</code> 等二元关系是右结合的。所以如果我们有 <code>p q r : Prop</code>，表达式 <code>p → q → r</code> 读作「如果 <code>p</code>，那么如果 <code>q</code>，那么 <code>r</code>」。这是 <code>p ∧ q → r</code> 的柯里化形式。</p>
<p>在上一章中，我们观察到 lambda 抽象可以被看作是 <code>→</code> 的「引入规则」，展示了如何「引入」或建立一个蕴含。应用可以看作是一个「消去规则」，展示了如何在证明中「消去」或使用一个蕴含。其他的命题连接词在 Lean 的库 <code>Prelude.core</code> 文件中定义。(参见<a href="./interacting_with_lean.html#_importing_files">导入文件</a>以获得关于库层次结构的更多信息)，并且每个连接都带有其规范引入和消去规则。</p>
<!--
### Conjunction
-->
<h3 id="合取"><a class="header" href="#合取">合取</a></h3>
<!--
The expression ``And.intro h1 h2`` builds a proof of ``p ∧ q`` using
proofs ``h1 : p`` and ``h2 : q``. It is common to describe
``And.intro`` as the *and-introduction* rule. In the next example we
use ``And.intro`` to create a proof of ``p → q → p ∧ q``.
-->
<p>表达式 <code>And.intro h1 h2</code> 是 <code>p ∧ q</code> 的证明，它使用了 <code>h1 : p</code> 和 <code>h2 : q</code> 的证明。通常把 <code>And.intro</code> 称为<em>合取引入</em>规则。下面的例子我们使用 <code>And.intro</code> 来创建 <code>p → q → p ∧ q</code> 的证明。</p>
<pre><code class="language-lean">variable (p q : Prop)

example (hp : p) (hq : q) : p ∧ q := And.intro hp hq

#check fun (hp : p) (hq : q) =&gt; And.intro hp hq
</code></pre>
<!--
The ``example`` command states a theorem without naming it or storing
it in the permanent context. Essentially, it just checks that the
given term has the indicated type. It is convenient for illustration,
and we will use it often.

The expression ``And.left h`` creates a proof of ``p`` from a proof
``h : p ∧ q``. Similarly, ``And.right h`` is a proof of ``q``. They
are commonly known as the left and right *and-elimination* rules.
-->
<p><code>example</code> 命令声明了一个没有名字也不会永久保存的定理。本质上，它只是检查给定项是否具有指定的类型。它便于说明，我们将经常使用它。</p>
<p>表达式 <code>And.left h</code> 从 <code>h : p ∧ q</code> 建立了一个 <code>p</code> 的证明。类似地，<code>And.right h</code> 是 <code>q</code> 的证明。它们常被称为左或右<em>合取消去</em>规则。</p>
<pre><code class="language-lean">variable (p q : Prop)

example (h : p ∧ q) : p := And.left h
example (h : p ∧ q) : q := And.right h
</code></pre>
<!--
We can now prove ``p ∧ q → q ∧ p`` with the following proof term.
-->
<p>我们现在可以证明 <code>p ∧ q → q ∧ p</code>：</p>
<pre><code class="language-lean">variable (p q : Prop)

example (h : p ∧ q) : q ∧ p :=
  And.intro (And.right h) (And.left h)
</code></pre>
<!--
Notice that and-introduction and and-elimination are similar to the
pairing and projection operations for the Cartesian product. The
difference is that given ``hp : p`` and ``hq : q``, ``And.intro hp
hq`` has type ``p ∧ q : Prop``, while ``Prod hp hq`` has type
``p × q : Type``. The similarity between ``∧`` and ``×`` is another instance
of the Curry-Howard isomorphism, but in contrast to implication and
the function space constructor, ``∧`` and ``×`` are treated separately
in Lean. With the analogy, however, the proof we have just constructed
is similar to a function that swaps the elements of a pair.

We will see in [Chapter Structures and Records](./structures_and_records.md) that certain
types in Lean are *structures*, which is to say, the type is defined
with a single canonical *constructor* which builds an element of the
type from a sequence of suitable arguments. For every ``p q : Prop``,
``p ∧ q`` is an example: the canonical way to construct an element is
to apply ``And.intro`` to suitable arguments ``hp : p`` and
``hq : q``. Lean allows us to use *anonymous constructor* notation
``⟨arg1, arg2, ...⟩`` in situations like these, when the relevant type is an
inductive type and can be inferred from the context. In particular, we
can often write ``⟨hp, hq⟩`` instead of ``And.intro hp hq``:
-->
<p>请注意，引入和消去与笛卡尔积的配对和投影操作类似。区别在于，给定 <code>hp : p</code> 和 <code>hq : q</code>，<code>And.intro hp hq</code> 具有类型 <code>p ∧ q : Prop</code>，而 <code>Prod hp hq</code> 具有类型 <code>p × q : Type</code>。<code>∧</code> 和 <code>×</code> 之间的相似性是Curry-Howard同构的另一个例子，但与蕴涵和函数空间构造子不同，在 Lean 中 <code>∧</code> 和 <code>×</code> 是分开处理的。然而，通过类比，我们刚刚构造的证明类似于交换一对中的元素的函数。</p>
<p>我们将在<a href="./structures_and_records.html">结构体和记录</a>一章中看到 Lean 中的某些类型是<em>Structures</em>，也就是说，该类型是用单个规范的<em>构造子</em>定义的，该构造子从一系列合适的参数构建该类型的一个元素。对于每一组 <code>p q : Prop</code>， <code>p ∧ q</code> 就是一个例子:构造一个元素的规范方法是将 <code>And.intro</code> 应用于合适的参数 <code>hp : p</code> 和 <code>hq : q</code>。Lean 允许我们使用<em>匿名构造子</em>表示法 <code>⟨arg1, arg2, ...⟩</code> 在此类情况下，当相关类型是归纳类型并可以从上下文推断时。特别地，我们经常可以写入 <code>⟨hp, hq⟩</code>，而不是 <code>And.intro hp hq</code>:</p>
<pre><code class="language-lean">variable (p q : Prop)
variable (hp : p) (hq : q)

#check (⟨hp, hq⟩ : p ∧ q)
</code></pre>
<!--
These angle brackets are obtained by typing ``\<`` and ``\>``, respectively.

Lean provides another useful syntactic gadget. Given an expression
``e`` of an inductive type ``Foo`` (possibly applied to some
arguments), the notation ``e.bar`` is shorthand for ``Foo.bar e``.
This provides a convenient way of accessing functions without opening
a namespace.  For example, the following two expressions mean the same
thing:
-->
<p>尖括号可以用 <code>\&lt;</code> 和 <code>\&gt;</code> 打出来。</p>
<p>Lean 提供了另一个有用的语法小工具。给定一个归纳类型 <code>Foo</code> 的表达式 <code>e</code>(可能应用于一些参数)，符号 <code>e.bar</code> 是 <code>Foo.bar e</code> 的缩写。这为访问函数提供了一种方便的方式，而无需打开名称空间。例如，下面两个表达的意思是相同的：</p>
<pre><code class="language-lean">variable (xs : List Nat)

#check List.length xs
#check xs.length
</code></pre>
<!--
As a result, given ``h : p ∧ q``, we can write ``h.left`` for
``And.left h`` and ``h.right`` for ``And.right h``. We can therefore
rewrite the sample proof above conveniently as follows:
-->
<p>给定 <code>h : p ∧ q</code>，我们可以写 <code>h.left</code> 来表示 <code>And.left h</code> 以及 <code>h.right</code> 来表示 <code>And.right h</code>。因此我们可以简写上面的证明如下：</p>
<pre><code class="language-lean">variable (p q : Prop)

example (h : p ∧ q) : q ∧ p :=
  ⟨h.right, h.left⟩
</code></pre>
<!--
There is a fine line between brevity and obfuscation, and omitting
information in this way can sometimes make a proof harder to read. But
for straightforward constructions like the one above, when the type of
``h`` and the goal of the construction are salient, the notation is
clean and effective.

It is common to iterate constructions like "And." Lean also allows you
to flatten nested constructors that associate to the right, so that
these two proofs are equivalent:
-->
<p>在简洁和含混不清之间有一条微妙的界限，以这种方式省略信息有时会使证明更难阅读。但对于像上面这样简单的结构，当 <code>h</code> 的类型和结构的目标很突出时，符号是干净和有效的。</p>
<p>像 <code>And.</code> 这样的迭代结构是很常见的。Lean 还允许你将嵌套的构造函数向右结合，这样这两个证明是等价的:</p>
<pre><code class="language-lean">variable (p q : Prop)

example (h : p ∧ q) : q ∧ p ∧ q :=
  ⟨h.right, ⟨h.left, h.right⟩⟩

example (h : p ∧ q) : q ∧ p ∧ q :=
  ⟨h.right, h.left, h.right⟩
</code></pre>
<!--
This is often useful as well.
-->
<p>这一点也很常用。</p>
<!--
### Disjunction
-->
<h3 id="析取"><a class="header" href="#析取">析取</a></h3>
<!--
The expression ``Or.intro_left q hp`` creates a proof of ``p ∨ q``
from a proof ``hp : p``. Similarly, ``Or.intro_right p hq`` creates a
proof for ``p ∨ q`` using a proof ``hq : q``. These are the left and
right *or-introduction* rules.
-->
<p>表达式 <code>Or.intro_left q hp</code> 从证明 <code>hp : p</code> 建立了 <code>p ∨ q</code> 的证明。类似地，<code>Or.intro_right p hq</code> 从证明 <code>hq : q</code> 建立了 <code>p ∨ q</code> 的证明。这是左右析取（「或」）引入规则。</p>
<pre><code class="language-lean">variable (p q : Prop)
example (hp : p) : p ∨ q := Or.intro_left q hp
example (hq : q) : p ∨ q := Or.intro_right p hq
</code></pre>
<!--
The *or-elimination* rule is slightly more complicated. The idea is
that we can prove ``r`` from ``p ∨ q``, by showing that ``r`` follows
from ``p`` and that ``r`` follows from ``q``.  In other words, it is a
proof by cases. In the expression ``Or.elim hpq hpr hqr``, ``Or.elim``
takes three arguments, ``hpq : p ∨ q``, ``hpr : p → r`` and
``hqr : q → r``, and produces a proof of ``r``. In the following example, we use
``Or.elim`` to prove ``p ∨ q → q ∨ p``.
-->
<p>析取消去规则稍微复杂一点。这个想法是，如果我们想要从 <code>p ∨ q</code> 证明 <code>r</code>，只需要展示 <code>p</code> 可以证明 <code>r</code>，且 <code>q</code> 也可以证明 <code>r</code>。换句话说，它是一种逐情况证明。在表达式 <code>Or.elim hpq hpr hqr</code> 中，<code>Or.elim</code> 接受三个论证，<code>hpq : p ∨ q</code>，<code>hpr : p → r</code> 和 <code>hqr : q → r</code>，生成 <code>r</code> 的证明。在下面的例子中，我们使用 <code>Or.elim</code> 证明 <code>p ∨ q → q ∨ p</code>。</p>
<pre><code class="language-lean">variable (p q r : Prop)

example (h : p ∨ q) : q ∨ p :=
  Or.elim h
    (fun hp : p =&gt;
      show q ∨ p from Or.intro_right q hp)
    (fun hq : q =&gt;
      show q ∨ p from Or.intro_left p hq)
</code></pre>
<!--
In most cases, the first argument of ``Or.intro_right`` and
``Or.intro_left`` can be inferred automatically by Lean. Lean
therefore provides ``Or.inr`` and ``Or.inl`` which can be viewed as
shorthand for ``Or.intro_right _`` and ``Or.intro_left _``. Thus the
proof term above could be written more concisely:
-->
<p>在大多数情况下，<code>Or.intro_right</code> 和 <code>Or.intro_left</code> 的第一个参数可以由 Lean 自动推断出来。因此，Lean 提供了 <code>Or.inr</code> 和 <code>Or.inl</code> 作为 <code>Or.intro_right _</code> 和 <code>Or.intro_left _</code> 的缩写。因此，上面的证明项可以写得更简洁:</p>
<pre><code class="language-lean">variable (p q r : Prop)

example (h : p ∨ q) : q ∨ p :=
  Or.elim h (fun hp =&gt; Or.inr hp) (fun hq =&gt; Or.inl hq)
</code></pre>
<!--
Notice that there is enough information in the full expression for
Lean to infer the types of ``hp`` and ``hq`` as well.  But using the
type annotations in the longer version makes the proof more readable,
and can help catch and debug errors.

Because ``Or`` has two constructors, we cannot use anonymous
constructor notation. But we can still write ``h.elim`` instead of
``Or.elim h``:
-->
<p>Lean 的完整表达式中有足够的信息来推断 <code>hp</code> 和 <code>hq</code> 的类型。但是在较长的版本中使用类型注释可以使证明更具可读性，并有助于捕获和调试错误。</p>
<p>因为 <code>Or</code> 有两个构造子，所以不能使用匿名构造子表示法。但我们仍然可以写 <code>h.elim</code> 而不是 <code>Or.elim h</code>，不过你需要注意这些缩写是增强还是降低了可读性：</p>
<pre><code class="language-lean">variable (p q r : Prop)

example (h : p ∨ q) : q ∨ p :=
  h.elim (fun hp =&gt; Or.inr hp) (fun hq =&gt; Or.inl hq)
</code></pre>
<!--
Once again, you should exercise judgment as to whether such
abbreviations enhance or diminish readability.
-->
<!--
### Negation and Falsity
-->
<h3 id="否定和假言"><a class="header" href="#否定和假言">否定和假言</a></h3>
<!--
Negation, ``¬p``, is actually defined to be ``p → False``, so we
obtain ``¬p`` by deriving a contradiction from ``p``. Similarly, the
expression ``hnp hp`` produces a proof of ``False`` from ``hp : p``
and ``hnp : ¬p``. The next example uses both these rules to produce a
proof of ``(p → q) → ¬q → ¬p``. (The symbol ``¬`` is produced by
typing ``\not`` or ``\neg``.)
-->
<p>否定 <code>¬p</code> 真正的定义是 <code>p → False</code>，所以我们通过从 <code>p</code> 导出一个矛盾来获得 <code>¬p</code>。类似地，表达式 <code>hnp hp</code> 从 <code>hp : p</code> 和 <code>hnp : ¬p</code> 产生一个 <code>False</code> 的证明。下一个例子用所有这些规则来证明 <code>(p → q) → ¬q → ¬p</code>。（<code>¬</code> 符号可以由 <code>\not</code> 或者 <code>\neg</code> 来写出。）</p>
<pre><code class="language-lean">variable (p q : Prop)

example (hpq : p → q) (hnq : ¬q) : ¬p :=
  fun hp : p =&gt;
  show False from hnq (hpq hp)
</code></pre>
<!--
The connective ``False`` has a single elimination rule,
``False.elim``, which expresses the fact that anything follows from a
contradiction. This rule is sometimes called *ex falso* (short for *ex
falso sequitur quodlibet*), or the *principle of explosion*.
-->
<p>连接词 <code>False</code> 只有一个消去规则 <code>False.elim</code>，它表达了一个事实，即矛盾能导出一切。这个规则有时被称为<em>ex falso</em> 【<em>ex falso sequitur quodlibet</em>（无稽之谈）的缩写】，或<em>爆炸原理</em>。</p>
<pre><code class="language-lean">variable (p q : Prop)

example (hp : p) (hnp : ¬p) : q := False.elim (hnp hp)
</code></pre>
<!--
The arbitrary fact, ``q``, that follows from falsity is an implicit
argument in ``False.elim`` and is inferred automatically. This
pattern, deriving an arbitrary fact from contradictory hypotheses, is
quite common, and is represented by ``absurd``.
-->
<p>假命题导出任意的事实 <code>q</code>，是 <code>False.elim</code> 的一个隐参数，而且是自动推断出来的。这种从相互矛盾的假设中推导出任意事实的模式很常见，用 <code>absurd</code> 来表示。</p>
<pre><code class="language-lean">variable (p q : Prop)

example (hp : p) (hnp : ¬p) : q := absurd hp hnp
</code></pre>
<!--
Here, for example, is a proof of ``¬p → q → (q → p) → r``:
-->
<p>证明 <code>¬p → q → (q → p) → r</code>：</p>
<pre><code class="language-lean">variable (p q r : Prop)

example (hnp : ¬p) (hq : q) (hqp : q → p) : r :=
  absurd (hqp hq) hnp
</code></pre>
<!--
Incidentally, just as ``False`` has only an elimination rule, ``True``
has only an introduction rule, ``True.intro : true``.  In other words,
``True`` is simply true, and has a canonical proof, ``True.intro``.
-->
<p>顺便说一句，就像 <code>False</code> 只有一个消去规则，<code>True</code> 只有一个引入规则 <code>True.intro : true</code>。换句话说，<code>True</code> 就是真，并且有一个标准证明 <code>True.intro</code>。</p>
<!--
### Logical Equivalence
-->
<h3 id="逻辑等价"><a class="header" href="#逻辑等价">逻辑等价</a></h3>
<!--
The expression ``Iff.intro h1 h2`` produces a proof of ``p ↔ q`` from
``h1 : p → q`` and ``h2 : q → p``.  The expression ``Iff.mp h``
produces a proof of ``p → q`` from ``h : p ↔ q``. Similarly,
``Iff.mpr h`` produces a proof of ``q → p`` from ``h : p ↔ q``. Here is a proof
of ``p ∧ q ↔ q ∧ p``:
-->
<p>表达式 <code>Iff.intro h1 h2</code> 从 <code>h1 : p → q</code> 和 <code>h2 : q → p</code> 生成了 <code>p ↔ q</code> 的证明。表达式 <code>Iff.mp h</code> 从 <code>h : p ↔ q</code> 生成了 <code>p → q</code> 的证明。表达式 <code>Iff.mpr h</code> 从 <code>h : p ↔ q</code> 生成了 <code>q → p</code> 的证明。下面是 <code>p ∧ q ↔ q ∧ p</code> 的证明：</p>
<pre><code class="language-lean">variable (p q : Prop)

theorem and_swap : p ∧ q ↔ q ∧ p :=
  Iff.intro
    (fun h : p ∧ q =&gt;
     show q ∧ p from And.intro (And.right h) (And.left h))
    (fun h : q ∧ p =&gt;
     show p ∧ q from And.intro (And.right h) (And.left h))

#check and_swap p q    -- p ∧ q ↔ q ∧ p

variable (h : p ∧ q)
example : q ∧ p := Iff.mp (and_swap p q) h
</code></pre>
<!--
We can use the anonymous constructor notation to construct a proof of
``p ↔ q`` from proofs of the forward and backward directions, and we
can also use ``.`` notation with ``mp`` and ``mpr``. The previous
examples can therefore be written concisely as follows:
-->
<p>我们可以用匿名构造子表示法来，从正反两个方向的证明，来构建 <code>p ↔ q</code> 的证明。我们也可以使用 <code>.</code> 符号连接 <code>mp</code> 和 <code>mpr</code>。因此，前面的例子可以简写如下：</p>
<pre><code class="language-lean">variable (p q : Prop)

theorem and_swap : p ∧ q ↔ q ∧ p :=
  ⟨ fun h =&gt; ⟨h.right, h.left⟩, fun h =&gt; ⟨h.right, h.left⟩ ⟩

example (h : p ∧ q) : q ∧ p := (and_swap p q).mp h
</code></pre>
<!--
Introducing Auxiliary Subgoals
--------
-->
<h2 id="引入辅助子目标"><a class="header" href="#引入辅助子目标">引入辅助子目标</a></h2>
<!--
This is a good place to introduce another device Lean offers to help
structure long proofs, namely, the ``have`` construct, which
introduces an auxiliary subgoal in a proof. Here is a small example,
adapted from the last section:
-->
<p>这里介绍 Lean 提供的另一种帮助构造长证明的方法，即 <code>have</code> 结构，它在证明中引入了一个辅助的子目标。下面是一个小例子，改编自上一节:</p>
<pre><code class="language-lean">variable (p q : Prop)

example (h : p ∧ q) : q ∧ p :=
  have hp : p := h.left
  have hq : q := h.right
  show q ∧ p from And.intro hq hp
</code></pre>
<!--
Internally, the expression ``have h : p := s; t`` produces the term
``(fun (h : p) => t) s``. In other words, ``s`` is a proof of ``p``,
``t`` is a proof of the desired conclusion assuming ``h : p``, and the
two are combined by a lambda abstraction and application. This simple
device is extremely useful when it comes to structuring long proofs,
since we can use intermediate ``have``'s as stepping stones leading to
the final goal.

Lean also supports a structured way of reasoning backwards from a
goal, which models the "suffices to show" construction in ordinary
mathematics. The next example simply permutes the last two lines in
the previous proof.
-->
<p>在内部，表达式 <code>have h : p := s; t</code> 产生项 <code>(fun (h : p) =&gt; t) s</code>。换句话说，<code>s</code> 是 <code>p</code> 的证明，<code>t</code> 是假设 <code>h : p</code> 的期望结论的证明，并且这两个是由 lambda 抽象和应用组合在一起的。这个简单的方法在构建长证明时非常有用，因为我们可以使用中间的 <code>have</code> 作为通向最终目标的垫脚石。</p>
<p>Lean 还支持从目标向后推理的结构化方法，它模仿了普通数学文献中「足以说明某某」（suffices to show）的构造。下一个例子简单地排列了前面证明中的最后两行。</p>
<pre><code class="language-lean">variable (p q : Prop)

example (h : p ∧ q) : q ∧ p :=
  have hp : p := h.left
  suffices hq : q from And.intro hq hp
  show q from And.right h
</code></pre>
<!--
Writing ``suffices hq : q`` leaves us with two goals. First, we have
to show that it indeed suffices to show ``q``, by proving the original
goal of ``q ∧ p`` with the additional hypothesis ``hq : q``. Finally,
we have to show ``q``.
-->
<p><code>suffices hq : q</code> 给出了两条目标。第一，我们需要证明，通过利用附加假设 <code>hq : q</code> 证明原目标 <code>q ∧ p</code>，这样足以证明 <code>q</code>，第二，我们需要证明 <code>q</code>。</p>
<!--
Classical Logic
---------------
-->
<h2 id="经典逻辑"><a class="header" href="#经典逻辑">经典逻辑</a></h2>
<!--
The introduction and elimination rules we have seen so far are all
constructive, which is to say, they reflect a computational
understanding of the logical connectives based on the
propositions-as-types correspondence. Ordinary classical logic adds to
this the law of the excluded middle, ``p ∨ ¬p``. To use this
principle, you have to open the classical namespace.
-->
<p>到目前为止，我们看到的引入和消去规则都是构造主义的，也就是说，它们反映了基于命题即类型对应的逻辑连接词的计算理解。普通经典逻辑在此基础上加上了排中律 <code>p ∨ ¬p</code>（excluded middle, em）。要使用这个原则，你必须打开经典逻辑命名空间。</p>
<pre><code class="language-lean">open Classical

variable (p : Prop)
#check em p
</code></pre>
<!--
Intuitively, the constructive "Or" is very strong: asserting ``p ∨ q``
amounts to knowing which is the case. If ``RH`` represents the Riemann
hypothesis, a classical mathematician is willing to assert
``RH ∨ ¬RH``, even though we cannot yet assert either disjunct.

One consequence of the law of the excluded middle is the principle of
double-negation elimination:
-->
<p>从直觉上看，构造主义的「或」非常强：断言 <code>p ∨ q</code> 等于知道哪个是真实情况。如果 <code>RH</code> 代表黎曼猜想，经典数学家愿意断言 <code>RH ∨ ¬RH</code>，即使我们还不能断言析取式的任何一端。</p>
<p>排中律的一个结果是双重否定消去规则（double-negation elimination, dne）:</p>
<pre><code class="language-lean">open Classical

theorem dne {p : Prop} (h : ¬¬p) : p :=
  Or.elim (em p)
    (fun hp : p =&gt; hp)
    (fun hnp : ¬p =&gt; absurd hnp h)
</code></pre>
<!--
Double-negation elimination allows one to prove any proposition,
``p``, by assuming ``¬p`` and deriving ``false``, because that amounts
to proving ``¬¬p``. In other words, double-negation elimination allows
one to carry out a proof by contradiction, something which is not
generally possible in constructive logic. As an exercise, you might
try proving the converse, that is, showing that ``em`` can be proved
from ``dne``.

The classical axioms also give you access to additional patterns of
proof that can be justified by appeal to ``em``.  For example, one can
carry out a proof by cases:
-->
<p>双重否定消去规则给出了一种证明任何命题 <code>p</code> 的方法：通过假设 <code>¬p</code> 来推导出 <code>false</code>，相当于证明了 <code>p</code>。换句话说，双重否定消除允许反证法，这在构造主义逻辑中通常是不可能的。作为练习，你可以试着证明相反的情况，也就是说，证明 <code>em</code> 可以由 <code>dne</code> 证明。</p>
<p>经典公理还可以通过使用 <code>em</code> 让你获得额外的证明模式。例如，我们可以逐情况进行证明:</p>
<pre><code class="language-lean">open Classical
variable (p : Prop)

example (h : ¬¬p) : p :=
  byCases
    (fun h1 : p =&gt; h1)
    (fun h1 : ¬p =&gt; absurd h1 h)
</code></pre>
<!--
Or you can carry out a proof by contradiction:
-->
<p>或者你可以用反证法来证明：</p>
<pre><code class="language-lean">open Classical
variable (p : Prop)

example (h : ¬¬p) : p :=
  byContradiction
    (fun h1 : ¬p =&gt;
     show False from h h1)
</code></pre>
<!--
If you are not used to thinking constructively, it may take some time
for you to get a sense of where classical reasoning is used.  It is
needed in the following example because, from a constructive
standpoint, knowing that ``p`` and ``q`` are not both true does not
necessarily tell you which one is false:
-->
<p>如果你不习惯构造主义，你可能需要一些时间来了解经典推理在哪里使用。在下面的例子中，它是必要的，因为从一个构造主义的观点来看，知道 <code>p</code> 和 <code>q</code> 不同时真并不一定告诉你哪一个是假的：</p>
<pre><code class="language-lean"><span class="boring">open Classical
</span><span class="boring">variable (p q : Prop)
</span>example (h : ¬(p ∧ q)) : ¬p ∨ ¬q :=
  Or.elim (em p)
    (fun hp : p =&gt;
      Or.inr
        (show ¬q from
          fun hq : q =&gt;
          h ⟨hp, hq⟩))
    (fun hp : ¬p =&gt;
      Or.inl hp)
</code></pre>
<!--

We will see later that there *are* situations in constructive logic
where principles like excluded middle and double-negation elimination
are permissible, and Lean supports the use of classical reasoning in
such contexts without relying on excluded middle.

The full list of axioms that are used in Lean to support classical
reasoning are discussed in [Axioms and Computation](./axioms_and_computation.md).
-->
<p>稍后我们将看到，构造逻辑中 <strong>有</strong> 某些情况允许「排中律」和「双重否定消除律」等，而 Lean 支持在这种情况下使用经典推理，而不依赖于排中律。</p>
<p>Lean 中使用的公理的完整列表见<a href="./axioms_and_computation.html">公理与计算</a>。</p>
<!--
Examples of Propositional Validities
------------------------------------
-->
<p>逻辑命题的例子</p>
<!--
Lean's standard library contains proofs of many valid statements of
propositional logic, all of which you are free to use in proofs of
your own. The following list includes a number of common identities.
-->
<p>Lean 的标准库包含了许多命题逻辑的有效语句的证明，你可以自由地在自己的证明中使用这些证明。下面的列表包括一些常见的逻辑等价式。</p>
<!--
Commutativity:
-->
<p>交换律：</p>
<ol>
<li><code>p ∧ q ↔ q ∧ p</code></li>
<li><code>p ∨ q ↔ q ∨ p</code></li>
</ol>
<!--
Associativity:
-->
<p>结合律：</p>
<ol start="3">
<li><code>(p ∧ q) ∧ r ↔ p ∧ (q ∧ r)</code></li>
<li><code>(p ∨ q) ∨ r ↔ p ∨ (q ∨ r)</code></li>
</ol>
<!--
Distributivity:
-->
<p>分配律：</p>
<ol start="5">
<li><code>p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r)</code></li>
<li><code>p ∨ (q ∧ r) ↔ (p ∨ q) ∧ (p ∨ r)</code></li>
</ol>
<!--
Other properties:
-->
<p>其他性质：</p>
<ol start="7">
<li><code>(p → (q → r)) ↔ (p ∧ q → r)</code></li>
<li><code>((p ∨ q) → r) ↔ (p → r) ∧ (q → r)</code></li>
<li><code>¬(p ∨ q) ↔ ¬p ∧ ¬q</code></li>
<li><code>¬p ∨ ¬q → ¬(p ∧ q)</code></li>
<li><code>¬(p ∧ ¬p)</code></li>
<li><code>p ∧ ¬q → ¬(p → q)</code></li>
<li><code>¬p → (p → q)</code></li>
<li><code>(¬p ∨ q) → (p → q)</code></li>
<li><code>p ∨ False ↔ p</code></li>
<li><code>p ∧ False ↔ False</code></li>
<li><code>¬(p ↔ ¬p)</code></li>
<li><code>(p → q) → (¬q → ¬p)</code></li>
</ol>
<!--
These require classical reasoning:
-->
<p>经典推理：</p>
<ol start="19">
<li><code>(p → r ∨ s) → ((p → r) ∨ (p → s))</code></li>
<li><code>¬(p ∧ q) → ¬p ∨ ¬q</code></li>
<li><code>¬(p → q) → p ∧ ¬q</code></li>
<li><code>(p → q) → (¬p ∨ q)</code></li>
<li><code>(¬q → ¬p) → (p → q)</code></li>
<li><code>p ∨ ¬p</code></li>
<li><code>(((p → q) → p) → p)</code></li>
</ol>
<!--
The ``sorry`` identifier magically produces a proof of anything, or
provides an object of any data type at all. Of course, it is unsound
as a proof method -- for example, you can use it to prove ``False`` --
and Lean produces severe warnings when files use or import theorems
which depend on it. But it is very useful for building long proofs
incrementally. Start writing the proof from the top down, using
``sorry`` to fill in subproofs. Make sure Lean accepts the term with
all the ``sorry``'s; if not, there are errors that you need to
correct. Then go back and replace each ``sorry`` with an actual proof,
until no more remain.

Here is another useful trick. Instead of using ``sorry``, you can use
an underscore ``_`` as a placeholder. Recall this tells Lean that
the argument is implicit, and should be filled in automatically. If
Lean tries to do so and fails, it returns with an error message "don't
know how to synthesize placeholder," followed by the type of
the term it is expecting, and all the objects and hypotheses available
in the context. In other words, for each unresolved placeholder, Lean
reports the subgoal that needs to be filled at that point. You can
then construct a proof by incrementally filling in these placeholders.

For reference, here are two sample proofs of validities taken from the
list above.
-->
<p><code>sorry</code> 标识符神奇地生成任何东西的证明，或者提供任何数据类型的对象。当然，作为一种证明方法，它是不可靠的——例如，你可以使用它来证明 <code>False</code>——并且当文件使用或导入依赖于它的定理时，Lean 会产生严重的警告。但它对于增量地构建长证明非常有用。从上到下写证明，用 <code>sorry</code> 来填子证明。确保 Lean 接受所有的 <code>sorry</code>；如果不是，则有一些错误需要纠正。然后返回，用实际的证据替换每个 <code>sorry</code>，直到做完。</p>
<p>有另一个有用的技巧。你可以使用下划线 <code>_</code> 作为占位符，而不是 <code>sorry</code>。回想一下，这告诉 Lean 该参数是隐式的，应该自动填充。如果 Lean 尝试这样做并失败了，它将返回一条错误消息「不知道如何合成占位符」（Don't know how to synthesize placeholder），然后是它所期望的项的类型，以及上下文中可用的所有对象和假设。换句话说，对于每个未解决的占位符，Lean 报告在那一点上需要填充的子目标。然后，你可以通过递增填充这些占位符来构造一个证明。</p>
<p>这里有两个简单的证明例子作为参考。</p>
<!--
```lean
open Classical

-- distributivity
example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) :=
  Iff.intro
    (fun h : p ∧ (q ∨ r) =>
      have hp : p := h.left
      Or.elim (h.right)
        (fun hq : q =>
          show (p ∧ q) ∨ (p ∧ r) from Or.inl ⟨hp, hq⟩)
        (fun hr : r =>
          show (p ∧ q) ∨ (p ∧ r) from Or.inr ⟨hp, hr⟩))
    (fun h : (p ∧ q) ∨ (p ∧ r) =>
      Or.elim h
        (fun hpq : p ∧ q =>
          have hp : p := hpq.left
          have hq : q := hpq.right
          show p ∧ (q ∨ r) from ⟨hp, Or.inl hq⟩)
        (fun hpr : p ∧ r =>
          have hp : p := hpr.left
          have hr : r := hpr.right
          show p ∧ (q ∨ r) from ⟨hp, Or.inr hr⟩))

-- an example that requires classical reasoning
example (p q : Prop) : ¬(p ∧ ¬q) → (p → q) :=
  fun h : ¬(p ∧ ¬q) =>
  fun hp : p =>
  show q from
    Or.elim (em q)
      (fun hq : q => hq)
      (fun hnq : ¬q => absurd (And.intro hp hnq) h)
```
-->
<pre><code class="language-lean">open Classical

-- 分配律
example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) :=
  Iff.intro
    (fun h : p ∧ (q ∨ r) =&gt;
      have hp : p := h.left
      Or.elim (h.right)
        (fun hq : q =&gt;
          show (p ∧ q) ∨ (p ∧ r) from Or.inl ⟨hp, hq⟩)
        (fun hr : r =&gt;
          show (p ∧ q) ∨ (p ∧ r) from Or.inr ⟨hp, hr⟩))
    (fun h : (p ∧ q) ∨ (p ∧ r) =&gt;
      Or.elim h
        (fun hpq : p ∧ q =&gt;
          have hp : p := hpq.left
          have hq : q := hpq.right
          show p ∧ (q ∨ r) from ⟨hp, Or.inl hq⟩)
        (fun hpr : p ∧ r =&gt;
          have hp : p := hpr.left
          have hr : r := hpr.right
          show p ∧ (q ∨ r) from ⟨hp, Or.inr hr⟩))

-- 需要一点经典推理的例子
example (p q : Prop) : ¬(p ∧ ¬q) → (p → q) :=
  fun h : ¬(p ∧ ¬q) =&gt;
  fun hp : p =&gt;
  show q from
    Or.elim (em q)
      (fun hq : q =&gt; hq)
      (fun hnq : ¬q =&gt; absurd (And.intro hp hnq) h)
</code></pre>
<!--
Exercises
---------
-->
<h2 id="练习"><a class="header" href="#练习">练习</a></h2>
<!--
Prove the following identities, replacing the "sorry" placeholders with actual proofs.
-->
<p>证明以下等式，用真实证明取代「sorry」占位符。</p>
<!--
```lean
variable (p q r : Prop)

-- commutativity of ∧ and ∨
example : p ∧ q ↔ q ∧ p := sorry
example : p ∨ q ↔ q ∨ p := sorry

-- associativity of ∧ and ∨
example : (p ∧ q) ∧ r ↔ p ∧ (q ∧ r) := sorry
example : (p ∨ q) ∨ r ↔ p ∨ (q ∨ r) := sorry

-- distributivity
example : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := sorry
example : p ∨ (q ∧ r) ↔ (p ∨ q) ∧ (p ∨ r) := sorry

-- other properties
example : (p → (q → r)) ↔ (p ∧ q → r) := sorry
example : ((p ∨ q) → r) ↔ (p → r) ∧ (q → r) := sorry
example : ¬(p ∨ q) ↔ ¬p ∧ ¬q := sorry
example : ¬p ∨ ¬q → ¬(p ∧ q) := sorry
example : ¬(p ∧ ¬p) := sorry
example : p ∧ ¬q → ¬(p → q) := sorry
example : ¬p → (p → q) := sorry
example : (¬p ∨ q) → (p → q) := sorry
example : p ∨ False ↔ p := sorry
example : p ∧ False ↔ False := sorry
example : (p → q) → (¬q → ¬p) := sorry
```
-->
<pre><code class="language-lean">variable (p q r : Prop)

--  ∧ 和 ∨ 的交换律
example : p ∧ q ↔ q ∧ p := sorry
example : p ∨ q ↔ q ∨ p := sorry

-- ∧ 和 ∨ 的结合律
example : (p ∧ q) ∧ r ↔ p ∧ (q ∧ r) := sorry
example : (p ∨ q) ∨ r ↔ p ∨ (q ∨ r) := sorry

-- 分配律
example : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := sorry
example : p ∨ (q ∧ r) ↔ (p ∨ q) ∧ (p ∨ r) := sorry

-- 其他性质
example : (p → (q → r)) ↔ (p ∧ q → r) := sorry
example : ((p ∨ q) → r) ↔ (p → r) ∧ (q → r) := sorry
example : ¬(p ∨ q) ↔ ¬p ∧ ¬q := sorry
example : ¬p ∨ ¬q → ¬(p ∧ q) := sorry
example : ¬(p ∧ ¬p) := sorry
example : p ∧ ¬q → ¬(p → q) := sorry
example : ¬p → (p → q) := sorry
example : (¬p ∨ q) → (p → q) := sorry
example : p ∨ False ↔ p := sorry
example : p ∧ False ↔ False := sorry
example : (p → q) → (¬q → ¬p) := sorry
</code></pre>
<!--
Prove the following identities, replacing the "sorry" placeholders
with actual proofs. These require classical reasoning.
-->
<p>下面这些需要一点经典逻辑。</p>
<pre><code class="language-lean">open Classical

variable (p q r : Prop)

example : (p → q ∨ r) → ((p → q) ∨ (p → r)) := sorry
example : ¬(p ∧ q) → ¬p ∨ ¬q := sorry
example : ¬(p → q) → p ∧ ¬q := sorry
example : (p → q) → (¬p ∨ q) := sorry
example : (¬q → ¬p) → (p → q) := sorry
example : p ∨ ¬p := sorry
example : (((p → q) → p) → p) := sorry
</code></pre>
<!--
Prove ``¬(p ↔ ¬p)`` without using classical logic.
-->
<p>最后，证明 <code>¬(p ↔ ¬p)</code> 且不使用经典逻辑。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
Quantifiers and Equality
========================
-->
<h1 id="量词与等价"><a class="header" href="#量词与等价">量词与等价</a></h1>
<!--
The last chapter introduced you to methods that construct proofs of
statements involving the propositional connectives. In this chapter,
we extend the repertoire of logical constructions to include the
universal and existential quantifiers, and the equality relation.
-->
<p>上一章介绍了构造包含命题连接词的证明方法。在本章中，我们扩展逻辑结构，包括全称量词和存在量词，以及等价关系。</p>
<!--
The Universal Quantifier
------------------------
-->
<h2 id="全称量词"><a class="header" href="#全称量词">全称量词</a></h2>
<!--
Notice that if ``α`` is any type, we can represent a unary predicate
``p`` on ``α`` as an object of type ``α → Prop``. In that case, given
``x : α``, ``p x`` denotes the assertion that ``p`` holds of
``x``. Similarly, an object ``r : α → α → Prop`` denotes a binary
relation on ``α``: given ``x y : α``, ``r x y`` denotes the assertion
that ``x`` is related to ``y``.

The universal quantifier, ``∀ x : α, p x`` is supposed to denote the
assertion that "for every ``x : α``, ``p x``" holds. As with the
propositional connectives, in systems of natural deduction, "forall"
is governed by an introduction and elimination rule. Informally, the
introduction rule states:

> Given a proof of ``p x``, in a context where ``x : α`` is arbitrary, we obtain a proof ``∀ x : α, p x``.

The elimination rule states:

> Given a proof ``∀ x : α, p x`` and any term ``t : α``, we obtain a proof of ``p t``.

As was the case for implication, the propositions-as-types
interpretation now comes into play. Remember the introduction and
elimination rules for dependent arrow types:

> Given a term ``t`` of type ``β x``, in a context where ``x : α`` is arbitrary, we have ``(fun x : α => t) : (x : α) → β x``.

The elimination rule states:

> Given a term ``s : (x : α) → β x`` and any term ``t : α``, we have ``s t : β t``.

In the case where ``p x`` has type ``Prop``, if we replace
``(x : α) → β x`` with ``∀ x : α, p x``, we can read these as the correct rules
for building proofs involving the universal quantifier.

The Calculus of Constructions therefore identifies dependent arrow
types with forall-expressions in this way. If ``p`` is any expression,
``∀ x : α, p`` is nothing more than alternative notation for
``(x : α) → p``, with the idea that the former is more natural than the latter
in cases where ``p`` is a proposition. Typically, the expression ``p``
will depend on ``x : α``. Recall that, in the case of ordinary
function spaces, we could interpret ``α → β`` as the special case of
``(x : α) → β`` in which ``β`` does not depend on ``x``. Similarly, we
can think of an implication ``p → q`` between propositions as the
special case of ``∀ x : p, q`` in which the expression ``q`` does not
depend on ``x``.

Here is an example of how the propositions-as-types correspondence gets put into practice.
-->
<p>如果 <code>α</code> 是任何类型，我们可以将 <code>α</code> 上的一元谓词 <code>p</code> 作为 <code>α → Prop</code> 类型的对象。在这种情况下，给定 <code>x : α</code>， <code>p x</code> 表示断言 <code>p</code> 在 <code>x</code> 上成立。类似地，一个对象 <code>r : α → α → Prop</code> 表示 <code>α</code> 上的二元关系：给定 <code>x y : α</code>，<code>r x y</code> 表示断言 <code>x</code> 与 <code>y</code> 相关。</p>
<p>全称量词 <code>∀ x : α, p x</code> 表示，对于每一个 <code>x : α</code>，<code>p x</code> 成立。与命题连接词一样，在自然演绎系统中，「forall」有引入和消去规则。非正式地，引入规则是：</p>
<blockquote>
<p>在 <code>x : α</code> 是任意的情况下，给定 <code>p x</code> 的证明；就可以得到 <code>∀ x : α, p x</code> 的证明。</p>
</blockquote>
<p>消去规则是：</p>
<blockquote>
<p>给定 <code>∀ x : α, p x</code> 的证明和任何项 <code>t : α</code>，就可以得到 <code>p t</code> 的证明。</p>
</blockquote>
<p>与蕴含的情况一样，命题即类型。回想依值箭头类型的引入规则:</p>
<blockquote>
<p>在 <code>x : α</code> 是任意的情况下给定类型为 <code>β x</code> 的项 <code>t</code>，就可以得到 <code>(fun x : α =&gt; t) : (x : α) → β x</code>。</p>
</blockquote>
<p>消去规则：</p>
<blockquote>
<p>给定项 <code>s : (x : α) → β x</code> 和任何项 <code>t : α</code>，就可以得到 <code>s t : β t</code>。</p>
</blockquote>
<p>在 <code>p x</code> 具有 <code>Prop</code> 类型的情况下，如果我们用 <code>∀ x : α, p x</code> 替换 <code>(x : α) → β x</code>，就得到构建涉及全称量词的证明的规则。</p>
<p>因此，构造演算用全称表达式来识别依值箭头类型。如果 <code>p</code> 是任何表达式，<code>∀ x : α, p</code> 不过是 <code>(x : α) → p</code> 的替代符号，在 <code>p</code> 是命题的情况下，前者比后者更自然。通常，表达式 <code>p</code> 取决于 <code>x : α</code>。回想一下，在普通函数空间中，我们可以将 <code>α → β</code> 解释为 <code>(x : α) → β</code> 的特殊情况，其中 <code>β</code> 不依赖于 <code>x</code>。类似地，我们可以把命题之间的蕴涵 <code>p → q</code> 看作是 <code>∀ x : p, q</code> 的特殊情况，其中 <code>q</code> 不依赖于 <code>x</code>。</p>
<p>下面是一个例子，说明了如何运用命题即类型对应规则。<code>∀</code> 可以用 <code>\forall</code> 输入，也可以用前两个字母简写 <code>\fo</code>。</p>
<pre><code class="language-lean">example (α : Type) (p q : α → Prop) : (∀ x : α, p x ∧ q x) → ∀ y : α, p y :=
  fun h : ∀ x : α, p x ∧ q x =&gt;
  fun y : α =&gt;
  show p y from (h y).left
</code></pre>
<!--
As a notational convention, we give the universal quantifier the
widest scope possible, so parentheses are needed to limit the
quantifier over ``x`` to the hypothesis in the example above. The
canonical way to prove ``∀ y : α, p y`` is to take an arbitrary ``y``,
and prove ``p y``. This is the introduction rule. Now, given that
``h`` has type ``∀ x : α, p x ∧ q x``, the expression ``h y`` has type
``p y ∧ q y``. This is the elimination rule. Taking the left conjunct
gives the desired conclusion, ``p y``.

Remember that expressions which differ up to renaming of bound
variables are considered to be equivalent. So, for example, we could
have used the same variable, ``x``, in both the hypothesis and
conclusion, and instantiated it by a different variable, ``z``, in the
proof:
-->
<p>作为一种符号约定，我们给予全称量词尽可能最宽的优先级范围，因此上面例子中的假设中，需要用括号将 <code>x</code> 上的量词限制起来。证明 <code>∀ y : α, p y</code> 的标准方法是取任意的 <code>y</code>，然后证明 <code>p y</code>。这是引入规则。现在，给定 <code>h</code> 有类型 <code>∀ x : α, p x ∧ q x</code>，表达式 <code>h y</code> 有类型 <code>p y ∧ q y</code>。这是消去规则。取合取的左侧得到想要的结论 <code>p y</code>。</p>
<p>只有约束变量名称不同的表达式被认为是等价的。因此，例如，我们可以在假设和结论中使用相同的变量 <code>x</code>，并在证明中用不同的变量 <code>z</code> 实例化它:</p>
<pre><code class="language-lean">example (α : Type) (p q : α → Prop) : (∀ x : α, p x ∧ q x) → ∀ x : α, p x :=
  fun h : ∀ x : α, p x ∧ q x =&gt;
  fun z : α =&gt;
  show p z from And.left (h z)
</code></pre>
<!--
As another example, here is how we can express the fact that a relation, ``r``, is transitive:
-->
<p>再举一个例子，下面是关系 <code>r</code> 的传递性：</p>
<pre><code class="language-lean">variable (α : Type) (r : α → α → Prop)
variable (trans_r : ∀ x y z, r x y → r y z → r x z)

variable (a b c : α)
variable (hab : r a b) (hbc : r b c)

#check trans_r    -- ∀ (x y z : α), r x y → r y z → r x z
#check trans_r a b c -- r a b → r b c → r a c
#check trans_r a b c hab -- r b c → r a c
#check trans_r a b c hab hbc -- r a c
</code></pre>
<!--

Think about what is going on here. When we instantiate ``trans_r`` at
the values ``a b c``, we end up with a proof of ``r a b → r b c → r a c``.
Applying this to the "hypothesis" ``hab : r a b``, we get a proof
of the implication ``r b c → r a c``. Finally, applying it to the
hypothesis ``hbc`` yields a proof of the conclusion ``r a c``.

In situations like this, it can be tedious to supply the arguments
``a b c``, when they can be inferred from ``hab hbc``. For that reason, it
is common to make these arguments implicit:
-->
<p>当我们在值 <code>a b c</code> 上实例化 <code>trans_r</code> 时，我们最终得到 <code>r a b → r b c → r a c</code> 的证明。将此应用于「假设」<code>hab : r a b</code>，我们得到了 <code>r b c → r a c</code> 的一个证明。最后将它应用到假设 <code>hbc</code> 中，得到结论 <code>r a c</code> 的证明。</p>
<pre><code class="language-lean">variable (α : Type) (r : α → α → Prop)
variable (trans_r : ∀ {x y z}, r x y → r y z → r x z)

variable (a b c : α)
variable (hab : r a b) (hbc : r b c)

#check trans_r
#check trans_r hab
#check trans_r hab hbc
</code></pre>
<!--
The advantage is that we can simply write ``trans_r hab hbc`` as a
proof of ``r a c``. A disadvantage is that Lean does not have enough
information to infer the types of the arguments in the expressions
``trans_r`` and ``trans_r hab``. The output of the first ``#check``
command is ``r ?m.1 ?m.2 → r ?m.2 ?m.3 → r ?m.1 ?m.3``, indicating
that the implicit arguments are unspecified in this case.

Here is an example of how we can carry out elementary reasoning with an equivalence relation:
-->
<p>优点是我们可以简单地写 <code>trans_r hab hbc</code> 作为 <code>r a c</code> 的证明。一个缺点是 Lean 没有足够的信息来推断表达式 <code>trans_r</code> 和 <code>trans_r hab</code> 中的参数类型。第一个 <code>#check</code> 命令的输出是 <code>r ?m.1 ?m.2 → r ?m.2 ?m.3 → r ?m.1 ?m.3</code>，表示在本例中隐式参数未指定。</p>
<p>下面是一个用等价关系进行基本推理的例子:</p>
<pre><code class="language-lean">variable (α : Type) (r : α → α → Prop)

variable (refl_r : ∀ x, r x x)
variable (symm_r : ∀ {x y}, r x y → r y x)
variable (trans_r : ∀ {x y z}, r x y → r y z → r x z)

example (a b c d : α) (hab : r a b) (hcb : r c b) (hcd : r c d) : r a d :=
  trans_r (trans_r hab (symm_r hcb)) hcd
</code></pre>
<!--
To get used to using universal quantifiers, you should try some of the
exercises at the end of this section.

It is the typing rule for dependent arrow types, and the universal
quantifier in particular, that distinguishes ``Prop`` from other
types.  Suppose we have ``α : Sort i`` and ``β : Sort j``, where the
expression ``β`` may depend on a variable ``x : α``. Then
``(x : α) → β`` is an element of ``Sort (imax i j)``, where ``imax i j`` is the
maximum of ``i`` and ``j`` if ``j`` is not 0, and 0 otherwise.

The idea is as follows. If ``j`` is not ``0``, then ``(x : α) → β`` is
an element of ``Sort (max i j)``. In other words, the type of
dependent functions from ``α`` to ``β`` "lives" in the universe whose
index is the maximum of ``i`` and ``j``. Suppose, however, that ``β``
is of ``Sort 0``, that is, an element of ``Prop``. In that case,
``(x : α) → β`` is an element of ``Sort 0`` as well, no matter which
type universe ``α`` lives in. In other words, if ``β`` is a
proposition depending on ``α``, then ``∀ x : α, β`` is again a
proposition. This reflects the interpretation of ``Prop`` as the type
of propositions rather than data, and it is what makes ``Prop``
*impredicative*.

The term "predicative" stems from foundational developments around the
turn of the twentieth century, when logicians such as Poincaré and
Russell blamed set-theoretic paradoxes on the "vicious circles" that
arise when we define a property by quantifying over a collection that
includes the very property being defined. Notice that if ``α`` is any
type, we can form the type ``α → Prop`` of all predicates on ``α``
(the "power type of ``α``"). The impredicativity of ``Prop`` means that we
can form propositions that quantify over ``α → Prop``. In particular,
we can define predicates on ``α`` by quantifying over all predicates
on ``α``, which is exactly the type of circularity that was once
considered problematic.
-->
<p>为了习惯使用全称量词，你应该尝试本节末尾的一些练习。</p>
<p>依值箭头类型的类型规则，特别是全称量词，体现了 <code>Prop</code> 命题类型与其他对象的类型的不同。假设我们有 <code>α : Sort i</code> 和 <code>β : Sort j</code>，其中表达式 <code>β</code> 可能依赖于变量 <code>x : α</code>。那么 <code>(x : α) → β</code> 是 <code>Sort (imax i j)</code> 的一个元素，其中 <code>imax i j</code> 是 <code>i</code> 和 <code>j</code> 在 <code>j</code> 不为0时的最大值，否则为0。</p>
<p>其想法如下。如果 <code>j</code> 不是 <code>0</code>，然后 <code>(x : α) → β</code> 是 <code>Sort (max i j)</code> 类型的一个元素。换句话说，从 <code>α</code> 到 <code>β</code> 的一类依值函数存在于指数为 <code>i</code> 和 <code>j</code> 最大值的宇宙中。然而，假设 <code>β</code> 属于 <code>Sort 0</code>，即 <code>Prop</code> 的一个元素。在这种情况下，<code>(x : α) → β</code> 也是 <code>Sort 0</code> 的一个元素，无论 <code>α</code> 生活在哪种类型的宇宙中。换句话说，如果 <code>β</code> 是一个依赖于 <code>α</code> 的命题，那么 <code>∀ x : α, β</code> 又是一个命题。这反映出 <code>Prop</code> 作为一种命题类型而不是数据类型，这也使得 <code>Prop</code> 具有「非直谓性」（impredicative）。</p>
<p>「直谓性」一词起源于20世纪初的数学基础发展，当时逻辑学家如庞加莱和罗素将集合论的悖论归咎于「恶性循环」：当我们通过量化一个集合来定义一个属性时，这个集合包含了被定义的属性。注意，如果 <code>α</code> 是任何类型，我们可以在 <code>α</code> 上形成所有谓词的类型 <code>α → Prop</code>(<code>α</code> 的「幂」类型)。Prop的非直谓性意味着我们可以通过 <code>α → Prop</code> 形成量化命题。特别是，我们可以通过量化所有关于 <code>α</code> 的谓词来定义 <code>α</code> 上的谓词，这正是曾经被认为有问题的循环类型。</p>
<!--
Equality
--------
-->
<h2 id="等价"><a class="header" href="#等价">等价</a></h2>
<!--
Let us now turn to one of the most fundamental relations defined in
Lean's library, namely, the equality relation. In [Chapter Inductive Types](inductive_types.md),
we will explain *how* equality is defined from the primitives of Lean's logical framework.
In the meanwhile, here we explain how to use it.

Of course, a fundamental property of equality is that it is an equivalence relation:
-->
<p>现在让我们来看看在 Lean 库中定义的最基本的关系之一，即等价关系。在<a href="inductive_types.html">归纳类型</a>一章中，我们将解释如何从 Lean 的逻辑框架中定义等价。在这里我们解释如何使用它。</p>
<p>等价关系的基本性质：反身性、对称性、传递性。</p>
<pre><code class="language-lean">#check Eq.refl    -- Eq.refl.{u_1} {α : Sort u_1} (a : α) : a = a
#check Eq.symm    -- Eq.symm.{u} {α : Sort u} {a b : α} (h : a = b) : b = a
#check Eq.trans   -- Eq.trans.{u} {α : Sort u} {a b c : α} (h₁ : a = b) (h₂ : b = c) : a = c
</code></pre>
<!--
We can make the output easier to read by telling Lean not to insert
the implicit arguments (which are displayed here as metavariables).
-->
<p>通过告诉 Lean 不要插入隐参数(在这里显示为元变量)可以使输出更容易阅读。</p>
<pre><code class="language-lean">universe u

#check @Eq.refl.{u}   -- @Eq.refl : ∀ {α : Sort u} (a : α), a = a
#check @Eq.symm.{u}   -- @Eq.symm : ∀ {α : Sort u} {a b : α}, a = b → b = a
#check @Eq.trans.{u}  -- @Eq.trans : ∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c
</code></pre>
<!--
The inscription ``.{u}`` tells Lean to instantiate the constants at the universe ``u``.

Thus, for example, we can specialize the example from the previous section to the equality relation:
-->
<p><code>.{u}</code> 告诉 Lean 实例化宇宙 <code>u</code> 上的常量。</p>
<p>因此，我们可以将上一节中的示例具体化为等价关系:</p>
<pre><code class="language-lean">variable (α : Type) (a b c d : α)
variable (hab : a = b) (hcb : c = b) (hcd : c = d)

example : a = d :=
  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd
</code></pre>
<!--
We can also use the projection notation:
-->
<p>我们也可以使用投影记号：</p>
<pre><code class="language-lean"><span class="boring">variable (α : Type) (a b c d : α)
</span><span class="boring">variable (hab : a = b) (hcb : c = b) (hcd : c = d)
</span>example : a = d := (hab.trans hcb.symm).trans hcd
</code></pre>
<!--
Reflexivity is more powerful than it looks. Recall that terms in the
Calculus of Constructions have a computational interpretation, and
that the logical framework treats terms with a common reduct as the
same. As a result, some nontrivial identities can be proved by
reflexivity:
-->
<p>反身性比它看上去更强大。回想一下，在构造演算中，项有一个计算解释，可规约为相同形式的项会被逻辑框架视为相同的。因此，一些非平凡的恒等式可以通过自反性来证明：</p>
<pre><code class="language-lean">variable (α β : Type)

example (f : α → β) (a : α) : (fun x =&gt; f x) a = f a := Eq.refl _
example (a : α) (b : β) : (a, b).1 = a := Eq.refl _
example : 2 + 3 = 5 := Eq.refl _
</code></pre>
<!--
This feature of the framework is so important that the library defines a notation ``rfl`` for ``Eq.refl _``:
-->
<p>这个特性非常重要，以至于库中为 <code>Eq.refl _</code> 专门定义了一个符号 <code>rfl</code>：</p>
<pre><code class="language-lean"><span class="boring">variable (α β : Type)
</span>example (f : α → β) (a : α) : (fun x =&gt; f x) a = f a := rfl
example (a : α) (b : β) : (a, b).1 = a := rfl
example : 2 + 3 = 5 := rfl
</code></pre>
<!--
Equality is much more than an equivalence relation, however. It has
the important property that every assertion respects the equivalence,
in the sense that we can substitute equal expressions without changing
the truth value. That is, given ``h1 : a = b`` and ``h2 : p a``, we
can construct a proof for ``p b`` using substitution:
``Eq.subst h1 h2``.
-->
<p>然而，等价不仅仅是一种关系。它有一个重要的性质，即每个断言都遵从等价性，即我们可以在不改变真值的情况下对表达式做等价代换。也就是说，给定 <code>h1 : a = b</code> 和 <code>h2 : p a</code>，我们可以构造一个证明 <code>p b</code>，只需要使用代换 <code>Eq.subst h1 h2</code>。</p>
<pre><code class="language-lean">example (α : Type) (a b : α) (p : α → Prop)
        (h1 : a = b) (h2 : p a) : p b :=
  Eq.subst h1 h2

example (α : Type) (a b : α) (p : α → Prop)
    (h1 : a = b) (h2 : p a) : p b :=
  h1 ▸ h2
</code></pre>
<!--
The triangle in the second presentation is a macro built on top of
``Eq.subst`` and ``Eq.symm``, and you can enter it by typing ``\t``.

The rule ``Eq.subst`` is used to define the following auxiliary rules,
which carry out more explicit substitutions. They are designed to deal
with applicative terms, that is, terms of form ``s t``. Specifically,
``congrArg`` can be used to replace the argument, ``congrFun`` can be
used to replace the term that is being applied, and ``congr`` can be
used to replace both at once.
-->
<p>第二个例子中的三角形是建立在 <code>Eq.subst</code> 和 <code>Eq.symm</code> 之上的宏，它可以通过 <code>\t</code> 来输入。</p>
<p>规则 <code>Eq.subst</code> 定义了一些辅助规则，用来执行更显式的替换。它们是为处理应用型项，即形式为 <code>s t</code> 的项而设计的。这些辅助规则是，使用 <code>congrArg</code> 来替换参数，使用 <code>congrFun</code> 来替换正在应用的项，并且可以同时使用 <code>congr</code> 来替换两者。</p>
<pre><code class="language-lean">variable (α : Type)
variable (a b : α)
variable (f g : α → Nat)
variable (h₁ : a = b)
variable (h₂ : f = g)

example : f a = f b := congrArg f h₁
example : f a = g a := congrFun h₂ a
example : f a = g b := congr h₂ h₁
</code></pre>
<!--
Lean's library contains a large number of common identities, such as these:
-->
<p>Lean 的库包含大量通用的等式，例如：</p>
<pre><code class="language-lean">variable (a b c : Nat)

example : a + 0 = a := Nat.add_zero a
example : 0 + a = a := Nat.zero_add a
example : a * 1 = a := Nat.mul_one a
example : 1 * a = a := Nat.one_mul a
example : a + b = b + a := Nat.add_comm a b
example : a + b + c = a + (b + c) := Nat.add_assoc a b c
example : a * b = b * a := Nat.mul_comm a b
example : a * b * c = a * (b * c) := Nat.mul_assoc a b c
example : a * (b + c) = a * b + a * c := Nat.mul_add a b c
example : a * (b + c) = a * b + a * c := Nat.left_distrib a b c
example : (a + b) * c = a * c + b * c := Nat.add_mul a b c
example : (a + b) * c = a * c + b * c := Nat.right_distrib a b c
</code></pre>
<!--
Note that ``Nat.mul_add`` and ``Nat.add_mul`` are alternative names
for ``Nat.left_distrib`` and ``Nat.right_distrib``, respectively.  The
properties above are stated for the natural numbers (type ``Nat``).

Here is an example of a calculation in the natural numbers that uses
substitution combined with associativity and distributivity.
-->
<p><code>Nat.mul_add</code> 和 <code>Nat.add_mul</code> 是 <code>Nat.left_distrib</code> 和 <code>Nat.right_distrib</code> 的代称。上面的属性是为自然数类型 <code>Nat</code> 声明的。</p>
<p>这是一个使用代换以及结合律、交换律和分配律的自然数计算的例子。</p>
<pre><code class="language-lean">example (x y : Nat) : (x + y) * (x + y) = x * x + y * x + x * y + y * y :=
  have h1 : (x + y) * (x + y) = (x + y) * x + (x + y) * y :=
    Nat.mul_add (x + y) x y
  have h2 : (x + y) * (x + y) = x * x + y * x + (x * y + y * y) :=
    (Nat.add_mul x y x) ▸ (Nat.add_mul x y y) ▸ h1
  h2.trans (Nat.add_assoc (x * x + y * x) (x * y) (y * y)).symm
</code></pre>
<!--
Notice that the second implicit parameter to ``Eq.subst``, which
provides the context in which the substitution is to occur, has type
``α → Prop``.  Inferring this predicate therefore requires an instance
of *higher-order unification*. In full generality, the problem of
determining whether a higher-order unifier exists is undecidable, and
Lean can at best provide imperfect and approximate solutions to the
problem. As a result, ``Eq.subst`` doesn't always do what you want it
to.  The macro ``h ▸ e`` uses more effective heuristics for computing
this implicit parameter, and often succeeds in situations where
applying ``Eq.subst`` fails.

Because equational reasoning is so common and important, Lean provides
a number of mechanisms to carry it out more effectively. The next
section offers syntax that allow you to write calculational proofs in
a more natural and perspicuous way. But, more importantly, equational
reasoning is supported by a term rewriter, a simplifier, and other
kinds of automation. The term rewriter and simplifier are described
briefly in the next section, and then in greater detail in the next
chapter.
-->
<p>注意，<code>Eq.subst</code> 的第二个隐式参数提供了将要发生代换的表达式上下文，其类型为 <code>α → Prop</code>。因此，推断这个谓词需要一个<em>高阶合一</em>（higher-order unification）的实例。一般来说，确定高阶合一器是否存在的问题是无法确定的，而 Lean 充其量只能提供不完美的和近似的解决方案。因此，<code>Eq.subst</code> 并不总是做你想要它做的事。宏 <code>h ▸ e</code> 使用了更有效的启发式方法来计算这个隐参数，并且在不能应用 <code>Eq.subst</code> 的情况下通常会成功。</p>
<p>因为等式推理是如此普遍和重要，Lean 提供了许多机制来更有效地执行它。下一节将提供允许你以更自然和清晰的方式编写计算式证明的语法。但更重要的是，等式推理是由项重写器、简化器和其他种类的自动化方法支持的。术语重写器和简化器将在下一节中简要描述，然后在下一章中更详细地描述。</p>
<!--
Calculational Proofs
--------------------
-->
<h2 id="计算式证明"><a class="header" href="#计算式证明">计算式证明</a></h2>
<!--
A calculational proof is just a chain of intermediate results that are
meant to be composed by basic principles such as the transitivity of
equality. In Lean, a calculational proof starts with the keyword
``calc``, and has the following syntax:
-->
<p>一个计算式证明是指一串使用诸如等式的传递性等基本规则得到的中间结果。在 Lean 中，计算式证明从关键字 <code>calc</code> 开始，语法如下：</p>
<pre><code>calc
  &lt;expr&gt;_0  'op_1'  &lt;expr&gt;_1  ':='  &lt;proof&gt;_1
  '_'       'op_2'  &lt;expr&gt;_2  ':='  &lt;proof&gt;_2
  ...
  '_'       'op_n'  &lt;expr&gt;_n  ':='  &lt;proof&gt;_n
</code></pre>
<!--
Note that the `calc` relations all have the same indentation. Each
``<proof>_i`` is a proof for ``<expr>_{i-1} op_i <expr>_i``.

We can also use `_` in the first relation (right after ``<expr>_0``)
which is useful to align the sequence of relation/proof pairs:
-->
<p><code>calc</code> 下的每一行使用相同的缩进。每个 <code>&lt;proof&gt;_i</code> 是 <code>&lt;expr&gt;_{i-1} op_i &lt;expr&gt;_i</code> 的证明。</p>
<p>我们也可以在第一个关系中使用 <code>_</code>(就在 <code>&lt;expr&gt;_0</code> 之后)，这对于对齐关系/证明对的序列很有用:</p>
<pre><code>calc &lt;expr&gt;_0
    '_' 'op_1' &lt;expr&gt;_1 ':=' &lt;proof&gt;_1
    '_' 'op_2' &lt;expr&gt;_2 ':=' &lt;proof&gt;_2
    ...
    '_' 'op_n' &lt;expr&gt;_n ':=' &lt;proof&gt;_n
</code></pre>
<!--
Here is an example:
-->
<p>例子：</p>
<pre><code class="language-lean">variable (a b c d e : Nat)
variable (h1 : a = b)
variable (h2 : b = c + 1)
variable (h3 : c = d)
variable (h4 : e = 1 + d)

theorem T : a = e :=
  calc
    a = b      := h1
    _ = c + 1  := h2
    _ = d + 1  := congrArg Nat.succ h3
    _ = 1 + d  := Nat.add_comm d 1
    _ = e      := Eq.symm h4
</code></pre>
<!--
This style of writing proofs is most effective when it is used in
conjunction with the ``simp`` and ``rewrite`` tactics, which are
discussed in greater detail in the next chapter. For example, using
the abbreviation ``rw`` for rewrite, the proof above could be written
as follows:
-->
<p>这种写证明的风格在与 <code>simp</code> 和 <code>rewrite</code> 策略（Tactic）结合使用时最为有效，这些策略将在下一章详细讨论。例如，用缩写 <code>rw</code> 表示重写，上面的证明可以写成如下。</p>
<pre><code class="language-lean"><span class="boring">variable (a b c d e : Nat)
</span><span class="boring">variable (h1 : a = b)
</span><span class="boring">variable (h2 : b = c + 1)
</span><span class="boring">variable (h3 : c = d)
</span><span class="boring">variable (h4 : e = 1 + d)
</span>theorem T : a = e :=
  calc
    a = b      := by rw [h1]
    _ = c + 1  := by rw [h2]
    _ = d + 1  := by rw [h3]
    _ = 1 + d  := by rw [Nat.add_comm]
    _ = e      := by rw [h4]
</code></pre>
<!--
Essentially, the ``rw`` tactic uses a given equality (which can be a
hypothesis, a theorem name, or a complex term) to "rewrite" the
goal. If doing so reduces the goal to an identity ``t = t``, the
tactic applies reflexivity to prove it.

Rewrites can be applied sequentially, so that the proof above can be
shortened to this:
-->
<p>本质上，<code>rw</code> 策略使用一个给定的等式(它可以是一个假设、一个定理名称或一个复杂的项)来「重写」目标。如果这样做将目标简化为一种等式 <code>t = t</code>，那么该策略将使用反身性来证明这一点。</p>
<p>重写可以一次应用一系列，因此上面的证明可以缩写为：</p>
<pre><code class="language-lean"><span class="boring">variable (a b c d e : Nat)
</span><span class="boring">variable (h1 : a = b)
</span><span class="boring">variable (h2 : b = c + 1)
</span><span class="boring">variable (h3 : c = d)
</span><span class="boring">variable (h4 : e = 1 + d)
</span>theorem T : a = e :=
  calc
    a = d + 1  := by rw [h1, h2, h3]
    _ = 1 + d  := by rw [Nat.add_comm]
    _ = e      := by rw [h4]
</code></pre>
<!--
Or even this:
-->
<p>甚至更简单：</p>
<pre><code class="language-lean"><span class="boring">variable (a b c d e : Nat)
</span><span class="boring">variable (h1 : a = b)
</span><span class="boring">variable (h2 : b = c + 1)
</span><span class="boring">variable (h3 : c = d)
</span><span class="boring">variable (h4 : e = 1 + d)
</span>theorem T : a = e :=
  by rw [h1, h2, h3, Nat.add_comm, h4]
</code></pre>
<!--
The ``simp`` tactic, instead, rewrites the goal by applying the given
identities repeatedly, in any order, anywhere they are applicable in a
term. It also uses other rules that have been previously declared to
the system, and applies commutativity wisely to avoid looping. As a
result, we can also prove the theorem as follows:
-->
<p>相反，<code>simp</code> 策略通过在项中以任意顺序在任何适用的地方重复应用给定的等式来重写目标。它还使用了之前声明给系统的其他规则，并明智地应用交换性以避免循环。因此，我们也可以如下证明定理:</p>
<pre><code class="language-lean"><span class="boring">variable (a b c d e : Nat)
</span><span class="boring">variable (h1 : a = b)
</span><span class="boring">variable (h2 : b = c + 1)
</span><span class="boring">variable (h3 : c = d)
</span><span class="boring">variable (h4 : e = 1 + d)
</span>theorem T : a = e :=
  by simp [h1, h2, h3, Nat.add_comm, h4]
</code></pre>
<!--
We will discuss variations of ``rw`` and ``simp`` in the next chapter.

The ``calc`` command can be configured for any relation that supports
some form of transitivity. It can even combine different relations.
-->
<p>我们将在下一章讨论 <code>rw</code> 和 <code>simp</code> 的变体。</p>
<p><code>calc</code> 命令可以配置为任何支持某种形式的传递性的关系式。它甚至可以结合不同的关系式。</p>
<pre><code class="language-lean">example (a b c d : Nat) (h1 : a = b) (h2 : b ≤ c) (h3 : c + 1 &lt; d) : a &lt; d :=
  calc
    a = b     := h1
    _ &lt; b + 1 := Nat.lt_succ_self b
    _ ≤ c + 1 := Nat.succ_le_succ h2
    _ &lt; d     := h3
</code></pre>
<!--
You can "teach" `calc` new transitivity theorems by adding new instances
of the `Trans` type class. Type classes are introduced later, but the following
small example demonstrates how to extend the `calc` notation using new `Trans` instances.
-->
<p>你可以通过添加 <code>Trans</code> 类型类（Type class）的新实例来「教给」<code>calc</code> 新的传递性定理。稍后将介绍类型类，但下面的小示例将演示如何使用新的 <code>Trans</code> 实例扩展 <code>calc</code> 表示法。</p>
<pre><code class="language-lean">def divides (x y : Nat) : Prop :=
  ∃ k, k*x = y

def divides_trans (h₁ : divides x y) (h₂ : divides y z) : divides x z :=
  let ⟨k₁, d₁⟩ := h₁
  let ⟨k₂, d₂⟩ := h₂
  ⟨k₁ * k₂, by rw [Nat.mul_comm k₁ k₂, Nat.mul_assoc, d₁, d₂]⟩

def divides_mul (x : Nat) (k : Nat) : divides x (k*x) :=
  ⟨k, rfl⟩

instance : Trans divides divides divides where
  trans := divides_trans

example (h₁ : divides x y) (h₂ : y = z) : divides x (2*z) :=
  calc
    divides x y     := h₁
    _ = z           := h₂
    divides _ (2*z) := divides_mul ..

infix:50 &quot; ∣ &quot; =&gt; divides

example (h₁ : divides x y) (h₂ : y = z) : divides x (2*z) :=
  calc
    x ∣ y   := h₁
    _ = z   := h₂
    _ ∣ 2*z := divides_mul ..
</code></pre>
<!--
The example above also makes it clear that you can use `calc` even if you
do not have an infix notation for your relation. Finally we remark that
the vertical bar `∣` in the example above is the unicode one. We use
unicode to make sure we do not overload the ASCII `|` used in the
`match .. with` expression.
-->
<p>上面的例子也清楚地表明，即使关系式没有中缀符号，也可以使用 <code>calc</code>。最后，我们注意到上面例子中的竖线<code>∣</code>是unicode。我们使用 unicode 来确保我们不会重载在<code>match .. with</code>表达式中使用的ASCII<code>|</code>。</p>
<!--
With ``calc``, we can write the proof in the last section in a more
natural and perspicuous way.
-->
<p>使用 <code>calc</code>，我们可以以一种更自然、更清晰的方式写出上一节的证明。</p>
<pre><code class="language-lean">example (x y : Nat) : (x + y) * (x + y) = x * x + y * x + x * y + y * y :=
  calc
    (x + y) * (x + y) = (x + y) * x + (x + y) * y  := by rw [Nat.mul_add]
    _ = x * x + y * x + (x + y) * y                := by rw [Nat.add_mul]
    _ = x * x + y * x + (x * y + y * y)            := by rw [Nat.add_mul]
    _ = x * x + y * x + x * y + y * y              := by rw [←Nat.add_assoc]
</code></pre>
<!--
The alternative `calc` notation is worth considering here. When the
first expression is taking this much space, using `_` in the first
relation naturally aligns all relations:
-->
<p>这里值得考虑另一种 <code>calc</code> 表示法。当第一个表达式占用这么多空间时，在第一个关系中使用 <code>_</code> 自然会对齐所有关系式:</p>
<pre><code class="language-lean">example (x y : Nat) : (x + y) * (x + y) = x * x + y * x + x * y + y * y :=
  calc (x + y) * (x + y)
    _ = (x + y) * x + (x + y) * y       := by rw [Nat.mul_add]
    _ = x * x + y * x + (x + y) * y     := by rw [Nat.add_mul]
    _ = x * x + y * x + (x * y + y * y) := by rw [Nat.add_mul]
    _ = x * x + y * x + x * y + y * y   := by rw [←Nat.add_assoc]
</code></pre>
<!--
Here the left arrow before ``Nat.add_assoc`` tells rewrite to use the
identity in the opposite direction. (You can enter it with ``\l`` or
use the ascii equivalent, ``<-``.) If brevity is what we are after,
both ``rw`` and ``simp`` can do the job on their own:
-->
<p><code>Nat.add_assoc</code> 之前的左箭头指挥重写以相反的方向使用等式。(你可以输入 <code>\l</code> 或 ascii 码 <code>&lt;-</code>。)如果追求简洁，<code>rw</code> 和 <code>simp</code> 可以一次性完成这项工作:</p>
<pre><code class="language-lean">example (x y : Nat) : (x + y) * (x + y) = x * x + y * x + x * y + y * y :=
  by rw [Nat.mul_add, Nat.add_mul, Nat.add_mul, ←Nat.add_assoc]

example (x y : Nat) : (x + y) * (x + y) = x * x + y * x + x * y + y * y :=
  by simp [Nat.mul_add, Nat.add_mul, Nat.add_assoc]
</code></pre>
<!--
The Existential Quantifier
--------------------------
-->
<h2 id="存在量词"><a class="header" href="#存在量词">存在量词</a></h2>
<!--
Finally, consider the existential quantifier, which can be written as
either ``exists x : α, p x`` or ``∃ x : α, p x``.  Both versions are
actually notationally convenient abbreviations for a more long-winded
expression, ``Exists (fun x : α => p x)``, defined in Lean's library.

As you should by now expect, the library includes both an introduction
rule and an elimination rule. The introduction rule is
straightforward: to prove ``∃ x : α, p x``, it suffices to provide a
suitable term ``t`` and a proof of ``p t``. Here are some examples:
-->
<p>存在量词可以写成 <code>exists x : α, p x</code> 或 <code>∃ x : α, p x</code>。这两个写法实际上在 Lean 的库中的定义为一个更冗长的表达式，<code>Exists (fun x : α =&gt; p x)</code>。</p>
<p>存在量词也有一个引入规则和一个消去规则。引入规则很简单：要证明 <code>∃ x : α, p x</code>，只需提供一个合适的项 <code>t</code> 和对 <code>p t</code> 的证明即可。<code>∃</code> 用 <code>\exists</code> 或简写 <code>\ex</code> 输入，下面是一些例子:</p>
<pre><code class="language-lean">example : ∃ x : Nat, x &gt; 0 :=
  have h : 1 &gt; 0 := Nat.zero_lt_succ 0
  Exists.intro 1 h

example (x : Nat) (h : x &gt; 0) : ∃ y, y &lt; x :=
  Exists.intro 0 h

example (x y z : Nat) (hxy : x &lt; y) (hyz : y &lt; z) : ∃ w, x &lt; w ∧ w &lt; z :=
  Exists.intro y (And.intro hxy hyz)

#check @Exists.intro -- ∀ {α : Sort u_1} {p : α → Prop} (w : α), p w → Exists p
</code></pre>
<!--
We can use the anonymous constructor notation ``⟨t, h⟩`` for
``Exists.intro t h``, when the type is clear from the context.
-->
<p>当类型可从上下文中推断时，我们可以使用匿名构造子表示法 <code>⟨t, h⟩</code> 替换 <code>Exists.intro t h</code>。</p>
<pre><code class="language-lean">example : ∃ x : Nat, x &gt; 0 :=
  have h : 1 &gt; 0 := Nat.zero_lt_succ 0
  ⟨1, h⟩

example (x : Nat) (h : x &gt; 0) : ∃ y, y &lt; x :=
  ⟨0, h⟩

example (x y z : Nat) (hxy : x &lt; y) (hyz : y &lt; z) : ∃ w, x &lt; w ∧ w &lt; z :=
  ⟨y, hxy, hyz⟩
</code></pre>
<!--
Note that ``Exists.intro`` has implicit arguments: Lean has to infer
the predicate ``p : α → Prop`` in the conclusion ``∃ x, p x``.  This
is not a trivial affair. For example, if we have
``hg : g 0 0 = 0`` and write ``Exists.intro 0 hg``, there are many possible values
for the predicate ``p``, corresponding to the theorems ``∃ x, g x x = x``,
``∃ x, g x x = 0``, ``∃ x, g x 0 = x``, etc. Lean uses the
context to infer which one is appropriate. This is illustrated in the
following example, in which we set the option ``pp.explicit`` to true
to ask Lean's pretty-printer to show the implicit arguments.
-->
<p>注意 <code>Exists.intro</code> 有隐参数：Lean 必须在结论 <code>∃ x, p x</code> 中推断谓词 <code>p : α → Prop</code>。这不是一件小事。例如，如果我们有 <code>hg : g 0 0 = 0</code> 和 <code>Exists.intro 0 hg</code>，有许多可能的值的谓词 <code>p</code>，对应定理 <code>∃ x, g x x = x</code>，<code>∃ x, g x x = 0</code>，<code>∃ x, g x 0 = x</code>，等等。Lean 使用上下文来推断哪个是合适的。下面的例子说明了这一点，在这个例子中，我们设置了选项 <code>pp.explicit</code> 为true，要求 Lean 打印隐参数。</p>
<!--
```lean
variable (g : Nat → Nat → Nat)
variable (hg : g 0 0 = 0)

theorem gex1 : ∃ x, g x x = x := ⟨0, hg⟩
theorem gex2 : ∃ x, g x 0 = x := ⟨0, hg⟩
theorem gex3 : ∃ x, g 0 0 = x := ⟨0, hg⟩
theorem gex4 : ∃ x, g x x = 0 := ⟨0, hg⟩

set_option pp.explicit true  -- display implicit arguments
#print gex1
#print gex2
#print gex3
#print gex4
```
-->
<pre><code class="language-lean">variable (g : Nat → Nat → Nat)
variable (hg : g 0 0 = 0)

theorem gex1 : ∃ x, g x x = x := ⟨0, hg⟩
theorem gex2 : ∃ x, g x 0 = x := ⟨0, hg⟩
theorem gex3 : ∃ x, g 0 0 = x := ⟨0, hg⟩
theorem gex4 : ∃ x, g x x = 0 := ⟨0, hg⟩

set_option pp.explicit true  -- 打印隐参数
#print gex1
#print gex2
#print gex3
#print gex4
</code></pre>
<!--
We can view ``Exists.intro`` as an information-hiding operation, since
it hides the witness to the body of the assertion. The existential
elimination rule, ``Exists.elim``, performs the opposite operation. It
allows us to prove a proposition ``q`` from ``∃ x : α, p x``, by
showing that ``q`` follows from ``p w`` for an arbitrary value
``w``. Roughly speaking, since we know there is an ``x`` satisfying
``p x``, we can give it a name, say, ``w``. If ``q`` does not mention
``w``, then showing that ``q`` follows from ``p w`` is tantamount to
showing that ``q`` follows from the existence of any such ``x``. Here
is an example:
-->
<p>我们可以将 <code>Exists.intro</code> 视为信息隐藏操作，因为它将断言的具体实例隐藏起来变成了存在量词。存在消去规则 <code>Exists.elim</code> 执行相反的操作。它允许我们从 <code>∃ x : α, p x</code> 证明一个命题 <code>q</code>，通过证明对于任意值 <code>w</code> 时 <code>p w</code> 都能推出 <code>q</code>。粗略地说，既然我们知道有一个 <code>x</code> 满足 <code>p x</code>，我们可以给它起个名字，比如 <code>w</code>。如果 <code>q</code> 没有提到 <code>w</code>，那么表明 <code>p w</code> 能推出 <code>q</code> 就等同于表明 <code>q</code> 从任何这样的 <code>x</code> 的存在而推得。下面是一个例子:</p>
<pre><code class="language-lean">variable (α : Type) (p q : α → Prop)

example (h : ∃ x, p x ∧ q x) : ∃ x, q x ∧ p x :=
  Exists.elim h
    (fun w =&gt;
     fun hw : p w ∧ q w =&gt;
     show ∃ x, q x ∧ p x from ⟨w, hw.right, hw.left⟩)
</code></pre>
<!--
It may be helpful to compare the exists-elimination rule to the
or-elimination rule: the assertion ``∃ x : α, p x`` can be thought of
as a big disjunction of the propositions ``p a``, as ``a`` ranges over
all the elements of ``α``. Note that the anonymous constructor
notation ``⟨w, hw.right, hw.left⟩`` abbreviates a nested constructor
application; we could equally well have written ``⟨w, ⟨hw.right, hw.left⟩⟩``.

Notice that an existential proposition is very similar to a sigma
type, as described in dependent types section.  The difference is that
given ``a : α`` and ``h : p a``, the term ``Exists.intro a h`` has
type ``(∃ x : α, p x) : Prop`` and ``Sigma.mk a h`` has type
``(Σ x : α, p x) : Type``. The similarity between ``∃`` and ``Σ`` is another
instance of the Curry-Howard isomorphism.

Lean provides a more convenient way to eliminate from an existential
quantifier with the ``match`` expression:
-->
<p>把存在消去规则和析取消去规则作个比较可能会带来一些启发。命题 <code>∃ x : α, p x</code> 可以看成一个对所有 <code>α</code> 中的元素 <code>a</code> 所组成的命题 <code>p a</code> 的大型析取。注意到匿名构造子 <code>⟨w, hw.right, hw.left⟩</code> 是嵌套的构造子 <code>⟨w, ⟨hw.right, hw.left⟩⟩</code> 的缩写。</p>
<p>存在式命题类型很像依值类型一节所述的 sigma 类型。给定 <code>a : α</code> 和 <code>h : p a</code> 时，项 <code>Exists.intro a h</code> 具有类型 <code>(∃ x : α, p x) : Prop</code>，而 <code>Sigma.mk a h</code> 具有类型 <code>(Σ x : α, p x) : Type</code>。<code>∃</code> 和 <code>Σ</code> 之间的相似性是Curry-Howard同构的另一例子。</p>
<p>Lean 提供一个更加方便的消去存在量词的途径，那就是通过 <code>match</code> 表达式。</p>
<pre><code class="language-lean">variable (α : Type) (p q : α → Prop)

example (h : ∃ x, p x ∧ q x) : ∃ x, q x ∧ p x :=
  match h with
  | ⟨w, hw⟩ =&gt; ⟨w, hw.right, hw.left⟩
</code></pre>
<!--
The ``match`` expression is part of Lean's function definition system,
which provides convenient and expressive ways of defining complex
functions.  Once again, it is the Curry-Howard isomorphism that allows
us to co-opt this mechanism for writing proofs as well.  The ``match``
statement "destructs" the existential assertion into the components
``w`` and ``hw``, which can then be used in the body of the statement
to prove the proposition. We can annotate the types used in the match
for greater clarity:
-->
<p><code>match</code> 表达式是 Lean 功能定义系统的一部分，它提供了复杂功能的方便且丰富的表达方式。再一次，正是Curry-Howard同构让我们能够采用这种机制来编写证明。<code>match</code> 语句将存在断言「析构」到组件 <code>w</code> 和 <code>hw</code> 中，然后可以在语句体中使用它们来证明命题。我们可以对 match 中使用的类型进行注释，以提高清晰度：</p>
<pre><code class="language-lean"><span class="boring">variable (α : Type) (p q : α → Prop)
</span>example (h : ∃ x, p x ∧ q x) : ∃ x, q x ∧ p x :=
  match h with
  | ⟨(w : α), (hw : p w ∧ q w)⟩ =&gt; ⟨w, hw.right, hw.left⟩
</code></pre>
<!--
We can even use the match statement to decompose the conjunction at the same time:
-->
<p>我们甚至可以同时使用 match 语句来分解合取：</p>
<pre><code class="language-lean"><span class="boring">variable (α : Type) (p q : α → Prop)
</span>example (h : ∃ x, p x ∧ q x) : ∃ x, q x ∧ p x :=
  match h with
  | ⟨w, hpw, hqw⟩ =&gt; ⟨w, hqw, hpw⟩
</code></pre>
<!--
Lean also provides a pattern-matching ``let`` expression:
-->
<p>Lean 还提供了一个模式匹配的 <code>let</code> 表达式：</p>
<pre><code class="language-lean"><span class="boring">variable (α : Type) (p q : α → Prop)
</span>example (h : ∃ x, p x ∧ q x) : ∃ x, q x ∧ p x :=
  let ⟨w, hpw, hqw⟩ := h
  ⟨w, hqw, hpw⟩
</code></pre>
<!--
This is essentially just alternative notation for the ``match``
construct above. Lean will even allow us to use an implicit ``match``
in the ``fun`` expression:
-->
<p>这实际上是上面的 <code>match</code> 结构的替代表示法。Lean 甚至允许我们在 <code>fun</code> 表达式中使用隐含的 <code>match</code>：</p>
<pre><code class="language-lean"><span class="boring">variable (α : Type) (p q : α → Prop)
</span>example : (∃ x, p x ∧ q x) → ∃ x, q x ∧ p x :=
  fun ⟨w, hpw, hqw⟩ =&gt; ⟨w, hqw, hpw⟩
</code></pre>
<!--
We will see in [Chapter Induction and Recursion](./induction_and_recursion.md) that all these variations are
instances of a more general pattern-matching construct.

In the following example, we define ``is_even a`` as ``∃ b, a = 2 * b``,
and then we show that the sum of two even numbers is an even number.
-->
<p>我们将在<a href="./induction_and_recursion.html">归纳和递归</a>一章看到所有这些变体都是更一般的模式匹配构造的实例。</p>
<p>在下面的例子中，我们将 <code>even a</code> 定义为 <code>∃ b, a = 2 * b</code>，然后我们证明两个偶数的和是偶数。</p>
<pre><code class="language-lean">def is_even (a : Nat) := ∃ b, a = 2 * b

theorem even_plus_even (h1 : is_even a) (h2 : is_even b) : is_even (a + b) :=
  Exists.elim h1 (fun w1 (hw1 : a = 2 * w1) =&gt;
  Exists.elim h2 (fun w2 (hw2 : b = 2 * w2) =&gt;
    Exists.intro (w1 + w2)
      (calc a + b
        _ = 2 * w1 + 2 * w2 := by rw [hw1, hw2]
        _ = 2 * (w1 + w2)   := by rw [Nat.mul_add])))
</code></pre>
<!--
Using the various gadgets described in this chapter --- the match
statement, anonymous constructors, and the ``rewrite`` tactic, we can
write this proof concisely as follows:
-->
<p>使用本章描述的各种小工具——<code>match</code> 语句、匿名构造子和 <code>rewrite</code> 策略，我们可以简洁地写出如下证明：</p>
<pre><code class="language-lean"><span class="boring">def is_even (a : Nat) := ∃ b, a = 2 * b
</span>theorem even_plus_even (h1 : is_even a) (h2 : is_even b) : is_even (a + b) :=
  match h1, h2 with
  | ⟨w1, hw1⟩, ⟨w2, hw2⟩ =&gt; ⟨w1 + w2, by rw [hw1, hw2, Nat.mul_add]⟩
</code></pre>
<!--
Just as the constructive "or" is stronger than the classical "or," so,
too, is the constructive "exists" stronger than the classical
"exists". For example, the following implication requires classical
reasoning because, from a constructive standpoint, knowing that it is
not the case that every ``x`` satisfies ``¬ p`` is not the same as
having a particular ``x`` that satisfies ``p``.
-->
<p>就像构造主义的「或」比古典的「或」强，同样，构造的「存在」也比古典的「存在」强。例如，下面的推论需要经典推理，因为从构造的角度来看，知道并不是每一个 <code>x</code> 都满足 <code>¬ p</code>，并不等于有一个特定的 <code>x</code> 满足 <code>p</code>。</p>
<pre><code class="language-lean">open Classical
variable (p : α → Prop)

example (h : ¬ ∀ x, ¬ p x) : ∃ x, p x :=
  byContradiction
    (fun h1 : ¬ ∃ x, p x =&gt;
      have h2 : ∀ x, ¬ p x :=
        fun x =&gt;
        fun h3 : p x =&gt;
        have h4 : ∃ x, p x := ⟨x, h3⟩
        show False from h1 h4
      show False from h h2)
</code></pre>
<!--
What follows are some common identities involving the existential
quantifier. In the exercises below, we encourage you to prove as many
as you can. We also leave it to you to determine which are
nonconstructive, and hence require some form of classical reasoning.
-->
<p>下面是一些涉及存在量词的常见等式。在下面的练习中，我们鼓励你尽可能多写出证明。你需要判断哪些是非构造主义的，因此需要一些经典推理。</p>
<pre><code class="language-lean">open Classical

variable (α : Type) (p q : α → Prop)
variable (r : Prop)

example : (∃ x : α, r) → r := sorry
example (a : α) : r → (∃ x : α, r) := sorry
example : (∃ x, p x ∧ r) ↔ (∃ x, p x) ∧ r := sorry
example : (∃ x, p x ∨ q x) ↔ (∃ x, p x) ∨ (∃ x, q x) := sorry

example : (∀ x, p x) ↔ ¬ (∃ x, ¬ p x) := sorry
example : (∃ x, p x) ↔ ¬ (∀ x, ¬ p x) := sorry
example : (¬ ∃ x, p x) ↔ (∀ x, ¬ p x) := sorry
example : (¬ ∀ x, p x) ↔ (∃ x, ¬ p x) := sorry

example : (∀ x, p x → r) ↔ (∃ x, p x) → r := sorry
example (a : α) : (∃ x, p x → r) ↔ (∀ x, p x) → r := sorry
example (a : α) : (∃ x, r → p x) ↔ (r → ∃ x, p x) := sorry
</code></pre>
<!--
Notice that the second example and the last two examples require the
assumption that there is at least one element ``a`` of type ``α``.

Here are solutions to two of the more difficult ones:
-->
<p>注意，第二个例子和最后两个例子要求假设至少有一个类型为 <code>α</code> 的元素 <code>a</code>。</p>
<p>以下是两个比较困难的问题的解：</p>
<pre><code class="language-lean">open Classical

variable (α : Type) (p q : α → Prop)
variable (a : α)
variable (r : Prop)

example : (∃ x, p x ∨ q x) ↔ (∃ x, p x) ∨ (∃ x, q x) :=
  Iff.intro
    (fun ⟨a, (h1 : p a ∨ q a)⟩ =&gt;
      Or.elim h1
        (fun hpa : p a =&gt; Or.inl ⟨a, hpa⟩)
        (fun hqa : q a =&gt; Or.inr ⟨a, hqa⟩))
    (fun h : (∃ x, p x) ∨ (∃ x, q x) =&gt;
      Or.elim h
        (fun ⟨a, hpa⟩ =&gt; ⟨a, (Or.inl hpa)⟩)
        (fun ⟨a, hqa⟩ =&gt; ⟨a, (Or.inr hqa)⟩))

example : (∃ x, p x → r) ↔ (∀ x, p x) → r :=
  Iff.intro
    (fun ⟨b, (hb : p b → r)⟩ =&gt;
     fun h2 : ∀ x, p x =&gt;
     show r from hb (h2 b))
    (fun h1 : (∀ x, p x) → r =&gt;
     show ∃ x, p x → r from
       byCases
         (fun hap : ∀ x, p x =&gt; ⟨a, λ h' =&gt; h1 hap⟩)
         (fun hnap : ¬ ∀ x, p x =&gt;
          byContradiction
            (fun hnex : ¬ ∃ x, p x → r =&gt;
              have hap : ∀ x, p x :=
                fun x =&gt;
                byContradiction
                  (fun hnp : ¬ p x =&gt;
                    have hex : ∃ x, p x → r := ⟨x, (fun hp =&gt; absurd hp hnp)⟩
                    show False from hnex hex)
              show False from hnap hap)))
</code></pre>
<!--
More on the Proof Language
--------------------------
-->
<h2 id="多来点儿证明语法"><a class="header" href="#多来点儿证明语法">多来点儿证明语法</a></h2>
<!--
We have seen that keywords like ``fun``, ``have``, and ``show`` make
it possible to write formal proof terms that mirror the structure of
informal mathematical proofs. In this section, we discuss some
additional features of the proof language that are often convenient.

To start with, we can use anonymous "have" expressions to introduce an
auxiliary goal without having to label it. We can refer to the last
expression introduced in this way using the keyword ``this``:
-->
<p>我们已经看到像 <code>fun</code>、<code>have</code> 和 <code>show</code> 这样的关键字使得写出反映非正式数学证明结构的正式证明项成为可能。在本节中，我们将讨论证明语言的一些通常很方便的附加特性。</p>
<p>首先，我们可以使用匿名的 <code>have</code> 表达式来引入一个辅助目标，而不需要标注它。我们可以使用关键字 <code>this</code> 来引用最后一个以这种方式引入的表达式:</p>
<pre><code class="language-lean">variable (f : Nat → Nat)
variable (h : ∀ x : Nat, f x ≤ f (x + 1))

example : f 0 ≤ f 3 :=
  have : f 0 ≤ f 1 := h 0
  have : f 0 ≤ f 2 := Nat.le_trans this (h 1)
  show f 0 ≤ f 3 from Nat.le_trans this (h 2)
</code></pre>
<!--
Often proofs move from one fact to the next, so this can be effective
in eliminating the clutter of lots of labels.

When the goal can be inferred, we can also ask Lean instead to fill in
the proof by writing ``by assumption``:
-->
<p>通常证明从一个事实转移到另一个事实，所以这可以有效地消除杂乱的大量标签。</p>
<p>当目标可以推断出来时，我们也可以让 Lean 写 <code>by assumption</code> 来填写证明：</p>
<pre><code class="language-lean"><span class="boring">variable (f : Nat → Nat)
</span><span class="boring">variable (h : ∀ x : Nat, f x ≤ f (x + 1))
</span>example : f 0 ≤ f 3 :=
  have : f 0 ≤ f 1 := h 0
  have : f 0 ≤ f 2 := Nat.le_trans (by assumption) (h 1)
  show f 0 ≤ f 3 from Nat.le_trans (by assumption) (h 2)
</code></pre>
<!--
This tells Lean to use the ``assumption`` tactic, which, in turn,
proves the goal by finding a suitable hypothesis in the local
context. We will learn more about the ``assumption`` tactic in the
next chapter.

We can also ask Lean to fill in the proof by writing ``‹p›``, where
``p`` is the proposition whose proof we want Lean to find in the
context.  You can type these corner quotes using ``\f<`` and ``\f>``,
respectively. The letter "f" is for "French," since the unicode
symbols can also be used as French quotation marks. In fact, the
notation is defined in Lean as follows:
-->
<p>这告诉 Lean 使用 <code>assumption</code> 策略，反过来，通过在局部上下文中找到合适的假设来证明目标。我们将在下一章学习更多关于 <code>assumption</code> 策略的内容。</p>
<p>我们也可以通过写 <code>‹p›</code> 的形式要求 Lean 填写证明，其中 <code>p</code> 是我们希望 Lean 在上下文中找到的证明命题。你可以分别使用 <code>\f&lt;</code> 和 <code>\f&gt;</code> 输入这些角引号。字母「f」表示「French」，因为 unicode 符号也可以用作法语引号。事实上，这个符号在 Lean 中定义如下:</p>
<pre><code class="language-lean">notation &quot;‹&quot; p &quot;›&quot; =&gt; show p by assumption
</code></pre>
<!--
This approach is more robust than using ``by assumption``, because the
type of the assumption that needs to be inferred is given
explicitly. It also makes proofs more readable. Here is a more
elaborate example:
-->
<p>这种方法比使用 <code>by assumption</code> 更稳健，因为需要推断的假设类型是显式给出的。它还使证明更具可读性。这里有一个更详细的例子:</p>
<pre><code class="language-lean">variable (f : Nat → Nat)
variable (h : ∀ x : Nat, f x ≤ f (x + 1))

example : f 0 ≥ f 1 → f 1 ≥ f 2 → f 0 = f 2 :=
  fun _ : f 0 ≥ f 1 =&gt;
  fun _ : f 1 ≥ f 2 =&gt;
  have : f 0 ≥ f 2 := Nat.le_trans ‹f 1 ≥ f 2› ‹f 0 ≥ f 1›
  have : f 0 ≤ f 2 := Nat.le_trans (h 0) (h 1)
  show f 0 = f 2 from Nat.le_antisymm this ‹f 0 ≥ f 2›
</code></pre>
<!--
Keep in mind that you can use the French quotation marks in this way
to refer to *anything* in the context, not just things that were
introduced anonymously. Its use is also not limited to propositions,
though using it for data is somewhat odd:
-->
<p>你可以这样使用法语引号来指代上下文中的「任何东西」，而不仅仅是匿名引入的东西。它的使用也不局限于命题，尽管将它用于数据有点奇怪：</p>
<pre><code class="language-lean">example (n : Nat) : Nat := ‹Nat›
</code></pre>
<!--
Later, we show how you can extend the proof language using the Lean macro system.
-->
<p>稍后，我们将展示如何使用 Lean 中的宏系统扩展证明语言。</p>
<!--
Exercises
---------
-->
<h2 id="练习-1"><a class="header" href="#练习-1">练习</a></h2>
<!--
1. Prove these equivalences:
-->
<ol>
<li>证明以下等式：</li>
</ol>
<pre><code class="language-lean">variable (α : Type) (p q : α → Prop)

example : (∀ x, p x ∧ q x) ↔ (∀ x, p x) ∧ (∀ x, q x) := sorry
example : (∀ x, p x → q x) → (∀ x, p x) → (∀ x, q x) := sorry
example : (∀ x, p x) ∨ (∀ x, q x) → ∀ x, p x ∨ q x := sorry
</code></pre>
<!--
You should also try to understand why the reverse implication is not derivable in the last example.
-->
<p>你还应该想想为什么在最后一个例子中反过来是不能证明的。</p>
<!--
2. It is often possible to bring a component of a formula outside a
   universal quantifier, when it does not depend on the quantified
   variable. Try proving these (one direction of the second of these
   requires classical logic):
-->
<ol start="2">
<li>当一个公式的组成部分不依赖于被全称的变量时，通常可以把它提取出一个全称量词的范围。尝试证明这些(第二个命题中的一个方向需要经典逻辑)：</li>
</ol>
<pre><code class="language-lean">variable (α : Type) (p q : α → Prop)
variable (r : Prop)

example : α → ((∀ x : α, r) ↔ r) := sorry
example : (∀ x, p x ∨ r) ↔ (∀ x, p x) ∨ r := sorry
example : (∀ x, r → p x) ↔ (r → ∀ x, p x) := sorry
</code></pre>
<!--
3. Consider the "barber paradox," that is, the claim that in a certain
   town there is a (male) barber that shaves all and only the men who
   do not shave themselves. Prove that this is a contradiction:
-->
<ol start="3">
<li>考虑「理发师悖论」：在一个小镇里，这里有一个（男性）理发师给所有不为自己刮胡子的人刮胡子。证明这里存在矛盾：</li>
</ol>
<pre><code class="language-lean">variable (men : Type) (barber : men)
variable (shaves : men → men → Prop)

example (h : ∀ x : men, shaves barber x ↔ ¬ shaves x x) : False := sorry
</code></pre>
<!--
4. Remember that, without any parameters, an expression of type
   ``Prop`` is just an assertion. Fill in the definitions of ``prime``
   and ``Fermat_prime`` below, and construct each of the given
   assertions. For example, you can say that there are infinitely many
   primes by asserting that for every natural number ``n``, there is a
   prime number greater than ``n``. Goldbach's weak conjecture states
   that every odd number greater than 5 is the sum of three
   primes. Look up the definition of a Fermat prime or any of the
   other statements, if necessary.
-->
<ol start="4">
<li>如果没有任何参数，类型 <code>Prop</code> 的表达式只是一个断言。填入下面 <code>prime</code> 和 <code>Fermat_prime</code> 的定义，并构造每个给定的断言。例如，通过断言每个自然数 <code>n</code> 都有一个大于 <code>n</code> 的质数，你可以说有无限多个质数。哥德巴赫弱猜想指出，每一个大于5的奇数都是三个素数的和。如果有必要，请查阅费马素数的定义或其他任何资料。</li>
</ol>
<pre><code class="language-lean">def even (n : Nat) : Prop := sorry

def prime (n : Nat) : Prop := sorry

def infinitely_many_primes : Prop := sorry

def Fermat_prime (n : Nat) : Prop := sorry

def infinitely_many_Fermat_primes : Prop := sorry

def goldbach_conjecture : Prop := sorry

def Goldbach's_weak_conjecture : Prop := sorry

def Fermat's_last_theorem : Prop := sorry
</code></pre>
<!--
5. Prove as many of the identities listed in the Existential
   Quantifier section as you can.
-->
<ol start="5">
<li>尽可能多地证明存在量词一节列出的等式。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><!--
Tactics
=======
-->
<h1 id="证明策略"><a class="header" href="#证明策略">证明策略</a></h1>
<!--
In this chapter, we describe an alternative approach to constructing
proofs, using *tactics*.  A proof term is a representation of a
mathematical proof; tactics are commands, or instructions, that
describe how to build such a proof. Informally, you might begin a
mathematical proof by saying "to prove the forward direction, unfold
the definition, apply the previous lemma, and simplify." Just as these
are instructions that tell the reader how to find the relevant proof,
tactics are instructions that tell Lean how to construct a proof
term. They naturally support an incremental style of writing proofs,
in which you decompose a proof and work on goals one step at a time.

We will describe proofs that consist of sequences of tactics as
"tactic-style" proofs, to contrast with the ways of writing proof
terms we have seen so far, which we will call "term-style"
proofs. Each style has its own advantages and disadvantages. For
example, tactic-style proofs can be harder to read, because they
require the reader to predict or guess the results of each
instruction. But they can also be shorter and easier to
write. Moreover, tactics offer a gateway to using Lean's automation,
since automated procedures are themselves tactics.
-->
<p>在本章中，我们描述了另一种构建证明的方法，即使用 <strong>策略（Tactic）</strong> 。 一个证明项代表一个数学证明；策略是描述如何建立这样一个证明的命令或指令。你可以在数学证明开始时非正式地说：「为了证明条件的必要性，展开定义，应用前面的定理，并进行简化。」就像这些指令告诉读者如何构建证明一样，策略告诉 Lean 如何构建证明。它们自然而然地支持增量式的证明书写，在这种写作方式中，你将分解一个证明，并一步步地实现目标。</p>
<blockquote>
<p>译者注：tactic 和 strategy 都有策略的意思，其中 tactic 侧重细节，如排兵布阵，
strategy 面向整体，如大规模战略。试译 strategy 为「要略」，与 tactic 相区分。</p>
</blockquote>
<p>我们将把由策略序列组成的证明描述为「策略式」证明，前几章的证明我们称为「项式」证明。每种风格都有自己的优点和缺点。例如，策略式证明可能更难读，因为它们要求读者预测或猜测每条指令的结果。但它们一般更短，更容易写。此外，策略提供了一个使用 Lean 自动化的途径，因为自动化程序本身就是策略。</p>
<!--
Entering Tactic Mode
--------------------
-->
<h2 id="进入策略模式"><a class="header" href="#进入策略模式">进入策略模式</a></h2>
<!--
Conceptually, stating a theorem or introducing a ``have`` statement
creates a goal, namely, the goal of constructing a term with the
expected type. For example, the following creates the goal of
constructing a term of type ``p ∧ q ∧ p``, in a context with constants
``p q : Prop``, ``hp : p`` and ``hq : q``:
-->
<p>从概念上讲，陈述一个定理或引入一个 <code>have</code> 的声明会产生一个目标，即构造一个具有预期类型的项的目标。例如, 下面创建的目标是构建一个类型为 <code>p ∧ q ∧ p</code> 的项，条件有常量 <code>p q : Prop</code>，<code>hp : p</code> 和 <code>hq : q</code>。</p>
<pre><code class="language-lean">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p :=
  sorry
</code></pre>
<!--
You can write this goal as follows:
-->
<p>写成目标如下：</p>
<pre><code>    p : Prop, q : Prop, hp : p, hq : q ⊢ p ∧ q ∧ p
</code></pre>
<!--
Indeed, if you replace the "sorry" by an underscore in the example
above, Lean will report that it is exactly this goal that has been
left unsolved.

Ordinarily, you meet such a goal by writing an explicit term. But
wherever a term is expected, Lean allows us to insert instead a ``by
<tactics>`` block, where ``<tactics>`` is a sequence of commands,
separated by semicolons or line breaks. You can prove the theorem above
in that way:
-->
<p>事实上，如果你把上面的例子中的「sorry」换成下划线，Lean 会报告说，正是这个目标没有得到解决。</p>
<p>通常情况下，你会通过写一个明确的项来满足这样的目标。但在任何需要项的地方，Lean 允许我们插入一个 <code>by &lt;tactics&gt;</code> 块，其中 <code>&lt;tactics&gt;</code> 是一串命令，用分号或换行符分开。你可以用下面这种方式来证明上面的定理：</p>
<pre><code class="language-lean">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p :=
  by apply And.intro
     exact hp
     apply And.intro
     exact hq
     exact hp
</code></pre>
<!--
We often put the ``by`` keyword on the preceding line, and write the
example above as:
-->
<p>我们经常将 <code>by</code> 关键字放在前一行，并将上面的例子写为</p>
<pre><code class="language-lean">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p := by
  apply And.intro
  exact hp
  apply And.intro
  exact hq
  exact hp
</code></pre>
<!--
The ``apply`` tactic applies an expression, viewed as denoting a
function with zero or more arguments. It unifies the conclusion with
the expression in the current goal, and creates new goals for the
remaining arguments, provided that no later arguments depend on
them. In the example above, the command ``apply And.intro`` yields two
subgoals:
-->
<p><code>apply</code> 策略应用于一个表达式，被视为表示一个有零或多个参数的函数。它将结论与当前目标中的表达式统一起来，并为剩余的参数创建新的目标，只要后面的参数不依赖于它们。在上面的例子中，命令 <code>apply And.intro</code> 产生了两个子目标：</p>
<pre><code>    case left
    p q : Prop
    hp : p
    hq : q
    ⊢ p

    case right
    p q : Prop
    hp : p
    hq : q
    ⊢ q ∧ p
</code></pre>
<!--
The first goal is met with the command ``exact hp``. The ``exact``
command is just a variant of ``apply`` which signals that the
expression given should fill the goal exactly. It is good form to use
it in a tactic proof, since its failure signals that something has
gone wrong. It is also more robust than ``apply``, since the
elaborator takes the expected type, given by the target of the goal,
into account when processing the expression that is being applied. In
this case, however, ``apply`` would work just as well.

You can see the resulting proof term with the ``#print`` command:
-->
<p>第一个目标是通过 <code>exact hp</code> 命令来实现的。<code>exact</code> 命令只是 <code>apply</code> 的一个变体，它表示所给的表达式应该准确地填充目标。在策略证明中使用它很有益，因为它如果失败那么表明出了问题。它也比 <code>apply</code> 更稳健，因为繁饰器在处理被应用的表达式时，会考虑到目标所预期的类型。然而，在这种情况下，<code>apply</code> 也可以很好地工作。</p>
<p>你可以用<code>#print</code>命令查看所产生的证明项。</p>
<pre><code class="language-lean"><span class="boring">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p := by
</span><span class="boring"> apply And.intro
</span><span class="boring"> exact hp
</span><span class="boring"> apply And.intro
</span><span class="boring"> exact hq
</span><span class="boring"> exact hp
</span>#print test
</code></pre>
<!--
You can write a tactic script incrementally. In VS Code, you can open
a window to display messages by pressing ``Ctrl-Shift-Enter``, and
that window will then show you the current goal whenever the cursor is
in a tactic block. In Emacs, you can see the goal at the end of any
line by pressing ``C-c C-g``, or see the remaining goal in an
incomplete proof by putting the cursor after the first character of
the last tactic. If the proof is incomplete, the token ``by`` is
decorated with a red squiggly line, and the error message contains the
remaining goals.

Tactic commands can take compound expressions, not just single
identifiers. The following is a shorter version of the preceding
proof:
-->
<p>你可以循序渐进地写一个策略脚本。在VS Code中，你可以通过按<code>Ctrl-Shift-Enter</code>打开一个窗口来显示信息，然后只要光标在策略块中，该窗口就会显示当前的目标。在 Emacs 中，你可以通过按<code>C-c C-g</code>看到任何一行末尾的目标，或者通过把光标放在最后一个策略的第一个字符之后，看到一个不完整的证明中的剩余目标。如果证明是不完整的，标记 <code>by</code> 会被装饰成一条红色的斜线，错误信息中包含剩余的目标。</p>
<p>策略命令可以接受复合表达式，而不仅仅是单一标识符。下面是前面证明的一个简短版本。</p>
<pre><code class="language-lean">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p := by
  apply And.intro hp
  exact And.intro hq hp
</code></pre>
<!--
Unsurprisingly, it produces exactly the same proof term.
-->
<p>它产生了相同的证明项。</p>
<pre><code class="language-lean"><span class="boring">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p := by
</span><span class="boring"> apply And.intro hp
</span><span class="boring"> exact And.intro hq hp
</span>#print test
</code></pre>
<!--
Multiple tactic applications can be written in a single line by concatenating with a semicolon.
-->
<p>应用多个策略可以通过用分号连接写在一行中。</p>
<pre><code class="language-lean">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p := by
  apply And.intro hp; exact And.intro hq hp
</code></pre>
<!--
Tactics that may produce multiple subgoals often tag them. For
example, the tactic ``apply And.intro`` tagged the first subgoal as
``left``, and the second as ``right``. In the case of the ``apply``
tactic, the tags are inferred from the parameters' names used in the
``And.intro`` declaration. You can structure your tactics using the
notation ``case <tag> => <tactics>``. The following is a structured
version of our first tactic proof in this chapter.
-->
<p>可能产生多个子目标的策略通常对子目标进行标记。例如，<code>apply And.intro</code> 策略将第一个目标标记为 <code>left</code>，将第二个目标标记为 <code>right</code>。在 <code>apply</code> 策略的情况下，标签是从 <code>And.intro</code> 声明中使用的参数名称推断出来的。你可以使用符号 <code>case &lt;tag&gt; =&gt; &lt;tactics&gt;</code> 来结构化你的策略。下面是本章中第一个策略证明的结构化版本。</p>
<pre><code class="language-lean">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p := by
  apply And.intro
  case left =&gt; exact hp
  case right =&gt;
    apply And.intro
    case left =&gt; exact hq
    case right =&gt; exact hp
</code></pre>
<!--
You can solve the subgoal ``right`` before ``left`` using the ``case``
notation:
-->
<p>使用 <code>case</code> 标记，你也可以在 <code>left</code> 之前先解决子目标 <code>right</code>：</p>
<pre><code class="language-lean">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p := by
  apply And.intro
  case right =&gt;
    apply And.intro
    case left =&gt; exact hq
    case right =&gt; exact hp
  case left =&gt; exact hp
</code></pre>
<!--
Note that Lean hides the other goals inside the ``case`` block. We say
it is "focusing" on the selected goal.  Moreover, Lean flags an error
if the selected goal is not fully solved at the end of the ``case``
block.

For simple subgoals, it may not be worth selecting a subgoal using its
tag, but you may still want to structure the proof. Lean also provides
the "bullet" notation ``. <tactics>`` (or ``· <tactics>``) for
structuring proof.
-->
<p>注意，Lean 将其他目标隐藏在 <code>case</code> 块内。我们说它「专注」于选定的目标。 此外，如果所选目标在 <code>case</code> 块的末尾没有完全解决，Lean 会标记一个错误。</p>
<p>对于简单的子目标，可能不值得使用其标签来选择一个子目标，但你可能仍然想要结构化证明。Lean 还提供了「子弹」符号 <code>. &lt;tactics&gt;</code> 或 <code>· &lt;tactics&gt;</code>。</p>
<pre><code class="language-lean">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p := by
  apply And.intro
  . exact hp
  . apply And.intro
    . exact hq
    . exact hp
</code></pre>
<!--
Basic Tactics
-------------
-->
<h2 id="基本策略"><a class="header" href="#基本策略">基本策略</a></h2>
<!--
In addition to ``apply`` and ``exact``, another useful tactic is
``intro``, which introduces a hypothesis. What follows is an example
of an identity from propositional logic that we proved in a previous
chapter, now proved using tactics.
-->
<p>除了 <code>apply</code> 和 <code>exact</code> 之外，另一个有用的策略是 <code>intro</code>，它引入了一个假设。下面是我们在前一章中证明的命题逻辑中的一个等价性的例子，现在用策略来证明。</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := by
  apply Iff.intro
  . intro h
    apply Or.elim (And.right h)
    . intro hq
      apply Or.inl
      apply And.intro
      . exact And.left h
      . exact hq
    . intro hr
      apply Or.inr
      apply And.intro
      . exact And.left h
      . exact hr
  . intro h
    apply Or.elim h
    . intro hpq
      apply And.intro
      . exact And.left hpq
      . apply Or.inl
        exact And.right hpq
    . intro hpr
      apply And.intro
      . exact And.left hpr
      . apply Or.inr
        exact And.right hpr
</code></pre>
<!--
The ``intro`` command can more generally be used to introduce a variable of any type:
-->
<p><code>intro</code> 命令可以更普遍地用于引入任何类型的变量。</p>
<pre><code class="language-lean">example (α : Type) : α → α := by
  intro a
  exact a

example (α : Type) : ∀ x : α, x = x := by
  intro x
  exact Eq.refl x
</code></pre>
<!--
You can use it to introduce several variables:
-->
<p>你可以同时引入好几个变量：</p>
<pre><code class="language-lean">example : ∀ a b c : Nat, a = b → a = c → c = b := by
  intro a b c h₁ h₂
  exact Eq.trans (Eq.symm h₂) h₁
</code></pre>
<!--
As the ``apply`` tactic is a command for constructing function
applications interactively, the ``intro`` tactic is a command for
constructing function abstractions interactively (i.e., terms of the
form ``fun x => e``).  As with lambda abstraction notation, the
``intro`` tactic allows us to use an implicit ``match``.
-->
<p>由于 <code>apply</code> 策略是一个用于交互式构造函数应用的命令，<code>intro</code> 策略是一个用于交互式构造函数抽象的命令（即 <code>fun x =&gt; e</code> 形式的项）。 与 lambda 抽象符号一样，<code>intro</code> 策略允许我们使用隐式的 <code>match</code>。</p>
<pre><code class="language-lean">example (α : Type) (p q : α → Prop) : (∃ x, p x ∧ q x) → ∃ x, q x ∧ p x := by
  intro ⟨w, hpw, hqw⟩
  exact ⟨w, hqw, hpw⟩
</code></pre>
<!--
You can also provide multiple alternatives like in the ``match`` expression.
-->
<p>就像 <code>match</code> 表达式一样，你也可以提供多个选项。</p>
<pre><code class="language-lean">example (α : Type) (p q : α → Prop) : (∃ x, p x ∨ q x) → ∃ x, q x ∨ p x := by
  intro
  | ⟨w, Or.inl h⟩ =&gt; exact ⟨w, Or.inr h⟩
  | ⟨w, Or.inr h⟩ =&gt; exact ⟨w, Or.inl h⟩
</code></pre>
<!--
The ``intros`` tactic can be used without any arguments, in which
case, it chooses names and introduces as many variables as it can. You
will see an example of this in a moment.

The ``assumption`` tactic looks through the assumptions in context of
the current goal, and if there is one matching the conclusion, it
applies it.
-->
<p><code>intros</code> 策略可以在没有任何参数的情况下使用，在这种情况下，它选择名字并尽可能多地引入变量。稍后你会看到一个例子。</p>
<p><code>assumption</code> 策略在当前目标的背景下查看假设，如果有一个与结论相匹配的假设，它就会应用这个假设。</p>
<!--
```lean
example (x y z w : Nat) (h₁ : x = y) (h₂ : y = z) (h₃ : z = w) : x = w := by
  apply Eq.trans h₁
  apply Eq.trans h₂
  assumption   -- applied h₃
```
-->
<pre><code class="language-lean">example (x y z w : Nat) (h₁ : x = y) (h₂ : y = z) (h₃ : z = w) : x = w := by
  apply Eq.trans h₁
  apply Eq.trans h₂
  assumption   -- 应用h₃
</code></pre>
<!--
It will unify metavariables in the conclusion if necessary:
-->
<p>若有必要，它会在结论中统一元变量。</p>
<!--
```lean
example (x y z w : Nat) (h₁ : x = y) (h₂ : y = z) (h₃ : z = w) : x = w := by
  apply Eq.trans
  assumption      -- solves x = ?b with h₁
  apply Eq.trans
  assumption      -- solves y = ?h₂.b with h₂
  assumption      -- solves z = w with h₃
```
-->
<pre><code class="language-lean">example (x y z w : Nat) (h₁ : x = y) (h₂ : y = z) (h₃ : z = w) : x = w := by
  apply Eq.trans
  assumption      -- 求解了 x = ?b with h₁
  apply Eq.trans
  assumption      -- 求解了 y = ?h₂.b with h₂
  assumption      -- 求解了 z = w with h₃
</code></pre>
<!--
The following example uses the ``intros`` command to introduce the three variables and two hypotheses automatically:
-->
<p>下面的例子使用 <code>intros</code> 命令来自动引入三个变量和两个假设：</p>
<pre><code class="language-lean">example : ∀ a b c : Nat, a = b → a = c → c = b := by
  intros
  apply Eq.trans
  apply Eq.symm
  assumption
  assumption
</code></pre>
<!--
Note that names automatically generated by Lean are inaccessible by default. The motivation is to
ensure your tactic proofs do not rely on automatically generated names, and are consequently more robust.
However, you can use the combinator ``unhygienic`` to disable this restriction.
-->
<p>请注意，由 Lean 自动生成的名称在默认情况下是不可访问的。其动机是为了确保你的策略证明不依赖于自动生成的名字，并因此而更加强大。然而，你可以使用组合器 <code>unhygienic</code> 来禁用这一限制。</p>
<pre><code class="language-lean">example : ∀ a b c : Nat, a = b → a = c → c = b := by unhygienic
  intros
  apply Eq.trans
  apply Eq.symm
  exact a_2
  exact a_1
</code></pre>
<!--
You can also use the ``rename_i`` tactic to rename the most recent inaccessible names in your context.
In the following example, the tactic ``rename_i h1 _ h2`` renames two of the last three hypotheses in
your context.
-->
<p>你也可以使用 <code>rename_i</code> 策略来重命名你的上下文中最近的不能访问的名字。在下面的例子中，策略 <code>rename_i h1 _ h2</code> 在你的上下文中重命名了三个假设中的两个。</p>
<pre><code class="language-lean">example : ∀ a b c d : Nat, a = b → a = d → a = c → c = b := by
  intros
  rename_i h1 _ h2
  apply Eq.trans
  apply Eq.symm
  exact h2
  exact h1
</code></pre>
<!--
The ``rfl`` tactic is syntactic sugar for ``exact rfl``.
-->
<p><code>rfl</code> 策略是 <code>exact rfl</code> 的语法糖。</p>
<pre><code class="language-lean">example (y : Nat) : (fun x : Nat =&gt; 0) y = 0 :=
  by rfl
</code></pre>
<!--
The ``repeat`` combinator can be used to apply a tactic several times.
-->
<p><code>repeat</code> 组合器可以多次使用一个策略。</p>
<pre><code class="language-lean">example : ∀ a b c : Nat, a = b → a = c → c = b := by
  intros
  apply Eq.trans
  apply Eq.symm
  repeat assumption
</code></pre>
<!--
Another tactic that is sometimes useful is the ``revert`` tactic,
which is, in a sense, an inverse to ``intro``.
-->
<p>另一个有时很有用的策略是还原 <code>revert</code> 策略，从某种意义上说，它是对 <code>intro</code> 的逆。</p>
<pre><code class="language-lean">example (x : Nat) : x = x := by
  revert x
  -- goal is ⊢ ∀ (x : Nat), x = x
  intro y
  -- goal is y : Nat ⊢ y = y
  rfl
</code></pre>
<!--
Moving a hypothesis into the goal yields an implication:
-->
<p>将一个假设还原到目标中会产生一个蕴含。</p>
<pre><code class="language-lean">example (x y : Nat) (h : x = y) : y = x := by
  revert h
  -- goal is x y : Nat ⊢ x = y → y = x
  intro h₁
  -- goal is x y : Nat, h₁ : x = y ⊢ y = x
  apply Eq.symm
  assumption
</code></pre>
<!--
But ``revert`` is even more clever, in that it will revert not only an
element of the context but also all the subsequent elements of the
context that depend on it. For example, reverting ``x`` in the example
above brings ``h`` along with it:
-->
<p>但是 <code>revert</code> 更聪明，因为它不仅会还原上下文中的一个元素，还会还原上下文中所有依赖它的后续元素。例如，在上面的例子中，还原 <code>x</code> 会带来 <code>h</code>。</p>
<pre><code class="language-lean">example (x y : Nat) (h : x = y) : y = x := by
  revert x
  -- goal is y : Nat ⊢ ∀ (x : Nat), x = y → y = x
  intros
  apply Eq.symm
  assumption
</code></pre>
<!--
You can also revert multiple elements of the context at once:
-->
<p>你还可以一次性还原多个元素：</p>
<pre><code class="language-lean">example (x y : Nat) (h : x = y) : y = x := by
  revert x y
  -- goal is ⊢ ∀ (x y : Nat), x = y → y = x
  intros
  apply Eq.symm
  assumption
</code></pre>
<!--
You can only ``revert`` an element of the local context, that is, a
local variable or hypothesis. But you can replace an arbitrary
expression in the goal by a fresh variable using the ``generalize``
tactic.
-->
<p>你只能 <code>revert</code> 局部环境中的一个元素，也就是一个局部变量或假设。但是你可以使用泛化 <code>generalize</code> 策略将目标中的任意表达式替换为新的变量。</p>
<pre><code class="language-lean">example : 3 = 3 := by
  generalize 3 = x
  -- goal is x : Nat ⊢ x = x
  revert x
  -- goal is ⊢ ∀ (x : Nat), x = x
  intro y
  -- goal is y : Nat ⊢ y = y
  rfl
</code></pre>
<!--
The mnemonic in the notation above is that you are generalizing the
goal by setting ``3`` to an arbitrary variable ``x``. Be careful: not
every generalization preserves the validity of the goal. Here,
``generalize`` replaces a goal that could be proved using
``rfl`` with one that is not provable:
-->
<p>上述符号的记忆法是，你通过将 <code>3</code> 设定为任意变量 <code>x</code> 来泛化目标。要注意：不是每一个泛化都能保留目标的有效性。这里，<code>generalize</code> 用一个无法证明的目标取代了一个可以用 <code>rfl</code> 证明的目标。</p>
<pre><code class="language-lean">example : 2 + 3 = 5 := by
  generalize 3 = x
  -- goal is x : Nat ⊢ 2 + x = 5
  admit
</code></pre>
<!--
In this example, the ``admit`` tactic is the analogue of the ``sorry``
proof term. It closes the current goal, producing the usual warning
that ``sorry`` has been used. To preserve the validity of the previous
goal, the ``generalize`` tactic allows us to record the fact that
``3`` has been replaced by ``x``. All you need to do is to provide a
label, and ``generalize`` uses it to store the assignment in the local
context:
-->
<p>在这个例子中，<code>admit</code> 策略是 <code>sorry</code> 证明项的类似物。它关闭了当前的目标，产生了通常的警告：使用了 <code>sorry</code>。为了保持之前目标的有效性，<code>generalize</code> 策略允许我们记录 <code>3</code> 已经被 <code>x</code> 所取代的事实。你所需要做的就是提供一个标签，<code>generalize</code> 使用它来存储局部上下文中的赋值。</p>
<pre><code class="language-lean">example : 2 + 3 = 5 := by
  generalize h : 3 = x
  -- goal is x : Nat, h : 3 = x ⊢ 2 + x = 5
  rw [← h]
</code></pre>
<!--
Here the ``rewrite`` tactic, abbreviated ``rw``, uses ``h`` to replace
``x`` by ``3`` again. The ``rewrite`` tactic will be discussed below.
-->
<p>这里 <code>rewrite</code> 策略，缩写为 <code>rw</code>，用 <code>h</code> 把 <code>x</code> 用 <code>3</code> 换了回来。<code>rewrite</code> 策略下文将继续讨论。</p>
<!--
More Tactics
------------
-->
<h2 id="更多策略"><a class="header" href="#更多策略">更多策略</a></h2>
<!--
Some additional tactics are useful for constructing and destructing
propositions and data. For example, when applied to a goal of the form
``p ∨ q``, you use tactics such as ``apply Or.inl`` and ``apply
Or.inr``.  Conversely, the ``cases`` tactic can be used to decompose a
disjunction.
-->
<p>一些额外的策略对于建构和析构命题以及数据很有用。例如，当应用于形式为 <code>p ∨ q</code> 的目标时，你可以使用 <code>apply Or.inl</code> 和 <code>apply Or.inr</code> 等策略。 反之，<code>cases</code> 策略可以用来分解一个析取。</p>
<pre><code class="language-lean">example (p q : Prop) : p ∨ q → q ∨ p := by
  intro h
  cases h with
  | inl hp =&gt; apply Or.inr; exact hp
  | inr hq =&gt; apply Or.inl; exact hq
</code></pre>
<!--
Note that the syntax is similar to the one used in `match` expressions.
The new subgoals can be solved in any order.
-->
<p>注意，该语法与 <code>match</code> 表达式中使用的语法相似。新的子目标可以按任何顺序解决。</p>
<pre><code class="language-lean">example (p q : Prop) : p ∨ q → q ∨ p := by
  intro h
  cases h with
  | inr hq =&gt; apply Or.inl; exact hq
  | inl hp =&gt; apply Or.inr; exact hp
</code></pre>
<!--
You can also use a (unstructured) ``cases`` without the ``with`` and a tactic
for each alternative.
-->
<p>你也可以使用一个（非结构化的）<code>cases</code>，而不使用 <code>with</code>，并为每个备选情况制定一个策略。</p>
<pre><code class="language-lean">example (p q : Prop) : p ∨ q → q ∨ p := by
  intro h
  cases h
  apply Or.inr
  assumption
  apply Or.inl
  assumption
</code></pre>
<!--
The (unstructured) ``cases`` is particularly useful when you can close several
subgoals using the same tactic.
-->
<p>（非结构化的）<code>cases</code> 在你可以用同一个策略来解决子任务时格外有用。</p>
<pre><code class="language-lean">example (p : Prop) : p ∨ p → p := by
  intro h
  cases h
  repeat assumption
</code></pre>
<!--
You can also use the combinator ``tac1 <;> tac2`` to apply ``tac2`` to each
subgoal produced by tactic ``tac1``.
-->
<p>你也可以使用组合器 <code>tac1 &lt;;&gt; tac2</code>，将 <code>tac2</code> 应用于策略 <code>tac1</code> 产生的每个子目标。</p>
<pre><code class="language-lean">example (p : Prop) : p ∨ p → p := by
  intro h
  cases h &lt;;&gt; assumption
</code></pre>
<!--
You can combine the unstructured ``cases`` tactic with the ``case`` and ``.`` notation.
-->
<p>你可以与 <code>.</code> 符号相结合使用非结构化的 <code>cases</code> 策略。</p>
<pre><code class="language-lean">example (p q : Prop) : p ∨ q → q ∨ p := by
  intro h
  cases h
  . apply Or.inr
    assumption
  . apply Or.inl
    assumption

example (p q : Prop) : p ∨ q → q ∨ p := by
  intro h
  cases h
  case inr h =&gt;
    apply Or.inl
    assumption
  case inl h =&gt;
    apply Or.inr
    assumption

example (p q : Prop) : p ∨ q → q ∨ p := by
  intro h
  cases h
  case inr h =&gt;
    apply Or.inl
    assumption
  . apply Or.inr
    assumption
</code></pre>
<!--
The ``cases`` tactic can also be used to
decompose a conjunction.
-->
<p><code>cases</code> 策略也被用来分解一个析取。</p>
<pre><code class="language-lean">example (p q : Prop) : p ∧ q → q ∧ p := by
  intro h
  cases h with
  | intro hp hq =&gt; constructor; exact hq; exact hp
</code></pre>
<!--
In this example, there is only one goal after the ``cases`` tactic is
applied, with ``h : p ∧ q`` replaced by a pair of assumptions,
``hp : p`` and ``hq : q``. The ``constructor`` tactic applies the unique
constructor for conjunction, ``And.intro``. With these tactics, an
example from the previous section can be rewritten as follows:
-->
<p>在这个例子中，应用 <code>cases</code> 策略后只有一个目标，<code>h : p ∧ q</code> 被一对假设取代，<code>hp : p</code> 和 <code>hq : q</code>。<code>constructor</code> 策略应用了唯一一个合取构造子 <code>And.intro</code>。有了这些策略，上一节的一个例子可以改写如下。</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := by
  apply Iff.intro
  . intro h
    cases h with
    | intro hp hqr =&gt;
      cases hqr
      . apply Or.inl; constructor &lt;;&gt; assumption
      . apply Or.inr; constructor &lt;;&gt; assumption
  . intro h
    cases h with
    | inl hpq =&gt;
      cases hpq with
      | intro hp hq =&gt; constructor; exact hp; apply Or.inl; exact hq
    | inr hpr =&gt;
      cases hpr with
      | intro hp hr =&gt; constructor; exact hp; apply Or.inr; exact hr
</code></pre>
<!--
You will see in [Chapter Inductive Types](./inductive_types.md) that
these tactics are quite general. The ``cases`` tactic can be used to
decompose any element of an inductively defined type; ``constructor``
always applies the first applicable constructor of an inductively defined type.
For example, you can use ``cases`` and ``constructor`` with an existential quantifier:
-->
<p>你将在<a href="./inductive_types.html">归纳类型</a>一章中看到，这些策略是相当通用的。<code>cases</code> 策略可以用来分解递归定义类型的任何元素；<code>constructor</code> 总是应用递归定义类型的第一个适用构造子。例如，你可以使用 <code>cases</code> 和 <code>constructor</code> 与一个存在量词：</p>
<pre><code class="language-lean">example (p q : Nat → Prop) : (∃ x, p x) → ∃ x, p x ∨ q x := by
  intro h
  cases h with
  | intro x px =&gt; constructor; apply Or.inl; exact px
</code></pre>
<!--
Here, the ``constructor`` tactic leaves the first component of the
existential assertion, the value of ``x``, implicit. It is represented
by a metavariable, which should be instantiated later on. In the
previous example, the proper value of the metavariable is determined
by the tactic ``exact px``, since ``px`` has type ``p x``. If you want
to specify a witness to the existential quantifier explicitly, you can
use the ``exists`` tactic instead:
-->
<p>在这里，<code>constructor</code> 策略将存在性断言的第一个组成部分，即 <code>x</code> 的值，保留为隐式的。它是由一个元变量表示的，这个元变量以后应该被实例化。在前面的例子中，元变量的正确值是由策略 <code>exact px</code> 决定的，因为 <code>px</code> 的类型是 <code>p x</code>。如果你想明确指定存在量词的存在者，你可以使用 <code>exists</code> 策略来代替。</p>
<pre><code class="language-lean">example (p q : Nat → Prop) : (∃ x, p x) → ∃ x, p x ∨ q x := by
  intro h
  cases h with
  | intro x px =&gt; exists x; apply Or.inl; exact px
</code></pre>
<!--
Here is another example:
-->
<p>另一个例子：</p>
<pre><code class="language-lean">example (p q : Nat → Prop) : (∃ x, p x ∧ q x) → ∃ x, q x ∧ p x := by
  intro h
  cases h with
  | intro x hpq =&gt;
    cases hpq with
    | intro hp hq =&gt;
      exists x
</code></pre>
<!--
These tactics can be used on data just as well as propositions. In the
next example, they are used to define functions which swap the
components of the product and sum types:
-->
<p>这些策略既可以用在命题上，也可以用在数上。在下面的两个例子中，它们被用来定义交换乘法和加法类型组件的函数：</p>
<pre><code class="language-lean">def swap_pair : α × β → β × α := by
  intro p
  cases p
  constructor &lt;;&gt; assumption

def swap_sum : Sum α β → Sum β α := by
  intro p
  cases p
  . apply Sum.inr; assumption
  . apply Sum.inl; assumption
</code></pre>
<!--
Note that up to the names we have chosen for the variables, the
definitions are identical to the proofs of the analogous propositions
for conjunction and disjunction. The ``cases`` tactic will also do a
case distinction on a natural number:
-->
<p>在我们为变量选择的名称之前，它们的定义与有关合取和析取的类似命题的证明是相同的。<code>cases</code> 策略也会对自然数进行逐情况区分：</p>
<pre><code class="language-lean">open Nat
example (P : Nat → Prop) (h₀ : P 0) (h₁ : ∀ n, P (succ n)) (m : Nat) : P m := by
  cases m with
  | zero    =&gt; exact h₀
  | succ m' =&gt; exact h₁ m'
</code></pre>
<!--
The ``cases`` tactic, and its companion, the ``induction`` tactic, are discussed in greater detail in
the [Tactics for Inductive Types](./inductive_types.md#tactics-for-inductive-types) section.

The ``contradiction`` tactic searches for a contradiction among the hypotheses of the current goal:
-->
<p><code>cases</code> 策略伙同 <code>induction</code> 策略将在<a href="./inductive_types.html#_tactics_for_inductive_types">归纳类型的策略</a>一节中详述。</p>
<p><code>contradiction</code> 策略搜索当前目标的假设中的矛盾：</p>
<pre><code class="language-lean">example (p q : Prop) : p ∧ ¬ p → q := by
  intro h
  cases h
  contradiction
</code></pre>
<!--
You can also use ``match`` in tactic blocks.
-->
<p>你也可以在策略块中使用 <code>match</code>：</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := by
  apply Iff.intro
  . intro h
    match h with
    | ⟨_, Or.inl _⟩ =&gt; apply Or.inl; constructor &lt;;&gt; assumption
    | ⟨_, Or.inr _⟩ =&gt; apply Or.inr; constructor &lt;;&gt; assumption
  . intro h
    match h with
    | Or.inl ⟨hp, hq⟩ =&gt; constructor; exact hp; apply Or.inl; exact hq
    | Or.inr ⟨hp, hr⟩ =&gt; constructor; exact hp; apply Or.inr; exact hr
</code></pre>
<!--
You can "combine" ``intro h`` with ``match h ...`` and write the previous examples as follows
-->
<p>你可以将 <code>intro h</code> 与 <code>match h ...</code> 结合起来，然后上例就可以如下地写出：</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := by
  apply Iff.intro
  . intro
    | ⟨hp, Or.inl hq⟩ =&gt; apply Or.inl; constructor &lt;;&gt; assumption
    | ⟨hp, Or.inr hr⟩ =&gt; apply Or.inr; constructor &lt;;&gt; assumption
  . intro
    | Or.inl ⟨hp, hq⟩ =&gt; constructor; assumption; apply Or.inl; assumption
    | Or.inr ⟨hp, hr⟩ =&gt; constructor; assumption; apply Or.inr; assumption
</code></pre>
<!--
Structuring Tactic Proofs
-------------------------
-->
<h2 id="结构化策略证明"><a class="header" href="#结构化策略证明">结构化策略证明</a></h2>
<!--
Tactics often provide an efficient way of building a proof, but long
sequences of instructions can obscure the structure of the
argument. In this section, we describe some means that help provide
structure to a tactic-style proof, making such proofs more readable
and robust.

One thing that is nice about Lean's proof-writing syntax is that it is
possible to mix term-style and tactic-style proofs, and pass between
the two freely. For example, the tactics ``apply`` and ``exact``
expect arbitrary terms, which you can write using ``have``, ``show``,
and so on. Conversely, when writing an arbitrary Lean term, you can
always invoke the tactic mode by inserting a ``by``
block. The following is a somewhat toy example:
-->
<p>策略通常提供了建立证明的有效方法，但一长串指令会掩盖论证的结构。在这一节中，我们将描述一些有助于为策略式证明提供结构的方法，使这种证明更易读，更稳健。</p>
<p>Lean 的证明写作语法的一个优点是，它可以混合项式和策略式证明，并在两者之间自由转换。例如，策略 <code>apply</code> 和 <code>exact</code> 可以传入任意的项，你可以用 <code>have</code>，<code>show</code> 等等来写这些项。反之，当写一个任意的 Lean 项时，你总是可以通过插入一个 <code>by</code> 块来调用策略模式。下面是一个简易例子：</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) → (p ∧ q) ∨ (p ∧ r) := by
  intro h
  exact
    have hp : p := h.left
    have hqr : q ∨ r := h.right
    show (p ∧ q) ∨ (p ∧ r) by
      cases hqr with
      | inl hq =&gt; exact Or.inl ⟨hp, hq⟩
      | inr hr =&gt; exact Or.inr ⟨hp, hr⟩
</code></pre>
<!--
The following is a more natural example:
-->
<p>更自然一点：</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := by
  apply Iff.intro
  . intro h
    cases h.right with
    | inl hq =&gt; exact Or.inl ⟨h.left, hq⟩
    | inr hr =&gt; exact Or.inr ⟨h.left, hr⟩
  . intro h
    cases h with
    | inl hpq =&gt; exact ⟨hpq.left, Or.inl hpq.right⟩
    | inr hpr =&gt; exact ⟨hpr.left, Or.inr hpr.right⟩
</code></pre>
<!--
In fact, there is a ``show`` tactic, which is similar to the
``show`` expression in a proof term. It simply declares the type of the
goal that is about to be solved, while remaining in tactic
mode.
-->
<p>事实上，有一个 <code>show</code> 策略，它类似于证明项中的 <code>show</code> 表达式。它只是简单地声明即将被解决的目标的类型，同时保持策略模式。</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := by
  apply Iff.intro
  . intro h
    cases h.right with
    | inl hq =&gt;
      show (p ∧ q) ∨ (p ∧ r)
      exact Or.inl ⟨h.left, hq⟩
    | inr hr =&gt;
      show (p ∧ q) ∨ (p ∧ r)
      exact Or.inr ⟨h.left, hr⟩
  . intro h
    cases h with
    | inl hpq =&gt;
      show p ∧ (q ∨ r)
      exact ⟨hpq.left, Or.inl hpq.right⟩
    | inr hpr =&gt;
      show p ∧ (q ∨ r)
      exact ⟨hpr.left, Or.inr hpr.right⟩
</code></pre>
<!--
The ``show`` tactic can actually be used to rewrite a goal to something definitionally equivalent:
-->
<p><code>show</code> 策略其实可以被用来重写一些定义等价的目标：</p>
<pre><code class="language-lean">example (n : Nat) : n + 1 = Nat.succ n := by
  show Nat.succ n = Nat.succ n
  rfl
</code></pre>
<!--
There is also a ``have`` tactic, which introduces a new subgoal, just as when writing proof terms:
-->
<p>还有一个 <code>have</code> 策略，它引入了一个新的子目标，就像写证明项时一样。</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) → (p ∧ q) ∨ (p ∧ r) := by
  intro ⟨hp, hqr⟩
  show (p ∧ q) ∨ (p ∧ r)
  cases hqr with
  | inl hq =&gt;
    have hpq : p ∧ q := And.intro hp hq
    apply Or.inl
    exact hpq
  | inr hr =&gt;
    have hpr : p ∧ r := And.intro hp hr
    apply Or.inr
    exact hpr
</code></pre>
<!--
As with proof terms, you can omit the label in the ``have`` tactic, in
which case, the default label ``this`` is used:
-->
<p>与证明项一样，你可以省略 <code>have</code> 策略中的标签，在这种情况下，将使用默认标签 <code>this</code>：</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) → (p ∧ q) ∨ (p ∧ r) := by
  intro ⟨hp, hqr⟩
  show (p ∧ q) ∨ (p ∧ r)
  cases hqr with
  | inl hq =&gt;
    have : p ∧ q := And.intro hp hq
    apply Or.inl
    exact this
  | inr hr =&gt;
    have : p ∧ r := And.intro hp hr
    apply Or.inr
    exact this
</code></pre>
<!--
The types in a ``have`` tactic can be omitted, so you can write ``have
hp := h.left`` and ``have hqr := h.right``.  In fact, with this
notation, you can even omit both the type and the label, in which case
the new fact is introduced with the label ``this``.
-->
<p><code>have</code> 策略中的类型可以省略，所以你可以写 <code>have hp := h.left</code> 和 <code>have hqr := h.right</code>。 事实上，使用这种符号，你甚至可以省略类型和标签，在这种情况下，新的事实是用标签 <code>this</code> 引入的。</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) → (p ∧ q) ∨ (p ∧ r) := by
  intro ⟨hp, hqr⟩
  cases hqr with
  | inl hq =&gt;
    have := And.intro hp hq
    apply Or.inl; exact this
  | inr hr =&gt;
    have := And.intro hp hr
    apply Or.inr; exact this
</code></pre>
<!--
Lean also has a ``let`` tactic, which is similar to the ``have``
tactic, but is used to introduce local definitions instead of
auxiliary facts. It is the tactic analogue of a ``let`` in a proof
term.
-->
<p>Lean 还有一个 <code>let</code> 策略，与 <code>have</code> 策略类似，但用于引入局部定义而不是辅助事实。它是证明项中 <code>let</code> 的策略版。</p>
<pre><code class="language-lean">example : ∃ x, x + 2 = 8 := by
  let a : Nat := 3 * 2
  exists a
</code></pre>
<!--
As with ``have``, you can leave the type implicit by writing ``let a
:= 3 * 2``. The difference between ``let`` and ``have`` is that
``let`` introduces a local definition in the context, so that the
definition of the local declaration can be unfolded in the proof.

We have used ``.`` to create nested tactic blocks.  In a nested block,
Lean focuses on the first goal, and generates an error if it has not
been fully solved at the end of the block. This can be helpful in
indicating the separate proofs of multiple subgoals introduced by a
tactic. The notation ``.`` is whitespace sensitive and relies on the indentation
to detect whether the tactic block ends. Alternatively, you can
define tactic blocks using curly braces and semicolons.
-->
<p>和 <code>have</code> 一样，你可以通过写 <code>let a := 3 * 2</code> 来保留类型为隐式。<code>let</code> 和 <code>have</code> 的区别在于，<code>let</code> 在上下文中引入了一个局部定义，因此局部声明的定义可以在证明中展开。</p>
<p>我们使用了<code>.</code>来创建嵌套的策略块。 在一个嵌套块中，Lean 专注于第一个目标，如果在该块结束时还没有完全解决，就会产生一个错误。这对于表明一个策略所引入的多个子目标的单独证明是有帮助的。符号 <code>.</code> 是对空格敏感的，并且依靠缩进来检测策略块是否结束。另外，你也可以用大括号和分号来定义策略块。</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := by
  apply Iff.intro
  { intro h;
    cases h.right;
    { show (p ∧ q) ∨ (p ∧ r);
      exact Or.inl ⟨h.left, ‹q›⟩ }
    { show (p ∧ q) ∨ (p ∧ r);
      exact Or.inr ⟨h.left, ‹r›⟩ } }
  { intro h;
    cases h;
    { show p ∧ (q ∨ r);
      rename_i hpq;
      exact ⟨hpq.left, Or.inl hpq.right⟩ }
    { show p ∧ (q ∨ r);
      rename_i hpr;
      exact ⟨hpr.left, Or.inr hpr.right⟩ } }
</code></pre>
<!--
It is useful to use indentation to structure proof: every time a tactic
leaves more than one subgoal, we separate the remaining subgoals by
enclosing them in blocks and indenting.  Thus if the application of
theorem ``foo`` to a single goal produces four subgoals, one would
expect the proof to look like this:
-->
<p>使用缩进来构造证明很有用：每次一个策略留下一个以上的子目标时，我们通过将它们封装在块中并缩进来分隔剩下的子目标。因此，如果将定理 <code>foo</code> 应用于一个目标产生了四个子目标，那么我们就可以期待这样的证明：</p>
<pre><code>  apply foo
  . &lt;proof of first goal&gt;
  . &lt;proof of second goal&gt;
  . &lt;proof of third goal&gt;
  . &lt;proof of final goal&gt;
</code></pre>
<!--
or
-->
<p>或</p>
<pre><code>  apply foo
  case &lt;tag of first goal&gt;  =&gt; &lt;proof of first goal&gt;
  case &lt;tag of second goal&gt; =&gt; &lt;proof of second goal&gt;
  case &lt;tag of third goal&gt;  =&gt; &lt;proof of third goal&gt;
  case &lt;tag of final goal&gt;  =&gt; &lt;proof of final goal&gt;
</code></pre>
<!--
or
-->
<p>或</p>
<pre><code>  apply foo
  { &lt;proof of first goal&gt;  }
  { &lt;proof of second goal&gt; }
  { &lt;proof of third goal&gt;  }
  { &lt;proof of final goal&gt;  }
</code></pre>
<!--
Tactic Combinators
------------------
-->
<h2 id="策略组合器"><a class="header" href="#策略组合器">策略组合器</a></h2>
<!--
*Tactic combinators* are operations that form new tactics from old
ones. A sequencing combinator is already implicit in the ``by`` block:
-->
<p><strong>策略组合器</strong> 是由旧策略形成新策略的操作。<code>by</code> 隐含了一个序列组合器：</p>
<pre><code class="language-lean">example (p q : Prop) (hp : p) : p ∨ q :=
  by apply Or.inl; assumption
</code></pre>
<!--
Here, ``apply Or.inl; assumption`` is functionally equivalent to a
single tactic which first applies ``apply Or.inl`` and then applies
``assumption``.

In ``t₁ <;> t₂``, the ``<;>`` operator provides a *parallel* version of the sequencing operation:
``t₁`` is applied to the current goal, and then ``t₂`` is applied to *all* the resulting subgoals:
-->
<p>这里，<code>apply Or.inl; assumption</code>在功能上等同于一个单独的策略，它首先应用<code>apply Or.inl</code>，然后应用 <code>assumption</code>。</p>
<p>在<code>t₁ &lt;;&gt; t₂</code>中，<code>&lt;;&gt;</code>操作符提供了一个<em>并行</em>的序列操作。<code>t₁</code>被应用于当前目标，然后<code>t₂</code>被应用于<em>所有</em>产生的子目标：</p>
<pre><code class="language-lean">example (p q : Prop) (hp : p) (hq : q) : p ∧ q :=
  by constructor &lt;;&gt; assumption
</code></pre>
<!--
This is especially useful when the resulting goals can be finished off
in a uniform way, or, at least, when it is possible to make progress
on all of them uniformly.

The ``first | t₁ | t₂ | ... | tₙ`` applies each `tᵢ` until one succeeds, or else fails:
-->
<p>当所产生的目标能够以统一的方式完成时，或者，至少，当有可能以统一的方式在所有的目标上取得进展时，这就特别有用。</p>
<p><code>first | t₁ | t₂ | ... | tₙ</code> 应用每$1 $2，直到其中一个成功，否则就失败：</p>
<pre><code class="language-lean">example (p q : Prop) (hp : p) : p ∨ q := by
  first | apply Or.inl; assumption | apply Or.inr; assumption

example (p q : Prop) (hq : q) : p ∨ q := by
  first | apply Or.inl; assumption | apply Or.inr; assumption
</code></pre>
<!--
In the first example, the left branch succeeds, whereas in the second one, it is the right one that succeeds.
In the next three examples, the same compound tactic succeeds in each case.
-->
<p>在第一个例子中，左分支成功了，而在第二个例子中，右分支成功了。在接下来的三个例子中，同样的复合策略在每种情况下都能成功。</p>
<pre><code class="language-lean">example (p q r : Prop) (hp : p) : p ∨ q ∨ r :=
  by repeat (first | apply Or.inl; assumption | apply Or.inr | assumption)

example (p q r : Prop) (hq : q) : p ∨ q ∨ r :=
  by repeat (first | apply Or.inl; assumption | apply Or.inr | assumption)

example (p q r : Prop) (hr : r) : p ∨ q ∨ r :=
  by repeat (first | apply Or.inl; assumption | apply Or.inr | assumption)
</code></pre>
<!--
The tactic tries to solve the left disjunct immediately by assumption;
if that fails, it tries to focus on the right disjunct; and if that
doesn't work, it invokes the assumption tactic.

You will have no doubt noticed by now that tactics can fail. Indeed,
it is the "failure" state that causes the *first* combinator to
backtrack and try the next tactic. The ``try`` combinator builds a
tactic that always succeeds, though possibly in a trivial way:
``try t`` executes ``t`` and reports success, even if ``t`` fails. It is
equivalent to ``first | t | skip``, where ``skip`` is a tactic that does
nothing (and succeeds in doing so). In the next example, the second
``constructor`` succeeds on the right conjunct ``q ∧ r`` (remember that
disjunction and conjunction associate to the right) but fails on the
first. The ``try`` tactic ensures that the sequential composition
succeeds.
-->
<p>该策略试图通过假设立即解决左边的析取项；如果失败，它就试图关注右边的析取项；如果不成功，它就调用假设策略。</p>
<p>毫无疑问，策略可能会失败。事实上，正是这种「失败」状态导致 <code>first</code> 组合器回溯并尝试下一个策略。<code>try</code> 组合器建立了一个总是成功的策略，尽管可能是以一种平凡的方式：<code>try t</code> 执行 <code>t</code> 并报告成功，即使 <code>t</code> 失败。它等同于 <code>first | t | skip</code>，其中 <code>skip</code> 是一个什么都不做的策略（并且成功地做到了「什么都不做」）。在下一个例子中，第二个 <code>constructor</code> 在右边的合取项 <code>q ∧ r</code> 上成功了（注意，合取和析取是右结合的），但在第一个合取项上失败。<code>try</code> 策略保证了序列组合的成功。</p>
<pre><code class="language-lean">example (p q r : Prop) (hp : p) (hq : q) (hr : r) : p ∧ q ∧ r := by
  constructor &lt;;&gt; (try constructor) &lt;;&gt; assumption
</code></pre>
<!--
Be careful: ``repeat (try t)`` will loop forever, because the inner tactic never fails.

In a proof, there are often multiple goals outstanding. Parallel
sequencing is one way to arrange it so that a single tactic is applied
to multiple goals, but there are other ways to do this. For example,
``all_goals t`` applies ``t`` to all open goals:
-->
<p>小心：<code>repeat (try t)</code> 将永远循环，因为内部策略永远不会失败。</p>
<p>在一个证明中，往往有多个目标未完成。并行序列是一种布置方式，以便将一个策略应用于多个目标，但也有其他的方式可以做到这一点。例如，<code>all_goals t</code>将 <code>t</code> 应用于所有未完成的目标：</p>
<pre><code class="language-lean">example (p q r : Prop) (hp : p) (hq : q) (hr : r) : p ∧ q ∧ r := by
  constructor
  all_goals (try constructor)
  all_goals assumption
</code></pre>
<!--
In this case, the ``any_goals`` tactic provides a more robust solution.
It is similar to ``all_goals``, except it succeeds if its argument
succeeds on at least one goal.
-->
<p>在这种情况下，<code>any_goals</code> 策略提供了一个更稳健的解决方案。它与 <code>all_goals</code> 类似，只是除非它的参数至少在一个目标上成功，否则就会失败。</p>
<pre><code class="language-lean">example (p q r : Prop) (hp : p) (hq : q) (hr : r) : p ∧ q ∧ r := by
  constructor
  any_goals constructor
  any_goals assumption
</code></pre>
<!--
The first tactic in the ``by`` block below repeatedly splits
conjunctions:
-->
<p>下面 <code>by</code> 块中的第一个策略是反复拆分合取：</p>
<pre><code class="language-lean">example (p q r : Prop) (hp : p) (hq : q) (hr : r) :
      p ∧ ((p ∧ q) ∧ r) ∧ (q ∧ r ∧ p) := by
  repeat (any_goals constructor)
  all_goals assumption
</code></pre>
<!--
In fact, we can compress the full tactic down to one line:
-->
<p>其实可以将整个策略压缩成一行：</p>
<pre><code class="language-lean">example (p q r : Prop) (hp : p) (hq : q) (hr : r) :
      p ∧ ((p ∧ q) ∧ r) ∧ (q ∧ r ∧ p) := by
  repeat (any_goals (first | constructor | assumption))
</code></pre>
<!--
The combinator ``focus t`` ensures that ``t`` only effects the current
goal, temporarily hiding the others from the scope. So, if ``t``
ordinarily only effects the current goal, ``focus (all_goals t)`` has
the same effect as ``t``.
-->
<p>组合器 <code>focus t</code> 确保 <code>t</code> 只影响当前的目标，暂时将其他目标从作用范围中隐藏。因此，如果 <code>t</code> 通常只影响当前目标，<code>focus (all_goals t)</code>与 <code>t</code> 具有相同的效果。</p>
<!--
Rewriting
---------
-->
<h2 id="重写"><a class="header" href="#重写">重写</a></h2>
<!--
The ``rewrite`` tactic (abbreviated ``rw``) and the ``simp`` tactic
were introduced briefly in [Calculational Proofs](./quantifiers_and_equality.md#calculational-proofs). In this
section and the next, we discuss them in greater detail.

The ``rewrite`` tactic provides a basic mechanism for applying
substitutions to goals and hypotheses, providing a convenient and
efficient way of working with equality. The most basic form of the
tactic is ``rewrite [t]``, where ``t`` is a term whose type asserts an
equality. For example, ``t`` can be a hypothesis ``h : x = y`` in the
context; it can be a general lemma, like
``add_comm : ∀ x y, x + y = y + x``, in which the rewrite tactic tries to find suitable
instantiations of ``x`` and ``y``; or it can be any compound term
asserting a concrete or general equation. In the following example, we
use this basic form to rewrite the goal using a hypothesis.
-->
<p>在<a href="./quantifiers_and_equality.html#%E8%AE%A1%E7%AE%97%E5%BC%8F%E8%AF%81%E6%98%8E">计算式证明</a>一节中简要介绍了 <code>rewrite</code> 策略（简称 <code>rw</code>）和 <code>simp</code> 策略。在本节和下一节中，我们将更详细地讨论它们。</p>
<p><code>rewrite</code> 策略提供了一种基本的机制，可以将替换应用于目标和假设，在处理等式时非常方便。该策略的最基本形式是 <code>rewrite [t]</code>，其中 <code>t</code> 是一个类型断定为等式的项。例如，<code>t</code> 可以是上下文中的一个假设<code>h : x = y</code>；可以是一个一般的法则，如<code>add_comm : ∀ x y, x + y = y + x</code>，在这个法则中，重写策略试图找到 <code>x</code> 和 <code>y</code> 的合适实例；或者可以是任何断言具体或一般等式的复合项。在下面的例子中，我们使用这种基本形式，用一个假设重写目标。</p>
<!--
```lean
example (f : Nat → Nat) (k : Nat) (h₁ : f 0 = 0) (h₂ : k = 0) : f k = 0 := by
  rw [h₂] -- replace k with 0
  rw [h₁] -- replace f 0 with 0
```
-->
<pre><code class="language-lean">example (f : Nat → Nat) (k : Nat) (h₁ : f 0 = 0) (h₂ : k = 0) : f k = 0 := by
  rw [h₂] -- 用 0 换掉 k
  rw [h₁] -- 用 0 换掉 f 0
</code></pre>
<!--
In the example above, the first use of ``rw`` replaces ``k`` with
``0`` in the goal ``f k = 0``. Then, the second one replaces ``f 0``
with ``0``. The tactic automatically closes any goal of the form
``t = t``. Here is an example of rewriting using a compound expression:
-->
<p>在上面的例子中，第一次使用 <code>rw</code> 将目标 <code>f k = 0</code> 中的 <code>k</code> 替换成 <code>0</code>。然后，第二次用 <code>0</code> 替换 <code>f 0</code>。该策略自动关闭任何形式的目标<code>t = t</code>。下面是一个使用复合表达式进行重写的例子。</p>
<pre><code class="language-lean">example (x y : Nat) (p : Nat → Prop) (q : Prop) (h : q → x = y)
        (h' : p y) (hq : q) : p x := by
  rw [h hq]; assumption
</code></pre>
<!--
Here, ``h hq`` establishes the equation ``x = y``.

Multiple rewrites can be combined using the notation ``rw [t_1, ..., t_n]``,
which is just shorthand for ``rw [t_1]; ...; rw [t_n]``. The previous example can be written as follows:
-->
<p>这里，<code>h hq</code> 建立了等式 <code>x = y</code>。<code>h hq</code> 周围的括号是不必要的，但为了清楚起见，还是加上了括号。</p>
<p>多个重写可以使用符号<code>rw [t_1, ..., t_n]</code>来组合，这只是<code>rw t_1; ...; rw t_n</code>的缩写。前面的例子可以写成如下：</p>
<pre><code class="language-lean">example (f : Nat → Nat) (k : Nat) (h₁ : f 0 = 0) (h₂ : k = 0) : f k = 0 := by
  rw [h₂, h₁]
</code></pre>
<!--
By default, ``rw`` uses an equation in the forward direction, matching
the left-hand side with an expression, and replacing it with the
right-hand side. The notation ``←t`` can be used to instruct the
tactic to use the equality ``t`` in the reverse direction.
-->
<p>默认情况下，<code>rw</code> 正向使用一个等式，用一个表达式匹配左边的等式，然后用右边的等式替换它。符号 <code>←t</code> 可以用来指示策略在反方向上使用等式 <code>t</code>。</p>
<pre><code class="language-lean">example (f : Nat → Nat) (a b : Nat) (h₁ : a = b) (h₂ : f a = 0) : f b = 0 := by
  rw [←h₁, h₂]
</code></pre>
<!--
In this example, the term ``←h₁`` instructs the rewriter to replace
``b`` with ``a``. In the editors, you can type the backwards arrow as
``\l``. You can also use the ascii equivalent, ``<-``.

Sometimes the left-hand side of an identity can match more than one
subterm in the pattern, in which case the ``rw`` tactic chooses the
first match it finds when traversing the term. If that is not the one
you want, you can use additional arguments to specify the appropriate
subterm.
-->
<p>在这个例子中，项 <code>←h₁</code> 指示重写器用 <code>a</code> 替换 <code>b</code>。在编辑器中，你可以用 <code>\l</code> 输入反箭头。你也可以使用 ascii 替代品 <code>&lt;-</code>。</p>
<p>有时一个等式的左侧可以匹配模式中的多个子项，在这种情况下，<code>rw</code> 策略会在遍历项时选择它发现的第一个匹配。如果这不是你想要的，你可以使用附加参数来指定适当的子项。</p>
<pre><code class="language-lean">example (a b c : Nat) : a + b + c = a + c + b := by
  rw [Nat.add_assoc, Nat.add_comm b, ← Nat.add_assoc]

example (a b c : Nat) : a + b + c = a + c + b := by
  rw [Nat.add_assoc, Nat.add_assoc, Nat.add_comm b]

example (a b c : Nat) : a + b + c = a + c + b := by
  rw [Nat.add_assoc, Nat.add_assoc, Nat.add_comm _ b]
</code></pre>
<!--
In the first example above, the first step rewrites ``a + b + c`` to
``a + (b + c)``. The next step applies commutativity to the term
``b + c``; without specifying the argument, the tactic would instead rewrite
``a + (b + c)`` to ``(b + c) + a``. Finally, the last step applies
associativity in the reverse direction, rewriting ``a + (c + b)`` to
``a + c + b``. The next two examples instead apply associativity to
move the parenthesis to the right on both sides, and then switch ``b``
and ``c``. Notice that the last example specifies that the rewrite
should take place on the right-hand side by specifying the second
argument to ``Nat.add_comm``.

By default, the ``rewrite`` tactic affects only the goal. The notation
``rw [t] at h`` applies the rewrite ``t`` at hypothesis ``h``.
-->
<p>在上面的第一个例子中，第一步将 <code>a + b + c</code> 重写为 <code>a + (b + c)</code>。然后，接下来对项 <code>b + c</code> 使用交换律；如果不指定参数，该策略将把 <code>a + (b + c)</code> 重写为 <code>(b + c) + a</code>。最后一步以相反的方向应用结合律，将<code>a + (c + b)</code>改写为 <code>a + c + b</code>。接下来的两个例子则是应用结合律将两边的小括号移到右边，然后将 <code>b</code> 和 <code>c</code> 调换。注意最后一个例子通过指定 <code>Nat.add_comm</code> 的第二个参数来指定重写应该在右侧进行。</p>
<p>默认情况下，<code>rewrite</code> 策略只影响目标。符号 <code>rw [t] at h</code> 在假设 <code>h</code> 处应用重写 <code>t</code>。</p>
<pre><code class="language-lean">example (f : Nat → Nat) (a : Nat) (h : a + 0 = 0) : f a = f 0 := by
  rw [Nat.add_zero] at h
  rw [h]
</code></pre>
<!--
The first step, ``rw [Nat.add_zero] at h``, rewrites the hypothesis ``a + 0 = 0`` to ``a = 0``.
Then the new hypothesis ``a = 0`` is used to rewrite the goal to ``f 0 = f 0``.

The ``rewrite`` tactic is not restricted to propositions.
In the following example, we use ``rw [h] at t`` to rewrite the hypothesis ``t : Tuple α n`` to ``t : Tuple α 0``.
-->
<p>第一步，<code>rw [Nat.add_zero] at h</code> 将假设 <code>a + 0 = 0</code> 改写为 <code>a = 0</code>。然后，新的假设<code>a = 0</code>被用来把目标重写为<code>f 0 = f 0</code>。</p>
<p><code>rewrite</code> 策略不限于命题。在下面的例子中，我们用<code>rw [h] at t</code>来重写假设<code>t : Tuple α n</code>为<code>t : Tuple α 0</code>。</p>
<pre><code class="language-lean">def Tuple (α : Type) (n : Nat) :=
  { as : List α // as.length = n }

example (n : Nat) (h : n = 0) (t : Tuple α n) : Tuple α 0 := by
  rw [h] at t
  exact t
</code></pre>
<!--
Using the Simplifier
--------------------
-->
<h2 id="简化"><a class="header" href="#简化">简化</a></h2>
<!--
Whereas ``rewrite`` is designed as a surgical tool for manipulating a
goal, the simplifier offers a more powerful form of automation. A
number of identities in Lean's library have been tagged with the
``[simp]`` attribute, and the ``simp`` tactic uses them to iteratively
rewrite subterms in an expression.
-->
<p><code>rewrite</code> 被设计为操纵目标的手术刀，而简化器提供了一种更强大的自动化形式。Lean 库中的一些特性已经被标记为<code>[simp]</code>属性，<code>simp</code> 策略使用它们来反复重写表达式中的子项。</p>
<pre><code class="language-lean">example (x y z : Nat) : (x + 0) * (0 + y * 1 + z * 0) = x * y := by
  simp

example (x y z : Nat) (p : Nat → Prop) (h : p (x * y))
        : p ((x + 0) * (0 + y * 1 + z * 0)) := by
  simp; assumption
</code></pre>
<!--
In the first example, the left-hand side of the equality in the goal
is simplified using the usual identities involving 0 and 1, reducing
the goal to ``x * y = x * y``. At that point, ``simp`` applies
reflexivity to finish it off. In the second example, ``simp`` reduces
the goal to ``p (x * y)``, at which point the assumption ``h``
finishes it off. Here are some more examples
with lists:
-->
<p>在第一个例子中，目标中等式的左侧被简化，使用涉及0和1的通常的同义词，将目标简化为<code>x * y = x * y'</code>。此时<code>simp'</code>应用反身性（rfl）来完成它。在第二个例子中，<code>simp</code> 将目标化简为<code>p (x * y)</code>，这时假设 <code>h</code> 完成了它。下面是一些关于列表的例子。</p>
<pre><code class="language-lean">open List

example (xs : List Nat)
        : reverse (xs ++ [1, 2, 3]) = [3, 2, 1] ++ reverse xs := by
  simp

example (xs ys : List α)
        : length (reverse (xs ++ ys)) = length xs + length ys := by
  simp [Nat.add_comm]
</code></pre>
<!--
As with ``rw``, you can use the keyword ``at`` to simplify a hypothesis:
-->
<p>就像 <code>rw</code>，你也可以用关键字 <code>at</code> 来简化一个假设：</p>
<pre><code class="language-lean">example (x y z : Nat) (p : Nat → Prop)
        (h : p ((x + 0) * (0 + y * 1 + z * 0))) : p (x * y) := by
  simp at h; assumption
</code></pre>
<!--
Moreover, you can use a "wildcard" asterisk to simplify all the hypotheses and the goal:
-->
<p>此外，你可以使用一个「通配符」星号来简化所有的假设和目标：</p>
<pre><code class="language-lean">attribute [local simp] Nat.mul_comm Nat.mul_assoc Nat.mul_left_comm
attribute [local simp] Nat.add_assoc Nat.add_comm Nat.add_left_comm

example (w x y z : Nat) (p : Nat → Prop)
        (h : p (x * y + z * w * x)) : p (x * w * z + y * x) := by
  simp at *; assumption

example (x y z : Nat) (p : Nat → Prop)
        (h₁ : p (1 * x + y)) (h₂ : p (x * z * 1))
        : p (y + 0 + x) ∧ p (z * x) := by
  simp at * &lt;;&gt; constructor &lt;;&gt; assumption
</code></pre>
<!--
For operations that are commutative and associative, like
multiplication on the natural numbers, the simplifier uses these two
facts to rewrite an expression, as well as *left commutativity*. In
the case of multiplication the latter is expressed as follows:
``x * (y * z) = y * (x * z)``. The ``local`` modifier tells the simplifier
to use these rules in the current file (or section or namespace, as
the case may be). It may seem that commutativity and
left-commutativity are problematic, in that repeated application of
either causes looping. But the simplifier detects identities that
permute their arguments, and uses a technique known as *ordered
rewriting*. This means that the system maintains an internal ordering
of terms, and only applies the identity if doing so decreases the
order. With the three identities mentioned above, this has the effect
that all the parentheses in an expression are associated to the right,
and the expressions are ordered in a canonical (though somewhat
arbitrary) way. Two expressions that are equivalent up to
associativity and commutativity are then rewritten to the same
canonical form.
-->
<p>上例中前两行的意思是，对于具有交换律和结合律的运算（如自然数的加法和乘法），简化器使用这两个定律来重写表达式，同时还使用<em>左交换律</em>。在乘法的情况下，左交换律表达如下：<code>x * (y * z) = y * (x * z)</code>。<code>local</code> 修饰符告诉简化器在当前文件（或小节或命名空间，视情况而定）中使用这些规则。交换律和左交换律是有一个问题是，重复应用其中一个会导致循环。但是简化器检测到了对其参数进行置换的特性，并使用了一种被称为<em>有序重写</em>的技术。这意味着系统保持着项的内部次序，只有在这样做会降低次序的情况下才会应用等式。对于上面提到的三个等式，其效果是表达式中的所有小括号都被结合到右边，并且表达式以一种规范的（尽管有些随意）方式排序。两个在交换律和结合律上等价的表达式然后被改写成相同的规范形式。</p>
<pre><code class="language-lean"><span class="boring">attribute [local simp] Nat.mul_comm Nat.mul_assoc Nat.mul_left_comm
</span><span class="boring">attribute [local simp] Nat.add_assoc Nat.add_comm Nat.add_left_comm
</span>example (w x y z : Nat) (p : Nat → Prop)
        : x * y + z * w * x = x * w * z + y * x := by
  simp

example (w x y z : Nat) (p : Nat → Prop)
        (h : p (x * y + z * w * x)) : p (x * w * z + y * x) := by
  simp; simp at h; assumption
</code></pre>
<!--
As with ``rewrite``, you can send ``simp`` a list of facts to use,
including general lemmas, local hypotheses, definitions to unfold, and
compound expressions. The ``simp`` tactic also recognizes the ``←t``
syntax that ``rewrite`` does. In any case, the additional rules are
added to the collection of identities that are used to simplify a
term.
-->
<p>与 <code>rewrite</code> 一样，你可以向 <code>simp</code> 提供一个要使用的事实列表，包括一般引理、局部假设、要展开的定义和复合表达式。<code>simp</code> 策略也能识别 <code>rewrite</code> 的<code>←t</code>语法。在任何情况下，额外的规则都会被添加到用于简化项的等式集合中。</p>
<pre><code class="language-lean">def f (m n : Nat) : Nat :=
  m + n + m

example {m n : Nat} (h : n = 1) (h' : 0 = m) : (f m n) = n := by
  simp [h, ←h', f]
</code></pre>
<!--
A common idiom is to simplify a goal using local hypotheses:
-->
<p>一个常见的习惯是用局部假设来简化一个目标：</p>
<pre><code class="language-lean">example (f : Nat → Nat) (k : Nat) (h₁ : f 0 = 0) (h₂ : k = 0) : f k = 0 := by
  simp [h₁, h₂]
</code></pre>
<!--
To use all the hypotheses present in the local context when
simplifying, we can use the wildcard symbol, ``*``:
-->
<p>为了在简化时使用局部环境中存在的所有假设，我们可以使用通配符 <code>*</code>：</p>
<pre><code class="language-lean">example (f : Nat → Nat) (k : Nat) (h₁ : f 0 = 0) (h₂ : k = 0) : f k = 0 := by
  simp [*]
</code></pre>
<!--
Here is another example:
-->
<p>另一例：</p>
<pre><code class="language-lean">example (u w x y z : Nat) (h₁ : x = y + z) (h₂ : w = u + x)
        : w = z + y + u := by
  simp [*, Nat.add_assoc, Nat.add_comm, Nat.add_left_comm]
</code></pre>
<!--
The simplifier will also do propositional rewriting. For example,
using the hypothesis ``p``, it rewrites ``p ∧ q`` to ``q`` and ``p ∨
q`` to ``true``, which it then proves trivially. Iterating such
rewrites produces nontrivial propositional reasoning.
-->
<p>简化器也会进行命题重写。例如，使用假设 <code>p</code>，它把 <code>p ∧ q</code> 改写为 <code>q</code>，把 <code>p ∨ q</code> 改写为 <code>true</code>，然后以普通方式证明。迭代这样的重写，会生成非平凡的命题推理。</p>
<pre><code class="language-lean">example (p q : Prop) (hp : p) : p ∧ q ↔ q := by
  simp [*]

example (p q : Prop) (hp : p) : p ∨ q := by
  simp [*]

example (p q r : Prop) (hp : p) (hq : q) : p ∧ (q ∨ r) := by
  simp [*]
</code></pre>
<!--
The next example simplifies all the hypotheses, and then uses them to prove the goal.
-->
<p>下一个例子简化了所有的假设，然后用这些假设来证明目标。</p>
<pre><code class="language-lean">example (u w x x' y y' z : Nat) (p : Nat → Prop)
        (h₁ : x + 0 = x') (h₂ : y + 0 = y')
        : x + y + 0 = x' + y' := by
  simp at *
  simp [*]
</code></pre>
<!--
One thing that makes the simplifier especially useful is that its
capabilities can grow as a library develops. For example, suppose we
define a list operation that symmetrizes its input by appending its
reversal:
-->
<p>使得简化器特别有用的一点是，它的能力可以随着规则库的发展而增强。例如，假设我们定义了一个列表操作，该操作通过拼接其反转来对称其输入：</p>
<pre><code class="language-lean">def mk_symm (xs : List α) :=
  xs ++ xs.reverse
</code></pre>
<!--
Then for any list ``xs``, ``reverse (mk_symm xs)`` is equal to ``mk_symm xs``,
which can easily be proved by unfolding the definition:
-->
<p>那么对于任何列表 <code>xs</code>，<code>reverse (mk_symm xs)</code> 等于 <code>mk_symm xs</code>，这可以通过展开定义轻松证明：</p>
<pre><code class="language-lean"><span class="boring">def mk_symm (xs : List α) :=
</span><span class="boring"> xs ++ xs.reverse
</span>theorem reverse_mk_symm (xs : List α)
        : (mk_symm xs).reverse = mk_symm xs := by
  simp [mk_symm]
</code></pre>
<!--
We can now use this theorem to prove new results:
-->
<p>你可以使用这个定理来证明一些新结果：</p>
<pre><code class="language-lean"><span class="boring">def mk_symm (xs : List α) :=
</span><span class="boring"> xs ++ xs.reverse
</span><span class="boring">theorem reverse_mk_symm (xs : List α)
</span><span class="boring">       : (mk_symm xs).reverse = mk_symm xs := by
</span><span class="boring"> simp [mk_symm]
</span>example (xs ys : List Nat)
        : (xs ++ mk_symm ys).reverse = mk_symm ys ++ xs.reverse := by
  simp [reverse_mk_symm]

example (xs ys : List Nat) (p : List Nat → Prop)
        (h : p (xs ++ mk_symm ys).reverse)
        : p (mk_symm ys ++ xs.reverse) := by
  simp [reverse_mk_symm] at h; assumption
</code></pre>
<!--
But using ``reverse_mk_symm`` is generally the right thing to do, and
it would be nice if users did not have to invoke it explicitly. You can
achieve that by marking it as a simplification rule when the theorem
is defined:
-->
<p>但是使用 <code>reverse_mk_symm</code> 通常是正确的，如果用户不需要明确地调用它，那就更好了。你可以通过在定义该定理时将其标记为简化规则来实现这一点：</p>
<pre><code class="language-lean"><span class="boring">def mk_symm (xs : List α) :=
</span><span class="boring"> xs ++ xs.reverse
</span>@[simp] theorem reverse_mk_symm (xs : List α)
        : (mk_symm xs).reverse = mk_symm xs := by
  simp [mk_symm]

example (xs ys : List Nat)
        : (xs ++ mk_symm ys).reverse = mk_symm ys ++ xs.reverse := by
  simp

example (xs ys : List Nat) (p : List Nat → Prop)
        (h : p (xs ++ mk_symm ys).reverse)
        : p (mk_symm ys ++ xs.reverse) := by
  simp at h; assumption
</code></pre>
<!--
The notation ``@[simp]`` declares ``reverse_mk_symm`` to have the
``[simp]`` attribute, and can be spelled out more explicitly:
-->
<p>符号 <code>@[simp]</code> 声明 <code>reverse_mk_symm</code> 具有 <code>[simp]</code> 属性，可以更明确地说明：</p>
<pre><code class="language-lean"><span class="boring">def mk_symm (xs : List α) :=
</span><span class="boring"> xs ++ xs.reverse
</span>theorem reverse_mk_symm (xs : List α)
        : (mk_symm xs).reverse = mk_symm xs := by
  simp [mk_symm]

attribute [simp] reverse_mk_symm

example (xs ys : List Nat)
        : (xs ++ mk_symm ys).reverse = mk_symm ys ++ xs.reverse := by
  simp

example (xs ys : List Nat) (p : List Nat → Prop)
        (h : p (xs ++ mk_symm ys).reverse)
        : p (mk_symm ys ++ xs.reverse) := by
  simp at h; assumption
</code></pre>
<!--
The attribute can also be applied any time after the theorem is declared:
-->
<p>该属性也可以在定理声明后的任何时候应用：</p>
<pre><code class="language-lean"><span class="boring">def mk_symm (xs : List α) :=
</span><span class="boring"> xs ++ xs.reverse
</span>theorem reverse_mk_symm (xs : List α)
        : (mk_symm xs).reverse = mk_symm xs := by
  simp [mk_symm]

example (xs ys : List Nat)
        : (xs ++ mk_symm ys).reverse = mk_symm ys ++ xs.reverse := by
  simp [reverse_mk_symm]

attribute [simp] reverse_mk_symm

example (xs ys : List Nat) (p : List Nat → Prop)
        (h : p (xs ++ mk_symm ys).reverse)
        : p (mk_symm ys ++ xs.reverse) := by
  simp at h; assumption
</code></pre>
<!--
Once the attribute is applied, however, there is no way to permanently
remove it; it persists in any file that imports the one where the
attribute is assigned. As we will discuss further in
[Attributes](./interacting_with_lean.md#attributes), one can limit the scope of an attribute to the
current file or section using the ``local`` modifier:
-->
<p>然而，一旦属性被应用，就没有办法永久地删除它；它将在任何导入该属性的文件中持续存在。正如我们将在<a href="./interacting_with_lean.html#%E5%B1%9E%E6%80%A7">属性</a>一章中进一步讨论的那样，我们可以使用 <code>local</code> 修饰符将属性的范围限制在当前文件或章节中：</p>
<pre><code class="language-lean"><span class="boring">def mk_symm (xs : List α) :=
</span><span class="boring"> xs ++ xs.reverse
</span>theorem reverse_mk_symm (xs : List α)
        : (mk_symm xs).reverse = mk_symm xs := by
  simp [mk_symm]

section
attribute [local simp] reverse_mk_symm

example (xs ys : List Nat)
        : (xs ++ mk_symm ys).reverse = mk_symm ys ++ xs.reverse := by
  simp

example (xs ys : List Nat) (p : List Nat → Prop)
        (h : p (xs ++ mk_symm ys).reverse)
        : p (mk_symm ys ++ xs.reverse) := by
  simp at h; assumption
end
</code></pre>
<!--
Outside the section, the simplifier will no longer use
``reverse_mk_symm`` by default.

Note that the various ``simp`` options we have discussed --- giving an
explicit list of rules, and using ``at`` to specify the location --- can be combined,
but the order they are listed is rigid. You can see the correct order
in an editor by placing the cursor on the ``simp`` identifier to see
the documentation string that is associated with it.

There are two additional modifiers that are useful. By default,
``simp`` includes all theorems that have been marked with the
attribute ``[simp]``. Writing ``simp only`` excludes these defaults,
allowing you to use a more explicitly crafted list of
rules. In the examples below, the minus sign and
``only`` are used to block the application of ``reverse_mk_symm``.
-->
<p>在该部分之外，简化器将不再默认使用 <code>reverse_mk_symm</code>。</p>
<p>请注意，我们讨论过的各种 <code>simp</code> 选项----给出一个明确的规则列表，并使用 <code>at</code> 指定位置----可以合并，但它们的排列顺序是严格的。你可以在编辑器中看到正确的顺序，把光标放在 <code>simp</code> 标识符上，查看与之相关的文档。</p>
<p>有两个额外的修饰符是有用的。默认情况下，<code>simp</code> 包括所有被标记为 <code>[simp]</code> 属性的定理。写<code>simp only</code>排除了这些默认值，允许你使用一个更明确的规则列表。在下面的例子中，减号和 <code>only</code> 被用来阻止 <code>reverse_mk_symm</code> 的应用：</p>
<pre><code class="language-lean">def mk_symm (xs : List α) :=
  xs ++ xs.reverse
@[simp] theorem reverse_mk_symm (xs : List α)
        : (mk_symm xs).reverse = mk_symm xs := by
  simp [mk_symm]

example (xs ys : List Nat) (p : List Nat → Prop)
        (h : p (xs ++ mk_symm ys).reverse)
        : p (mk_symm ys ++ xs.reverse) := by
  simp at h; assumption

example (xs ys : List Nat) (p : List Nat → Prop)
        (h : p (xs ++ mk_symm ys).reverse)
        : p ((mk_symm ys).reverse ++ xs.reverse) := by
  simp [-reverse_mk_symm] at h; assumption

example (xs ys : List Nat) (p : List Nat → Prop)
        (h : p (xs ++ mk_symm ys).reverse)
        : p ((mk_symm ys).reverse ++ xs.reverse) := by
  simp only [List.reverse_append] at h; assumption
</code></pre>
<!--
The `simp` tactic has many configuration options. For example, we can enable contextual simplifications as follows.
-->
<p><code>simp</code> 策略有很多配置选项，例如，我们可以启用语境简化：</p>
<pre><code class="language-lean">example : if x = 0 then y + x = y else x ≠ 0 := by
  simp (config := { contextual := true })
</code></pre>
<!--
when `contextual := true`, `simp` uses the fact that `x = 0` when simplifying `y + x = y`, and
`x ≠ 0` when simplifying the other branch. Here is another example.
-->
<p>当<code>contextual := true</code>，<code>simp</code> 简化<code>y + x = y</code>时会使用<code>x = 0</code>，同时会用<code>x ≠ 0</code>来简化另一侧。另一个例子：</p>
<pre><code class="language-lean">example : ∀ (x : Nat) (h : x = 0), y + x = y := by
  simp (config := { contextual := true })
</code></pre>
<!--
Another useful configuration option is `arith := true` which enables arithmetical simplifications. It is so useful
that `simp_arith` is a shorthand for `simp (config := { arith := true })`.
-->
<p>另一个有用的配置是<code>arith := true</code>，它会简化算术表达式。因为这太常用了所以用 <code>simp_arith</code> 作为<code>simp (config := { arith := true })</code>的缩写。</p>
<pre><code class="language-lean">example : 0 &lt; 1 + x ∧ x + y + 2 ≥ y + 1 := by
  simp_arith
</code></pre>
<!--
Split Tactic
------------
-->
<h2 id="拆分"><a class="header" href="#拆分">拆分</a></h2>
<!--
The ``split`` tactic is useful for breaking nested `if-then-else` and `match` expressions in cases.
For a `match` expression with `n` cases, the `split` tactic generates at most `n` subgoals. Here is an example.
-->
<p><code>split</code> 策略对于在多情形分支结构中打破嵌套的<code>if-then-else</code>和 <code>match</code> 表达式很有用。
对于包含 <code>n</code> 种情形的 <code>match</code> 表达式，<code>split</code> 策略最多生成 <code>n</code> 个子目标。例子：</p>
<pre><code class="language-lean">def f (x y z : Nat) : Nat :=
  match x, y, z with
  | 5, _, _ =&gt; y
  | _, 5, _ =&gt; y
  | _, _, 5 =&gt; y
  | _, _, _ =&gt; 1

example (x y z : Nat) : x ≠ 5 → y ≠ 5 → z ≠ 5 → z = w → f x y w = 1 := by
  intros
  simp [f]
  split
  . contradiction
  . contradiction
  . contradiction
  . rfl
</code></pre>
<!--
We can compress the tactic proof above as follows.
-->
<p>可以压缩成一行：</p>
<pre><code class="language-lean"><span class="boring">def f (x y z : Nat) : Nat :=
</span><span class="boring"> match x, y, z with
</span><span class="boring"> | 5, _, _ =&gt; y
</span><span class="boring"> | _, 5, _ =&gt; y
</span><span class="boring"> | _, _, 5 =&gt; y
</span><span class="boring"> | _, _, _ =&gt; 1
</span>example (x y z : Nat) : x ≠ 5 → y ≠ 5 → z ≠ 5 → z = w → f x y w = 1 := by
  intros; simp [f]; split &lt;;&gt; first | contradiction | rfl
</code></pre>
<!--
The tactic `split <;> first | contradiction | rfl` first applies the `split` tactic,
and then for each generated goal it tries `contradiction`, and then `rfl` if `contradiction` fails.
Like `simp`, we can apply `split` to a particular hypothesis.
-->
<p>策略<code>split &lt;;&gt; first | contradiction | rfl</code>首先应用 <code>split</code> 策略，接着对每个生成出的目标尝试 <code>contradiction</code>，如果失败那么最后 <code>rfl</code>。</p>
<p>类似 <code>simp</code>，我们对一个特定的假设也可以使用 <code>split</code>。</p>
<pre><code class="language-lean">def g (xs ys : List Nat) : Nat :=
  match xs, ys with
  | [a, b], _ =&gt; a+b+1
  | _, [b, c] =&gt; b+1
  | _, _      =&gt; 1

example (xs ys : List Nat) (h : g xs ys = 0) : False := by
  simp [g] at h; split at h &lt;;&gt; simp_arith at h
</code></pre>
<!--
Extensible Tactics
-----------------
-->
<h2 id="扩展策略"><a class="header" href="#扩展策略">扩展策略</a></h2>
<!--
In the following example, we define the notation `triv` using the command `syntax`.
Then, we use the command `macro_rules` to specify what should
be done when `triv` is used. You can provide different expansions, and the tactic
interpreter will try all of them until one succeeds.
-->
<p>在下面的例子中，我们使用 <code>syntax</code> 命令定义符号 <code>triv</code>。然后，我们使用 <code>macro_rules</code> 命令来指定使用 <code>triv</code> 时应该做什么。你可以提供不同的扩展，策略解释器将尝试所有的扩展，直到有一个成功。</p>
<!--
```lean
-- Define a new tactic notation
syntax "triv" : tactic

macro_rules
  | `(tactic| triv) => `(tactic| assumption)

example (h : p) : p := by
  triv

-- You cannot prove the following theorem using `triv`
-- example (x : α) : x = x := by
--  triv

-- Let's extend `triv`. The tactic interpreter
-- tries all possible macro extensions for `triv` until one succeeds
macro_rules
  | `(tactic| triv) => `(tactic| rfl)

example (x : α) : x = x := by
  triv

example (x : α) (h : p) : x = x ∧ p := by
  apply And.intro <;> triv

-- We now add a (recursive) extension
macro_rules | `(tactic| triv) => `(tactic| apply And.intro <;> triv)

example (x : α) (h : p) : x = x ∧ p := by
  triv
```
-->
<pre><code class="language-lean">-- 定义一个新策略符号
syntax &quot;triv&quot; : tactic

macro_rules
  | `(tactic| triv) =&gt; `(tactic| assumption)

example (h : p) : p := by
  triv

-- 你不能用 `triv` 解决下面的定理：
-- example (x : α) : x = x := by
--  triv

-- 扩展 `triv`。策略解释器会尝试所有可能的扩展宏，直到有一个成功。
macro_rules
  | `(tactic| triv) =&gt; `(tactic| rfl)

example (x : α) : x = x := by
  triv

example (x : α) (h : p) : x = x ∧ p := by
  apply And.intro &lt;;&gt; triv

-- 加一个递归扩展
macro_rules | `(tactic| triv) =&gt; `(tactic| apply And.intro &lt;;&gt; triv)

example (x : α) (h : p) : x = x ∧ p := by
  triv
</code></pre>
<!--
Exercises
---------
-->
<h2 id="练习-2"><a class="header" href="#练习-2">练习</a></h2>
<!--
1. Go back to the exercises in [Chapter Propositions and
Proofs](./propositions_and_proofs.md) and
[Chapter Quantifiers and Equality](./quantifiers_and_equality.md) and
redo as many as you can now with tactic proofs, using also ``rw``
and ``simp`` as appropriate.

1. Use tactic combinators to obtain a one line proof of the following:
-->
<ol>
<li>
<p>用策略式证明重做<a href="./propositions_and_proofs.html">命题与证明</a>和<a href="./quantifiers_and_equality.html">量词与等价</a>两章的练习。适当使用 <code>rw</code> 和 <code>simp</code>。</p>
</li>
<li>
<p>用策略组合器给下面的例子用一行写一个证明：</p>
</li>
</ol>
<pre><code class="language-lean">example (p q r : Prop) (hp : p)
        : (p ∨ q ∨ r) ∧ (q ∨ p ∨ r) ∧ (q ∨ r ∨ p) := by
  admit
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
Interacting with Lean
=====================
-->
<h1 id="与-lean-交互"><a class="header" href="#与-lean-交互">与 Lean 交互</a></h1>
<!--
You are now familiar with the fundamentals of dependent type theory,
both as a language for defining mathematical objects and a language
for constructing proofs. The one thing you are missing is a mechanism
for defining new data types. We will fill this gap in the next
chapter, which introduces the notion of an *inductive data type*. But
first, in this chapter, we take a break from the mechanics of type
theory to explore some pragmatic aspects of interacting with Lean.

Not all of the information found here will be useful to you right
away. We recommend skimming this section to get a sense of Lean's
features, and then returning to it as necessary.
-->
<p>你现在已经熟悉了依值类型论的基本原理，它既是一种定义数学对象的语言，也是一种构造证明的语言。现在你缺少一个定义新数据类型的机制。下一章介绍<em>归纳数据类型</em>的概念来帮你完成这个目标。但首先，在这一章中，我们从类型论的机制中抽身出来，探索与 Lean 交互的一些实用性问题。</p>
<p>并非所有的知识都能马上对你有用。可以略过这一节，然后在必要时再回到这一节以了解 Lean 的特性。</p>
<!--
Importing Files
---------------
-->
<h2 id="导入文件"><a class="header" href="#导入文件">导入文件</a></h2>
<!--
The goal of Lean's front end is to interpret user input, construct
formal expressions, and check that they are well formed and type
correct. Lean also supports the use of various editors, which provide
continuous checking and feedback. More information can be found on the
Lean [documentation pages](https://lean-lang.org/documentation/).

The definitions and theorems in Lean's standard library are spread
across multiple files. Users may also wish to make use of additional
libraries, or develop their own projects across multiple files. When
Lean starts, it automatically imports the contents of the library
``Init`` folder, which includes a number of fundamental definitions
and constructions. As a result, most of the examples we present here
work "out of the box."

If you want to use additional files, however, they need to be imported
manually, via an ``import`` statement at the beginning of a file. The
command
-->
<p>Lean 的前端的目标是解释用户的输入，构建形式化的表达式，并检查它们是否形式良好和类型正确。Lean 还支持使用各种编辑器，这些编辑器提供持续的检查和反馈。更多信息可以在Lean<a href="https://lean-lang.org/documentation/">文档</a>上找到。</p>
<p>Lean 的标准库中的定义和定理分布在多个文件中。用户也可能希望使用额外的库，或在多个文件中开发自己的项目。当 Lean 启动时，它会自动导入库中 <code>Init</code> 文件夹的内容，其中包括一些基本定义和结构。因此，我们在这里介绍的大多数例子都是「开箱即用」的。</p>
<p>然而，如果你想使用其他文件，需要通过文件开头的`import'语句手动导入。命令</p>
<pre><code>import Bar.Baz.Blah
</code></pre>
<!--
imports the file ``Bar/Baz/Blah.olean``, where the descriptions are
interpreted relative to the Lean *search path*. Information as to how
the search path is determined can be found on the
[documentation pages](https://lean-lang.org/documentation/).
By default, it includes the standard library directory, and (in some contexts)
the root of the user's local project.

Importing is transitive. In other words, if you import ``Foo`` and ``Foo`` imports ``Bar``,
then you also have access to the contents of ``Bar``, and do not need to import it explicitly.
-->
<p>导入文件 <code>Bar/Baz/Blah.olean</code>，其中的描述是相对于 Lean <strong>搜索路径</strong> 解释的。关于如何确定搜索路径的信息可以在<a href="https://lean-lang.org/documentation/">文档</a>中找到。默认情况下，它包括标准库目录，以及（在某些情况下）用户的本地项目的根目录。</p>
<p>导入是传递性的。换句话说，如果你导入了 <code>Foo</code>，并且 <code>Foo</code> 导入了 <code>Bar</code>，那么你也可以访问 <code>Bar</code> 的内容，而不需要明确导入它。</p>
<!--
More on Sections
----------------
-->
<h2 id="小节续"><a class="header" href="#小节续">小节（续）</a></h2>
<!--
Lean provides various sectioning mechanisms to help structure a
theory. You saw in [Variables and Sections](./dependent_type_theory.md#variables-and-sections) that the
``section`` command makes it possible not only to group together
elements of a theory that go together, but also to declare variables
that are inserted as arguments to theorems and definitions, as
necessary. Remember that the point of the `variable` command is to
declare variables for use in theorems, as in the following example:
-->
<p>Lean 提供了各种分段机制来帮助构造理论。你在<a href="./dependent_type_theory.html#%E5%8F%98%E9%87%8F%E5%92%8C%E5%B0%8F%E8%8A%82">变量和小节</a>中看到，<code>section</code> 命令不仅可以将理论中的元素组合在一起，还可以在必要时声明变量，作为定理和定义的参数插入。请记住，<code>variable</code> 命令的意义在于声明变量，以便在定理中使用，如下面的例子：</p>
<pre><code class="language-lean">section
variable (x y : Nat)

def double := x + x

#check double y
#check double (2 * x)

attribute [local simp] Nat.add_assoc Nat.add_comm Nat.add_left_comm

theorem t1 : double (x + y) = double x + double y := by
  simp [double]

#check t1 y
#check t1 (2 * x)

theorem t2 : double (x * y) = double x * y := by
  simp [double, Nat.add_mul]

end
</code></pre>
<!--
The definition of ``double`` does not have to declare ``x`` as an
argument; Lean detects the dependence and inserts it
automatically. Similarly, Lean detects the occurrence of ``x`` in
``t1`` and ``t2``, and inserts it automatically there, too.
Note that ``double`` does *not* have ``y`` as argument. Variables are only
included in declarations where they are actually used.
-->
<p><code>double</code> 的定义不需要声明 <code>x</code> 作为参数；Lean 检测到这种依赖关系并自动插入。同样，Lean 检测到 <code>x</code> 在 <code>t1</code> 和 <code>t2</code> 中的出现，也会自动插入。注意，double <strong>没有</strong> <code>y</code> 作为参数。变量只包括在实际使用的声明中。</p>
<!--
More on Namespaces
------------------
-->
<h2 id="命名空间续"><a class="header" href="#命名空间续">命名空间（续）</a></h2>
<!--
In Lean, identifiers are given by hierarchical *names* like
``Foo.Bar.baz``. We saw in [Namespaces](./dependent_type_theory.md#namespaces) that Lean provides
mechanisms for working with hierarchical names. The command
``namespace foo`` causes ``foo`` to be prepended to the name of each
definition and theorem until ``end foo`` is encountered. The command
``open foo`` then creates temporary *aliases* to definitions and
theorems that begin with prefix ``foo``.
-->
<p>在 Lean 中，标识符是由层次化的<em>名称</em>给出的，如 <code>Foo.Bar.baz</code>。我们在<a href="./dependent_type_theory.html#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">命名空间</a>一节中看到，Lean 提供了处理分层名称的机制。命令 <code>namespace foo</code> 导致 <code>foo</code> 被添加到每个定义和定理的名称中，直到遇到 <code>end foo</code>。命令 <code>open foo</code> 然后为以 <code>foo</code> 开头的定义和定理创建临时的 <strong>别名</strong> 。</p>
<pre><code class="language-lean">namespace Foo
def bar : Nat := 1
end Foo

open Foo

#check bar
#check Foo.bar
</code></pre>
<!--
The following definition
-->
<p>下面的定义</p>
<pre><code class="language-lean">def Foo.bar : Nat := 1
</code></pre>
<!--
is treated as a macro, and expands to
-->
<p>被看成一个宏；展开成</p>
<pre><code class="language-lean">namespace Foo
def bar : Nat := 1
end Foo
</code></pre>
<!--
Although the names of theorems and definitions have to be unique, the
aliases that identify them do not. When we open a namespace, an
identifier may be ambiguous. Lean tries to use type information to
disambiguate the meaning in context, but you can always disambiguate
by giving the full name. To that end, the string ``_root_`` is an
explicit description of the empty prefix.
-->
<p>尽管定理和定义的名称必须是唯一的，但标识它们的别名却不是。当我们打开一个命名空间时，一个标识符可能是模糊的。Lean 试图使用类型信息来消除上下文中的含义，但你总是可以通过给出全名来消除歧义。为此，字符串 <code>_root_</code> 是对空前缀的明确表述。</p>
<pre><code class="language-lean">def String.add (a b : String) : String :=
  a ++ b

def Bool.add (a b : Bool) : Bool :=
  a != b

def add (α β : Type) : Type := Sum α β

open Bool
open String
-- #check add -- ambiguous
#check String.add           -- String → String → String
#check Bool.add             -- Bool → Bool → Bool
#check _root_.add           -- Type → Type → Type

#check add &quot;hello&quot; &quot;world&quot;  -- String
#check add true false       -- Bool
#check add Nat Nat          -- Type
</code></pre>
<!--
We can prevent the shorter alias from being created by using the ``protected`` keyword:
-->
<p>我们可以通过使用 <code>protected</code> 关键字来阻止创建较短的别名：</p>
<pre><code class="language-lean">protected def Foo.bar : Nat := 1

open Foo

-- #check bar -- error
#check Foo.bar
</code></pre>
<!--
This is often used for names like ``Nat.rec`` and ``Nat.recOn``, to prevent
overloading of common names.

The ``open`` command admits variations. The command
-->
<p>这通常用于像<code>Nat.rec</code>和<code>Nat.recOn</code>这样的名称，以防止普通名称的重载。</p>
<p><code>open</code> 命令允许变量。命令</p>
<pre><code class="language-lean">open Nat (succ zero gcd)
#check zero     -- Nat
#eval gcd 15 6  -- 3
</code></pre>
<!--
creates aliases for only the identifiers listed. The command
-->
<p>仅对列出的标识符创建了别名。命令</p>
<pre><code class="language-lean">open Nat hiding succ gcd
#check zero     -- Nat
-- #eval gcd 15 6  -- error
#eval Nat.gcd 15 6  -- 3
</code></pre>
<!--
creates aliases for everything in the ``Nat`` namespace *except* the identifiers listed.
-->
<p>给 <code>Nat</code> 命名空间中 <strong>除了</strong> 被列出的标识符都创建了别名。命令</p>
<pre><code class="language-lean">open Nat renaming mul → times, add → plus
#eval plus (times 2 2) 3  -- 7
</code></pre>
<!--
creates aliases renaming ``Nat.mul`` to ``times`` and ``Nat.add`` to ``plus``.

It is sometimes useful to ``export`` aliases from one namespace to another, or to the top level. The command
-->
<p>将<code>Nat.mul</code>更名为 <code>times</code>，<code>Nat.add</code>更名为 <code>plus</code>。</p>
<p>有时，将别名从一个命名空间导出到另一个命名空间，或者导出到上一层是很有用的。命令</p>
<pre><code class="language-lean">export Nat (succ add sub)
</code></pre>
<!--
creates aliases for ``succ``, ``add``, and ``sub`` in the current
namespace, so that whenever the namespace is open, these aliases are
available. If this command is used outside a namespace, the aliases
are exported to the top level.
-->
<p>在当前命名空间中为 <code>succ</code>、<code>add</code> 和 <code>sub</code> 创建别名，这样无论何时命名空间被打开，这些别名都可以使用。如果这个命令在名字空间之外使用，那么这些别名会被输出到上一层。</p>
<!--
Attributes
----------
-->
<h2 id="属性"><a class="header" href="#属性">属性</a></h2>
<!--
The main function of Lean is to translate user input to formal
expressions that are checked by the kernel for correctness and then
stored in the environment for later use. But some commands have other
effects on the environment, either assigning attributes to objects in
the environment, defining notation, or declaring instances of type
classes, as described in [Chapter Type Classes](./type_classes.md). Most of
these commands have global effects, which is to say, that they remain
in effect not only in the current file, but also in any file that
imports it. However, such commands often support the ``local`` modifier,
which indicates that they only have effect until
the current ``section`` or ``namespace`` is closed, or until the end
of the current file.

In [Section Using the Simplifier](./tactics.md#using-the-simplifier),
we saw that theorems can be annotated with the ``[simp]`` attribute,
which makes them available for use by the simplifier.
The following example defines the prefix relation on lists,
proves that this relation is reflexive, and assigns the ``[simp]`` attribute to that theorem.
-->
<p>Lean 的主要功能是把用户的输入翻译成形式化的表达式，由内核检查其正确性，然后存储在环境中供以后使用。但是有些命令对环境有其他的影响，或者给环境中的对象分配属性，定义符号，或者声明类型类的实例，如<a href="./type_classes.html">类型类</a>一章所述。这些命令大多具有全局效应，也就是说，它们不仅在当前文件中保持有效，而且在任何导入它的文件中也保持有效。然而，这类命令通常支持 <code>local</code> 修饰符，这表明它们只在当前 <code>section</code> 或 <code>namespace</code> 关闭前或当前文件结束前有效。</p>
<p>在<a href="./tactics.html#%E7%AE%80%E5%8C%96">简化</a>一节中，我们看到可以用<code>[simp]</code>属性来注释定理，这使它们可以被简化器使用。下面的例子定义了列表的前缀关系，证明了这种关系是自反的，并为该定理分配了<code>[simp]</code>属性。</p>
<pre><code class="language-lean">def isPrefix (l₁ : List α) (l₂ : List α) : Prop :=
  ∃ t, l₁ ++ t = l₂

@[simp] theorem List.isPrefix_self (as : List α) : isPrefix as as :=
  ⟨[], by simp⟩

example : isPrefix [1, 2, 3] [1, 2, 3] := by
  simp
</code></pre>
<!--
The simplifier then proves ``isPrefix [1, 2, 3] [1, 2, 3]`` by rewriting it to ``True``.

One can also assign the attribute any time after the definition takes place:
-->
<p>然后简化器通过将其改写为 <code>True</code> 来证明 <code>isPrefix [1, 2, 3] [1, 2, 3]</code>。</p>
<p>你也可以在做出定义后的任何时候分配属性：</p>
<pre><code class="language-lean"><span class="boring">def isPrefix (l₁ : List α) (l₂ : List α) : Prop :=
</span><span class="boring"> ∃ t, l₁ ++ t = l₂
</span>theorem List.isPrefix_self (as : List α) : isPrefix as as :=
  ⟨[], by simp⟩

attribute [simp] List.isPrefix_self
</code></pre>
<!--
In all these cases, the attribute remains in effect in any file that
imports the one in which the declaration occurs. Adding the ``local``
modifier restricts the scope:
-->
<p>在所有这些情况下，该属性在任何导入该声明的文件中仍然有效。添加 <code>local</code> 修饰符可以限制范围：</p>
<pre><code class="language-lean"><span class="boring">def isPrefix (l₁ : List α) (l₂ : List α) : Prop :=
</span><span class="boring"> ∃ t, l₁ ++ t = l₂
</span>section

theorem List.isPrefix_self (as : List α) : isPrefix as as :=
  ⟨[], by simp⟩

attribute [local simp] List.isPrefix_self

example : isPrefix [1, 2, 3] [1, 2, 3] := by
  simp

end

-- Error:
-- example : isPrefix [1, 2, 3] [1, 2, 3] := by
--  simp
</code></pre>
<!--
For another example, we can use the ``instance`` command to assign the
notation ``≤`` to the `isPrefix` relation. That command, which will
be explained in [Chapter Type Classes](./type_classes.md), works by
assigning an ``[instance]`` attribute to the associated definition.
-->
<p>另一个例子，我们可以使用 <code>instance</code> 命令来给 <code>isPrefix</code> 关系分配符号<code>≤</code>。该命令将在<a href="./type_classes.html">类型类</a>中解释，它的工作原理是给相关定义分配一个<code>[instance]</code>属性。</p>
<pre><code class="language-lean">def isPrefix (l₁ : List α) (l₂ : List α) : Prop :=
  ∃ t, l₁ ++ t = l₂

instance : LE (List α) where
  le := isPrefix

theorem List.isPrefix_self (as : List α) : as ≤ as :=
  ⟨[], by simp⟩
</code></pre>
<!--
That assignment can also be made local:
-->
<p>这个分配也可以是局部的：</p>
<pre><code class="language-lean"><span class="boring">def isPrefix (l₁ : List α) (l₂ : List α) : Prop :=
</span><span class="boring">  ∃ t, l₁ ++ t = l₂
</span>def instLe : LE (List α) :=
  { le := isPrefix }

section
attribute [local instance] instLe

example (as : List α) : as ≤ as :=
  ⟨[], by simp⟩

end

-- Error:
-- example (as : List α) : as ≤ as :=
--  ⟨[], by simp⟩
</code></pre>
<!--
In [Section Notation](#notation) below, we will discuss Lean's
mechanisms for defining notation, and see that they also support the
``local`` modifier. However, in [Section Setting Options](#setting-options), we will
discuss Lean's mechanisms for setting options, which does *not* follow
this pattern: options can *only* be set locally, which is to say,
their scope is always restricted to the current section or current
file.
-->
<p>在下面的<a href="interacting_with_lean.html#%E7%AC%A6%E5%8F%B7">符号</a>一节中，我们将讨论 Lean 定义符号的机制，并看到它们也支持 <code>local</code> 修饰符。然而，在<a href="interacting_with_lean.html#%E8%AE%BE%E7%BD%AE%E9%80%89%E9%A1%B9">设置选项</a>一节中，我们将讨论 Lean 设置选项的机制，它并 <strong>不</strong> 遵循这种模式：选项 <strong>只能</strong> 在局部设置，也就是说，它们的范围总是限制在当前小节或当前文件中。</p>
<!--
More on Implicit Arguments
--------------------------
-->
<h2 id="隐参数续"><a class="header" href="#隐参数续">隐参数（续）</a></h2>
<!--
In [Section Implicit Arguments](./dependent_type_theory.md#implicit-arguments),
we saw that if Lean displays the type
of a term ``t`` as ``{x : α} → β x``, then the curly brackets
indicate that ``x`` has been marked as an *implicit argument* to
``t``. This means that whenever you write ``t``, a placeholder, or
"hole," is inserted, so that ``t`` is replaced by ``@t _``. If you
don't want that to happen, you have to write ``@t`` instead.

Notice that implicit arguments are inserted eagerly. Suppose we define
a function ``f (x : Nat) {y : Nat} (z : Nat)`` with the arguments
shown. Then, when we write the expression ``f 7`` without further
arguments, it is parsed as ``f 7 _``. Lean offers a weaker annotation,
``{{y : Nat}}``, which specifies that a placeholder should only be added
*before* a subsequent explicit argument. This annotation can also be
written using as ``⦃y : Nat⦄``, where the unicode brackets are entered
as ``\{{`` and ``\}}``, respectively. With this annotation, the
expression ``f 7`` would be parsed as is, whereas ``f 7 3`` would be
parsed as ``f 7 _ 3``, just as it would be with the strong annotation.

To illustrate the difference, consider the following example, which
shows that a reflexive euclidean relation is both symmetric and
transitive.
-->
<p>在<a href="./dependent_type_theory.html#%E9%9A%90%E5%8F%82%E6%95%B0">隐参数</a>一节中，我们看到，如果 Lean 将术语 <code>t</code> 的类型显示为 <code>{x : α} → β x</code>，那么大括号表示 <code>x</code> 被标记为 <code>t</code> 的<em>隐参数</em>。这意味着每当你写 <code>t</code> 时，就会插入一个占位符，或者说「洞」，这样 <code>t</code> 就会被 <code>@t _</code> 取代。如果你不希望这种情况发生，你必须写 <code>@t</code> 来代替。</p>
<p>请注意，隐参数是急于插入的。假设我们定义一个函数 <code>f (x : Nat) {y : Nat} (z : Nat)</code>。那么，当我们写表达式<code>f 7</code>时，没有进一步的参数，它会被解析为<code>f 7 _</code>。Lean 提供了一个较弱的注释，<code>{{y : ℕ}}</code>，它指定了一个占位符只应在后一个显式参数之前添加。这个注释也可以写成 <code>⦃y : Nat⦄</code>，其中的 unicode 括号输入方式为 <code>\{{</code> 和 <code>\}}</code>。有了这个注释，表达式<code>f 7</code>将被解析为原样，而<code>f 7 3</code>将被解析为 <code>f 7 _ 3</code>，就像使用强注释一样。</p>
<p>为了说明这种区别，请看下面的例子，它表明一个自反的欧几里得关系既是对称的又是传递的。</p>
<pre><code class="language-lean">def reflexive {α : Type u} (r : α → α → Prop) : Prop :=
  ∀ (a : α), r a a

def symmetric {α : Type u} (r : α → α → Prop) : Prop :=
  ∀ {a b : α}, r a b → r b a

def transitive {α : Type u} (r : α → α → Prop) : Prop :=
  ∀ {a b c : α}, r a b → r b c → r a c

def euclidean {α : Type u} (r : α → α → Prop) : Prop :=
  ∀ {a b c : α}, r a b → r a c → r b c

theorem th1 {α : Type u} {r : α → α → Prop}
            (reflr : reflexive r) (euclr : euclidean r)
            : symmetric r :=
  fun {a b : α} =&gt;
  fun (h : r a b) =&gt;
  show r b a from euclr h (reflr _)

theorem th2 {α : Type u} {r : α → α → Prop}
            (symmr : symmetric r) (euclr : euclidean r)
            : transitive r :=
  fun {a b c : α} =&gt;
  fun (rab : r a b) (rbc : r b c) =&gt;
  euclr (symmr rab) rbc

theorem th3 {α : Type u} {r : α → α → Prop}
            (reflr : reflexive r) (euclr : euclidean r)
            : transitive r :=
 th2 (th1 reflr @euclr) @euclr

variable (r : α → α → Prop)
variable (euclr : euclidean r)

#check euclr  -- r ?m1 ?m2 → r ?m1 ?m3 → r ?m2 ?m3
</code></pre>
<!--
The results are broken down into small steps: ``th1`` shows that a
relation that is reflexive and euclidean is symmetric, and ``th2``
shows that a relation that is symmetric and euclidean is
transitive. Then ``th3`` combines the two results. But notice that we
have to manually disable the implicit arguments in ``euclr``, because
otherwise too many implicit arguments are inserted. The problem goes
away if we use weak implicit arguments:
-->
<p>这些结果被分解成几个小步骤。<code>th1</code> 表明自反和欧氏的关系是对称的，<code>th2</code> 表明对称和欧氏的关系是传递的。然后 <code>th3</code> 结合这两个结果。但是请注意，我们必须手动禁用 <code>th1</code>、<code>th2</code> 和 <code>euclr</code> 中的隐参数，否则会插入太多的隐参数。如果我们使用弱隐式参数，这个问题就会消失：</p>
<pre><code class="language-lean">def reflexive {α : Type u} (r : α → α → Prop) : Prop :=
  ∀ (a : α), r a a

def symmetric {α : Type u} (r : α → α → Prop) : Prop :=
  ∀ {{a b : α}}, r a b → r b a

def transitive {α : Type u} (r : α → α → Prop) : Prop :=
  ∀ {{a b c : α}}, r a b → r b c → r a c

def euclidean {α : Type u} (r : α → α → Prop) : Prop :=
  ∀ {{a b c : α}}, r a b → r a c → r b c

theorem th1 {α : Type u} {r : α → α → Prop}
            (reflr : reflexive r) (euclr : euclidean r)
            : symmetric r :=
  fun {a b : α} =&gt;
  fun (h : r a b) =&gt;
  show r b a from euclr h (reflr _)

theorem th2 {α : Type u} {r : α → α → Prop}
            (symmr : symmetric r) (euclr : euclidean r)
            : transitive r :=
  fun {a b c : α} =&gt;
  fun (rab : r a b) (rbc : r b c) =&gt;
  euclr (symmr rab) rbc

theorem th3 {α : Type u} {r : α → α → Prop}
            (reflr : reflexive r) (euclr : euclidean r)
            : transitive r :=
  th2 (th1 reflr euclr) euclr

variable (r : α → α → Prop)
variable (euclr : euclidean r)

#check euclr  -- euclidean r
</code></pre>
<!--
There is a third kind of implicit argument that is denoted with square
brackets, ``[`` and ``]``. These are used for type classes, as
explained in [Chapter Type Classes](./type_classes.md).
-->
<p>还有第三种隐式参数，用方括号表示，<code>[</code> 和 <code>]</code>。这些是用于类型类的，在<a href="./type_classes.html">类型类</a>中解释。</p>
<!--
Notation
--------
-->
<h2 id="符号"><a class="header" href="#符号">符号</a></h2>
<!--
Identifiers in Lean can include any alphanumeric characters, including
Greek characters (other than ∀ , Σ , and λ , which, as we have seen,
have a special meaning in the dependent type theory). They can also
include subscripts, which can be entered by typing ``\_`` followed by
the desired subscripted character.

Lean's parser is extensible, which is to say, we can define new notation.

Lean's syntax can be extended and customized by users at every level,
ranging from basic "mixfix" notations to custom elaborators.  In fact,
all builtin syntax is parsed and processed using the same mechanisms
and APIs open to users.  In this section, we will describe and explain
the various extension points.

While introducing new notations is a relatively rare feature in
programming languages and sometimes even frowned upon because of its
potential to obscure code, it is an invaluable tool in formalization
for expressing established conventions and notations of the respective
field succinctly in code.  Going beyond basic notations, Lean's
ability to factor out common boilerplate code into (well-behaved)
macros and to embed entire custom domain specific languages (DSLs) to
textually encode subproblems efficiently and readably can be of great
benefit to both programmers and proof engineers alike.
-->
<p>Lean 中的标识符可以包括任何字母数字字符，包括希腊字母（除了∀、Σ和λ，它们在依值类型论中有特殊的含义）。它们还可以包括下标，可以通过输入 <code>\_</code>，然后再输入所需的下标字符。</p>
<p>Lean 的解析器是可扩展的，也就是说，我们可以定义新的符号。</p>
<p>Lean 的语法可以由用户在各个层面进行扩展和定制，从基本的「mixfix」符号到自定义的繁饰器。事实上，所有内置的语法都是使用对用户开放的相同机制和 API 进行解析和处理的。 在本节中，我们将描述和解释各种扩展点。</p>
<p>虽然在编程语言中引入新的符号是一个相对罕见的功能，有时甚至因为它有可能使代码变得模糊不清而被人诟病，但它是形式化的一个宝贵工具，可以在代码中简洁地表达各自领域的既定惯例和符号。 除了基本的符号之外，Lean 的能力是将普通的样板代码分解成（良好的）宏，并嵌入整个定制的特定领域语言（DSL，domain specific language），对子问题进行高效和可读的文本编码，这对程序员和证明工程师都有很大的好处。</p>
<!--
### Notations and Precedence
-->
<h3 id="符号和优先级"><a class="header" href="#符号和优先级">符号和优先级</a></h3>
<!--
The most basic syntax extension commands allow introducing new (or
overloading existing) prefix, infix, and postfix operators.
-->
<p>最基本的语法扩展命令允许引入新的（或重载现有的）前缀、下缀和后缀运算符：</p>
<!--
```lean
infixl:65   " + " => HAdd.hAdd  -- left-associative
infix:50    " = " => Eq         -- non-associative
infixr:80   " ^ " => HPow.hPow  -- right-associative
prefix:100  "-"   => Neg.neg
# set_option quotPrecheck false
postfix:max "⁻¹"  => Inv.inv
```
-->
<pre><code class="language-lean">infixl:65   &quot; + &quot; =&gt; HAdd.hAdd  -- 左结合
infix:50    &quot; = &quot; =&gt; Eq         -- 非结合
infixr:80   &quot; ^ &quot; =&gt; HPow.hPow  -- 右结合
prefix:100  &quot;-&quot;   =&gt; Neg.neg
set_option quotPrecheck false
postfix:max &quot;⁻¹&quot;  =&gt; Inv.inv
</code></pre>
<!--
After the initial command name describing the operator kind (its
"fixity"), we give the *parsing precedence* of the operator preceded
by a colon `:`, then a new or existing token surrounded by double
quotes (the whitespace is used for pretty printing), then the function
this operator should be translated to after the arrow `=>`.

The precedence is a natural number describing how "tightly" an
operator binds to its arguments, encoding the order of operations.  We
can make this more precise by looking at the commands the above unfold to:
-->
<p>语法：</p>
<p>运算符种类（其「结合方式」） : 解析优先级 &quot; 新的或现有的符号 &quot; =&gt; 这个符号应该翻译成的函数</p>
<p>优先级是一个自然数，描述一个运算符与它的参数结合的「紧密程度」，编码操作的顺序。我们可以通过查看上述展开的命令来使之更加精确：</p>
<pre><code class="language-lean">notation:65 lhs:65 &quot; + &quot; rhs:66 =&gt; HAdd.hAdd lhs rhs
notation:50 lhs:51 &quot; = &quot; rhs:51 =&gt; Eq lhs rhs
notation:80 lhs:81 &quot; ^ &quot; rhs:80 =&gt; HPow.hPow lhs rhs
notation:100 &quot;-&quot; arg:100 =&gt; Neg.neg arg
<span class="boring">set_option quotPrecheck false
</span>notation:1024 arg:1024 &quot;⁻¹&quot; =&gt; Inv.inv arg  -- `max` is a shorthand for precedence 1024
</code></pre>
<!--
It turns out that all commands from the first code block are in fact
command *macros* translating to the more general `notation` command.
We will learn about writing such macros below.  Instead of a single
token, the `notation` command accepts a mixed sequence of tokens and
named term placeholders with precedences, which can be referenced on
the right-hand side of `=>` and will be replaced by the respective
term parsed at that position.  A placeholder with precedence `p`
accepts only notations with precedence at least `p` in that place.
Thus the string `a + b + c` cannot be parsed as the equivalent of
`a + (b + c)` because the right-hand side operand of an `infixl` notation
has precedence one greater than the notation itself.  In contrast,
`infixr` reuses the notation's precedence for the right-hand side
operand, so `a ^ b ^ c` *can* be parsed as `a ^ (b ^ c)`.  Note that
if we used `notation` directly to introduce an infix notation like
-->
<p>事实证明，第一个代码块中的所有命令实际上都是命令 <strong>宏</strong> ，翻译成更通用的 <code>notation</code> 命令。我们将在下面学习如何编写这种宏。 <code>notation</code> 命令不接受单一的记号，而是接受一个混合的记号序列和有优先级的命名项占位符，这些占位符可以在<code>=&gt;</code>的右侧被引用，并将被在该位置解析的相应项所取代。 优先级为 <code>p</code> 的占位符在该处只接受优先级至少为 <code>p</code> 的记号。因此，字符串<code>a + b + c</code>不能被解析为等同于<code>a + (b + c)</code>，因为 <code>infixl</code> 符号的右侧操作数的优先级比该符号本身大。 相反，<code>infixr</code> 重用了符号右侧操作数的优先级，所以<code>a ^ b ^ c</code> <em>可以</em>被解析为<code>a ^ (b ^ c)</code>。 注意，如果我们直接使用 <code>notation</code> 来引入一个 infix 符号，如</p>
<pre><code class="language-lean"><span class="boring">set_option quotPrecheck false
</span>notation:65 lhs:65 &quot; ~ &quot; rhs:65 =&gt; wobble lhs rhs
</code></pre>
<!--
where the precedences do not sufficiently determine associativity,
Lean's parser will default to right associativity.  More precisely,
Lean's parser follows a local *longest parse* rule in the presence of
ambiguous grammars: when parsing the right-hand side of `a ~` in
`a ~ b ~ c`, it will continue parsing as long as possible (as the current
precedence allows), not stopping after `b` but parsing `~ c` as well.
Thus the term is equivalent to `a ~ (b ~ c)`.

As mentioned above, the `notation` command allows us to define
arbitrary *mixfix* syntax freely mixing tokens and placeholders.
-->
<p>在上文没有充分确定结合规则的情况下，Lean 的解析器将默认为右结合。 更确切地说，Lean 的解析器在存在模糊语法的情况下遵循一个局部的<em>最长解析</em>规则：当解析<code>a ~</code>中<code>a ~ b ~ c</code>的右侧时，它将继续尽可能长的解析（在当前的上下文允许的情况下），不在 <code>b</code> 之后停止，而是同时解析<code>~ c</code>。因此该术语等同于<code>a ~ (b ~ c)</code>。</p>
<p>如上所述，<code>notation</code> 命令允许我们定义任意的<em>mixfix</em>语法，自由地混合记号和占位符。</p>
<pre><code class="language-lean"><span class="boring">set_option quotPrecheck false
</span>notation:max &quot;(&quot; e &quot;)&quot; =&gt; e
notation:10 Γ &quot; ⊢ &quot; e &quot; : &quot; τ =&gt; Typing Γ e τ
</code></pre>
<!--
Placeholders without precedence default to `0`, i.e. they accept notations of any precedence in their place.
If two notations overlap, we again apply the longest parse rule:
-->
<p>没有优先级的占位符默认为 <code>0</code>，也就是说，它们接受任何优先级的符号来代替它们。如果两个记号重叠，我们再次应用最长解析规则：</p>
<pre><code class="language-lean">notation:65 a &quot; + &quot; b:66 &quot; + &quot; c:66 =&gt; a + b - c
#eval 1 + 2 + 3  -- 0
</code></pre>
<!--
The new notation is preferred to the binary notation since the latter,
before chaining, would stop parsing after `1 + 2`.  If there are
multiple notations accepting the same longest parse, the choice will
be delayed until elaboration, which will fail unless exactly one
overload is type correct.
-->
<p>新的符号比二进制符号要好，因为后者在连锁之前，会在<code>1 + 2</code>之后停止解析。 如果有多个符号接受同一个最长的解析，选择将被推迟到阐述，这将失败，除非正好有一个重载是类型正确的。</p>
<!--
Coercions
---------
-->
<h2 id="强制转换"><a class="header" href="#强制转换">强制转换</a></h2>
<!--
In Lean, the type of natural numbers, ``Nat``, is different from the
type of integers, ``Int``. But there is a function ``Int.ofNat`` that
embeds the natural numbers in the integers, meaning that we can view
any natural number as an integer, when needed. Lean has mechanisms to
detect and insert *coercions* of this sort.
-->
<p>在 Lean 中，自然数的类型 <code>Nat</code>，与整数的类型 <code>Int</code> 不同。但是有一个函数 <code>Int.ofNat</code> 将自然数嵌入整数中，这意味着我们可以在需要时将任何自然数视为整数。Lean 有机制来检测和插入这种 <strong>强制转换</strong> 。</p>
<pre><code class="language-lean">variable (m n : Nat)
variable (i j : Int)

#check i + m      -- i + Int.ofNat m : Int
#check i + m + j  -- i + Int.ofNat m + j : Int
#check i + m + n  -- i + Int.ofNat m + Int.ofNat n : Int
</code></pre>
<!--
Displaying Information
----------------------
-->
<h2 id="显示信息"><a class="header" href="#显示信息">显示信息</a></h2>
<!--
There are a number of ways in which you can query Lean for information
about its current state and the objects and theorems that are
available in the current context. You have already seen two of the
most common ones, ``#check`` and ``#eval``. Remember that ``#check``
is often used in conjunction with the ``@`` operator, which makes all
of the arguments to a theorem or definition explicit. In addition, you
can use the ``#print`` command to get information about any
identifier. If the identifier denotes a definition or theorem, Lean
prints the type of the symbol, and its definition. If it is a constant
or an axiom, Lean indicates that fact, and shows the type.
-->
<p>有很多方法可以让你查询 Lean 的当前状态以及当前上下文中可用的对象和定理的信息。你已经看到了两个最常见的方法，<code>#check</code>和<code>#eval</code>。请记住，<code>#check</code>经常与<code>@</code>操作符一起使用，它使定理或定义的所有参数显式化。此外，你可以使用<code>#print</code>命令来获得任何标识符的信息。如果标识符表示一个定义或定理，Lean 会打印出符号的类型，以及它的定义。如果它是一个常数或公理，Lean 会指出它并显示其类型。</p>
<!--
```lean
-- examples with equality
#check Eq
#check @Eq
#check Eq.symm
#check @Eq.symm

#print Eq.symm

-- examples with And
#check And
#check And.intro
#check @And.intro

-- a user-defined function
def foo {α : Type u} (x : α) : α := x

#check foo
#check @foo
#print foo
```
-->
<pre><code class="language-lean">-- 等式
#check Eq
#check @Eq
#check Eq.symm
#check @Eq.symm

#print Eq.symm

-- 与
#check And
#check And.intro
#check @And.intro

-- 自定义函数
def foo {α : Type u} (x : α) : α := x

#check foo
#check @foo
#print foo
</code></pre>
<!--
Setting Options
---------------
-->
<h2 id="设置选项"><a class="header" href="#设置选项">设置选项</a></h2>
<!--
Lean maintains a number of internal variables that can be set by users
to control its behavior. The syntax for doing so is as follows:
-->
<p>Lean 维护着一些内部变量，用户可以通过设置这些变量来控制其行为。语法如下：</p>
<pre><code>set_option &lt;name&gt; &lt;value&gt;
</code></pre>
<!--
One very useful family of options controls the way Lean's *pretty- printer* displays terms. The following options take an input of true or false:
-->
<p>有一系列非常有用的选项可以控制 Lean 的 <strong>美观打印</strong> 显示项的方式。下列选项的输入值为真或假：</p>
<pre><code>pp.explicit  : display implicit arguments
pp.universes : display hidden universe parameters
pp.notation  : display output using defined notations
</code></pre>
<!--
As an example, the following settings yield much longer output:
-->
<p>例如，以下设置会产生更长的输出:</p>
<pre><code class="language-lean">set_option pp.explicit true
set_option pp.universes true
set_option pp.notation false

#check 2 + 2 = 4
#reduce (fun x =&gt; x + 2) = (fun x =&gt; x + 3)
#check (fun x =&gt; x + 1) 1
</code></pre>
<!--
The command ``set_option pp.all true`` carries out these settings all
at once, whereas ``set_option pp.all false`` reverts to the previous
values. Pretty printing additional information is often very useful
when you are debugging a proof, or trying to understand a cryptic
error message. Too much information can be overwhelming, though, and
Lean's defaults are generally sufficient for ordinary interactions.
-->
<p>命令 <code>set_option pp.all true</code> 一次性执行这些设置，而 <code>set_option pp.all false</code> 则恢复到之前的值。当你调试一个证明，或试图理解一个神秘的错误信息时，漂亮地打印额外的信息往往是非常有用的。不过太多的信息可能会让人不知所措，Lean 的默认值一般来说对普通的交互是足够的。</p>
<!--
Elaboration Hints
-----------------

When you ask Lean to process an expression like ``λ x y z, f (x + y) z``, you are leaving information implicit. For example, the types of ``x``, ``y``, and ``z`` have to be inferred from the context, the notation ``+`` may be overloaded, and there may be implicit arguments to ``f`` that need to be filled in as well. Moreover, we will see in :numref:`Chapter %s <type_classes>` that some implicit arguments are synthesized by a process known as *type class resolution*. And we have also already seen in the last chapter that some parts of an expression can be constructed by the tactic framework.

Inferring some implicit arguments is straightforward. For example, suppose a function ``f`` has type ``Π {α : Type*}, α → α → α`` and Lean is trying to parse the expression ``f n``, where ``n`` can be inferred to have type ``nat``. Then it is clear that the implicit argument ``α`` has to be ``nat``. However, some inference problems are *higher order*. For example, the substitution operation for equality, ``eq.subst``, has the following type:

.. code-block:: text

    eq.subst : ∀ {α : Sort u} {p : α → Prop} {a b : α},
                 a = b → p a → p b

Now suppose we are given ``a b : ℕ`` and ``h₁ : a = b`` and ``h₂ : a * b > a``. Then, in the expression ``eq.subst h₁ h₂``, ``P`` could be any of the following:

-  ``λ x, x * b > x``
-  ``λ x, x * b > a``
-  ``λ x, a * b > x``
-  ``λ x, a * b > a``

In other words, our intent may be to replace either the first or second ``a`` in ``h₂``, or both, or neither. Similar ambiguities arise in inferring induction predicates, or inferring function arguments. Even second-order unification is known to be undecidable. Lean therefore relies on heuristics to fill in such arguments, and when it fails to guess the right ones, they need to be provided explicitly.

To make matters worse, sometimes definitions need to be unfolded, and sometimes expressions need to be reduced according to the computational rules of the underlying logical framework. Once again, Lean has to rely on heuristics to determine what to unfold or reduce, and when.

There are attributes, however, that can be used to provide hints to the elaborator. One class of attributes determines how eagerly definitions are unfolded: constants can be marked with the attribute ``[reducible]``, ``[semireducible]``, or ``[irreducible]``. Definitions are marked ``[semireducible]`` by default. A definition with the ``[reducible]`` attribute is unfolded eagerly; if you think of a definition as serving as an abbreviation, this attribute would be appropriate. The elaborator avoids unfolding definitions with the ``[irreducible]`` attribute. Theorems are marked ``[irreducible]`` by default, because typically proofs are not relevant to the elaboration process.

It is worth emphasizing that these attributes are only hints to the elaborator. When checking an elaborated term for correctness, Lean's kernel will unfold whatever definitions it needs to unfold. As with other attributes, the ones above can be assigned with the ``local`` modifier, so that they are in effect only in the current section or file.

Lean also has a family of attributes that control the elaboration strategy. A definition or theorem can be marked ``[elab_with_expected_type]``, ``[elab_simple]``. or ``[elab_as_eliminator]``. When applied to a definition ``f``, these bear on elaboration of an expression ``f a b c ...`` in which ``f`` is applied to arguments. With the default attribute, ``[elab_with_expected_type]``, the arguments ``a``, ``b``, ``c``, ... are elaborating using information about their expected type, inferred from ``f`` and the previous arguments. In contrast, with ``[elab_simple]``, the arguments are elaborated from left to right without propagating information about their types. The last attribute, ``[elab_as_eliminator]``, is commonly used for eliminators like recursors, induction principles, and ``eq.subst``. It uses a separate heuristic to infer higher-order parameters. We will consider such operations in more detail in the next chapter.

Once again, these attributes can be assigned and reassigned after an object is defined, and you can use the ``local`` modifier to limit their scope. Moreover, using the ``@`` symbol in front of an identifier in an expression instructs the elaborator to use the ``[elab_simple]`` strategy; the idea is that, when you provide the tricky parameters explicitly, you want the elaborator to weigh that information heavily. In fact, Lean offers an alternative annotation, ``@@``, which leaves parameters before the first higher-order parameter implicit. For example, ``@@eq.subst`` leaves the type of the equation implicit, but makes the context of the substitution explicit.

-->
<!--
Using the Library
-----------------
-->
<h2 id="使用库"><a class="header" href="#使用库">使用库</a></h2>
<!--
To use Lean effectively you will inevitably need to make use of
definitions and theorems in the library. Recall that the ``import``
command at the beginning of a file imports previously compiled results
from other files, and that importing is transitive; if you import
``Foo`` and ``Foo`` imports ``Bar``, then the definitions and theorems
from ``Bar`` are available to you as well. But the act of opening a
namespace, which provides shorter names, does not carry over. In each
file, you need to open the namespaces you wish to use.

In general, it is important for you to be familiar with the library
and its contents, so you know what theorems, definitions, notations,
and resources are available to you. Below we will see that Lean's
editor modes can also help you find things you need, but studying the
contents of the library directly is often unavoidable. Lean's standard
library can be found online, on GitHub:
-->
<p>为了有效地使用Lean，你将不可避免地需要使用库中的定义和定理。回想一下，文件开头的 <code>import</code> 命令会从其他文件中导入之前编译的结果，而且导入是传递的；如果你导入了 <code>Foo</code>，<code>Foo</code> 又导入了 <code>Bar</code>，那么 <code>Bar</code> 的定义和定理也可以被你利用。但是打开一个命名空间的行为，提供了更短的名字，并没有延续下去。在每个文件中，你需要打开你想使用的命名空间。</p>
<p>一般来说，你必须熟悉库和它的内容，这样你就知道有哪些定理、定义、符号和资源可供你使用。下面我们将看到 Lean 的编辑器模式也可以帮助你找到你需要的东西，但直接研究库的内容往往是不可避免的。Lean 的标准库在 GitHub 上。</p>
<ul>
<li>
<p><a href="https://github.com/leanprover/lean4/tree/master/src/Init">https://github.com/leanprover/lean4/tree/master/src/Init</a></p>
</li>
<li>
<p><a href="https://github.com/leanprover/std4/tree/main/Std">https://github.com/leanprover/std4/tree/main/Std</a></p>
</li>
</ul>
<!--
You can see the contents of these directories and files using GitHub's
browser interface. If you have installed Lean on your own computer,
you can find the library in the ``lean`` folder, and explore it with
your file manager. Comment headers at the top of each file provide
additional information.

Lean's library developers follow general naming guidelines to make it
easier to guess the name of a theorem you need, or to find it using
tab completion in editors with a Lean mode that supports this, which
is discussed in the next section. Identifiers are generally
``camelCase``, and types are `CamelCase`. For theorem names,
we rely on descriptive names where the different components are separated
by `_`s. Often the name of theorem simply describes the conclusion:
-->
<p>你可以使用 GitHub 的浏览器界面查看这些目录和文件的内容。如果你在自己的电脑上安装了Lean，你可以在 <code>lean</code> 文件夹中找到这个库，用你的文件管理器探索它。每个文件顶部的注释标题提供了额外的信息。</p>
<p>Lean 库的开发者遵循一般的命名准则，以便于猜测你所需要的定理的名称，或者在支持 Lean 模式的编辑器中用 Tab 自动补全来找到它，这将在下一节讨论。标识符一般是 <code>camelCase</code>，而类型是 <code>CamelCase</code>。对于定理的名称，我们依靠描述性的名称，其中不同的组成部分用 <code>_</code> 分开。通常情况下，定理的名称只是描述结论。</p>
<pre><code class="language-lean">#check Nat.succ_ne_zero
#check Nat.zero_add
#check Nat.mul_one
#check Nat.le_of_succ_le_succ
</code></pre>
<!--
Remember that identifiers in Lean can be organized into hierarchical
namespaces. For example, the theorem named ``le_of_succ_le_succ`` in the
namespace ``Nat`` has full name ``Nat.le_of_succ_le_succ``, but the shorter
name is made available by the command ``open Nat`` (for names not marked as
`protected`). We will see in [Chapter Inductive Types](./inductive_types.md)
and [Chapter Structures and Records](./structures_and_records.md)
that defining structures and inductive data types in Lean generates
associated operations, and these are stored in
a namespace with the same name as the type under definition. For
example, the product type comes with the following operations:
-->
<p>Lean 中的标识符可以被组织到分层的命名空间中。例如，命名空间 <code>Nat</code> 中名为 <code>le_of_succ_le_succ</code> 的定理有全称 <code>Nat.le_of_succ_le_succ</code>，但较短的名称可由命令 <code>open Nat</code> 提供（对于未标记为 <code>protected</code> 的名称）。我们将在<a href="./inductive_types.html">归纳类型</a>和<a href="./structures_and_records.html">结构体和记录</a>中看到，在 Lean 中定义结构体和归纳数据类型会产生相关操作，这些操作存储在与被定义类型同名的命名空间。例如，乘积类型带有以下操作：</p>
<pre><code class="language-lean">#check @Prod.mk
#check @Prod.fst
#check @Prod.snd
#check @Prod.rec
</code></pre>
<!--
The first is used to construct a pair, whereas the next two,
``Prod.fst`` and ``Prod.snd``, project the two elements. The last,
``Prod.rec``, provides another mechanism for defining functions on a
product in terms of a function on the two components. Names like
``Prod.rec`` are *protected*, which means that one has to use the full
name even when the ``Prod`` namespace is open.

With the propositions as types correspondence, logical connectives are
also instances of inductive types, and so we tend to use dot notation
for them as well:
-->
<p>第一个用于构建一个对，而接下来的两个，<code>Prod.fst</code> 和 <code>Prod.snd</code>，投影两个元素。最后一个，<code>Prod.rec</code>，提供了另一种机制，用两个元素的函数来定义乘积上的函数。像 <code>Prod.rec</code> 这样的名字是<em>受保护</em>的，这意味着即使 <code>Prod</code> 名字空间是打开的，也必须使用全名。</p>
<p>由于命题即类型的对应原则，逻辑连接词也是归纳类型的实例，因此我们也倾向于对它们使用点符号：</p>
<pre><code class="language-lean">#check @And.intro
#check @And.casesOn
#check @And.left
#check @And.right
#check @Or.inl
#check @Or.inr
#check @Or.elim
#check @Exists.intro
#check @Exists.elim
#check @Eq.refl
#check @Eq.subst
</code></pre>
<!--
Auto Bound Implicit Arguments
-----------------
-->
<h2 id="自动约束隐参数"><a class="header" href="#自动约束隐参数">自动约束隐参数</a></h2>
<!--
In the previous section, we have shown how implicit arguments make functions more convenient to use.
However, functions such as `compose` are still quite verbose to define. Note that the universe
polymorphic `compose` is even more verbose than the one previously defined.
-->
<p>在上一节中，我们已经展示了隐参数是如何使函数更方便使用的。然而，像 <code>compose</code> 这样的函数在定义时仍然相当冗长。宇宙多态的 <code>compose</code> 比之前定义的函数还要啰嗦。</p>
<pre><code class="language-lean">universe u v w
def compose {α : Type u} {β : Type v} {γ : Type w}
            (g : β → γ) (f : α → β) (x : α) : γ :=
  g (f x)
</code></pre>
<!--
You can avoid the `universe` command by providing the universe parameters when defining `compose`.
-->
<p>你可以通过在定义 <code>compose</code> 时提供宇宙参数来避免使用 <code>universe</code> 命令。</p>
<pre><code class="language-lean">def compose.{u, v, w}
            {α : Type u} {β : Type v} {γ : Type w}
            (g : β → γ) (f : α → β) (x : α) : γ :=
  g (f x)
</code></pre>
<!--
Lean 4 supports a new feature called *auto bound implicit arguments*. It makes functions such as
`compose` much more convenient to write. When Lean processes the header of a declaration,
any unbound identifier is automatically added as an implicit argument *if* it is a single lower case or
greek letter. With this feature we can write `compose` as
-->
<p>Lean 4支持一个名为 <strong>自动约束隐参数</strong> 的新特性。它使诸如 <code>compose</code> 这样的函数在编写时更加方便。当 Lean 处理一个声明的头时， <strong>如果</strong> 它是一个小写字母或希腊字母，任何未约束的标识符都会被自动添加为隐式参数。有了这个特性，我们可以把 <code>compose</code> 写成</p>
<pre><code class="language-lean">def compose (g : β → γ) (f : α → β) (x : α) : γ :=
  g (f x)

#check @compose
-- {β : Sort u_1} → {γ : Sort u_2} → {α : Sort u_3} → (β → γ) → (α → β) → α → γ
</code></pre>
<!--
Note that Lean inferred a more general type using `Sort` instead of `Type`.

Although we love this feature and use it extensively when implementing Lean,
we realize some users may feel uncomfortable with it. Thus, you can disable it using
the command `set_option autoImplicit false`.
-->
<p>请注意，Lean 使用 <code>Sort</code> 而不是 <code>Type</code> 推断出了一个更通用的类型。</p>
<p>虽然我们很喜欢这个功能，并且在实现 Lean 时广泛使用，但我们意识到有些用户可能会对它感到不舒服。因此，你可以使用<code>set_option autoBoundImplicitLocal false</code>命令将其禁用。</p>
<!--
```lean
set_option autoImplicit false
/- The following definition produces `unknown identifier` errors -/
-- def compose (g : β → γ) (f : α → β) (x : α) : γ :=
--   g (f x)
```
-->
<pre><code class="language-lean">set_option autoImplicit false
/- 这个定义会报错：`unknown identifier` -/
-- def compose (g : β → γ) (f : α → β) (x : α) : γ :=
--   g (f x)
</code></pre>
<!--
Implicit Lambdas
---------------
-->
<h2 id="隐式lambda"><a class="header" href="#隐式lambda">隐式Lambda</a></h2>
<!--
In Lean 3 stdlib, we find many
[instances](https://github.com/leanprover/lean/blob/master/library/init/category/reader.lean#L39) of the dreadful `@`+`_` idiom.
It is often used when the expected type is a function type with implicit arguments,
and we have a constant (`reader_t.pure` in the example) which also takes implicit arguments. In Lean 4, the elaborator automatically introduces lambdas
for consuming implicit arguments. We are still exploring this feature and analyzing its impact, but the experience so far has been very positive. Here is the example from the link above using Lean 4 implicit lambdas.
-->
<p>在Lean 3 stdlib中，我们发现了许多<a href="https://github.com/leanprover/lean/blob/master/library/init/category/reader.lean#L39">例子</a>包含丑陋的<code>@</code>+<code>_</code> 惯用法。当我们的预期类型是一个带有隐参数的函数类型，而我们有一个常量（例子中的<code>reader_t.pure</code>）也需要隐参数时，就会经常使用这个惯用法。在Lean 4中，繁饰器自动引入了 lambda 来消除隐参数。我们仍在探索这一功能并分析其影响，但到目前为止的结果是非常积极的。下面是上面链接中使用Lean 4隐式 lambda 的例子。</p>
<pre><code class="language-lean"><span class="boring">variable (ρ : Type) (m : Type → Type) [Monad m]
</span>instance : Monad (ReaderT ρ m) where
  pure := ReaderT.pure
  bind := ReaderT.bind
</code></pre>
<!--
Users can disable the implicit lambda feature by using `@` or writing
a lambda expression with `{}` or `[]` binder annotations.  Here are
few examples
-->
<p>用户可以通过使用<code>@</code>或用包含<code>{}</code>或<code>[]</code>的约束标记编写的 lambda 表达式来禁用隐式 lambda 功能。下面是几个例子</p>
<!--
```lean
# namespace ex2
def id1 : {α : Type} → α → α :=
  fun x => x

def listId : List ({α : Type} → α → α) :=
  (fun x => x) :: []

-- In this example, implicit lambda introduction has been disabled because
-- we use `@` before `fun`
def id2 : {α : Type} → α → α :=
  @fun α (x : α) => id1 x

def id3 : {α : Type} → α → α :=
  @fun α x => id1 x

def id4 : {α : Type} → α → α :=
  fun x => id1 x

-- In this example, implicit lambda introduction has been disabled
-- because we used the binder annotation `{...}`
def id5 : {α : Type} → α → α :=
  fun {α} x => id1 x
# end ex2
```
-->
<pre><code class="language-lean"><span class="boring">namespace ex2
</span>def id1 : {α : Type} → α → α :=
  fun x =&gt; x

def listId : List ({α : Type} → α → α) :=
  (fun x =&gt; x) :: []

-- 这个例子中，隐式 lambda 引入被禁用了，因为在 `fun` 前使用了`@`
def id2 : {α : Type} → α → α :=
  @fun α (x : α) =&gt; id1 x

def id3 : {α : Type} → α → α :=
  @fun α x =&gt; id1 x

def id4 : {α : Type} → α → α :=
  fun x =&gt; id1 x

-- 这个例子中，隐式 lambda 引入被禁用了，因为使用了绑定记号`{...}`
def id5 : {α : Type} → α → α :=
  fun {α} x =&gt; id1 x
<span class="boring">end ex2
</span></code></pre>
<!--
Sugar for Simple Functions
-------------------------
-->
<h2 id="简单函数语法糖"><a class="header" href="#简单函数语法糖">简单函数语法糖</a></h2>
<!--
In Lean 3, we can create simple functions from infix operators by
using parentheses. For example, `(+1)` is sugar for `fun x, x + 1`. In
Lean 4, we generalize this notation using `·` as a placeholder. Here
are a few examples:
-->
<p>在Lean 3中，我们可以通过使用小括号从 infix 运算符中创建简单的函数。例如，<code>(+1)</code>是<code>fun x, x + 1</code>的语法糖。在Lean 4中，我们用<code>·</code>作为占位符来扩展这个符号。这里有几个例子：</p>
<pre><code class="language-lean"><span class="boring">namespace ex3
</span>#check (· + 1)
-- fun a =&gt; a + 1
#check (2 - ·)
-- fun a =&gt; 2 - a
#eval [1, 2, 3, 4, 5].foldl (·*·) 1
-- 120

def f (x y z : Nat) :=
  x + y + z

#check (f · 1 ·)
-- fun a b =&gt; f a 1 b

#eval [(1, 2), (3, 4), (5, 6)].map (·.1)
-- [1, 3, 5]
<span class="boring">end ex3
</span></code></pre>
<!--
As in Lean 3, the notation is activated using parentheses, and the lambda abstraction is created by collecting the nested `·`s.
The collection is interrupted by nested parentheses. In the following example, two different lambda expressions are created.
-->
<p>如同在Lean 3中，符号是用圆括号激活的，lambda抽象是通过收集嵌套的<code>·</code>创建的。这个集合被嵌套的小括号打断。在下面的例子中创建了两个不同的 lambda 表达式。</p>
<pre><code class="language-lean">#check (Prod.mk · (· + 1))
-- fun a =&gt; (a, fun b =&gt; b + 1)
</code></pre>
<!--
Named Arguments
---------------
-->
<h2 id="命名参数"><a class="header" href="#命名参数">命名参数</a></h2>
<!--
Named arguments enable you to specify an argument for a parameter by
matching the argument with its name rather than with its position in
the parameter list.  If you don't remember the order of the parameters
but know their names, you can send the arguments in any order. You may
also provide the value for an implicit parameter when Lean failed to
infer it. Named arguments also improve the readability of your code by
identifying what each argument represents.
-->
<p>被命名参数使你可以通过用参数的名称而不是参数列表中的位置来指定参数。 如果你不记得参数的顺序但知道它们的名字，你可以以任何顺序传入参数。当 Lean 未能推断出一个隐参数时，你也可以提供该参数的值。被命名参数还可以通过识别每个参数所代表的内容来提高你的代码的可读性。</p>
<pre><code class="language-lean">def sum (xs : List Nat) :=
  xs.foldl (init := 0) (·+·)

#eval sum [1, 2, 3, 4]
-- 10

example {a b : Nat} {p : Nat → Nat → Nat → Prop} (h₁ : p a b b) (h₂ : b = a)
    : p a a b :=
  Eq.subst (motive := fun x =&gt; p a x b) h₂ h₁
</code></pre>
<!--
In the following examples, we illustrate the interaction between named
and default arguments.
-->
<p>在下面的例子中，我们说明了被命名参数和默认参数之间的交互。</p>
<pre><code class="language-lean">def f (x : Nat) (y : Nat := 1) (w : Nat := 2) (z : Nat) :=
  x + y + w - z

example (x z : Nat) : f (z := z) x = x + 1 + 2 - z := rfl

example (x z : Nat) : f x (z := z) = x + 1 + 2 - z := rfl

example (x y : Nat) : f x y = fun z =&gt; x + y + 2 - z := rfl

example : f = (fun x z =&gt; x + 1 + 2 - z) := rfl

example (x : Nat) : f x = fun z =&gt; x + 1 + 2 - z := rfl

example (y : Nat) : f (y := 5) = fun x z =&gt; x + 5 + 2 - z := rfl

def g {α} [Add α] (a : α) (b? : Option α := none) (c : α) : α :=
  match b? with
  | none   =&gt; a + c
  | some b =&gt; a + b + c

variable {α} [Add α]

example : g = fun (a c : α) =&gt; a + c := rfl

example (x : α) : g (c := x) = fun (a : α) =&gt; a + x := rfl

example (x : α) : g (b? := some x) = fun (a c : α) =&gt; a + x + c := rfl

example (x : α) : g x = fun (c : α) =&gt; x + c := rfl

example (x y : α) : g x y = fun (c : α) =&gt; x + y + c := rfl
</code></pre>
<!--
You can use `..` to provide missing explicit arguments as `_`.
This feature combined with named arguments is useful for writing patterns. Here is an example:
-->
<p>你可以使用<code>..</code>来提供缺少的显式参数作为 <code>_</code>。这个功能与被命名参数相结合，对编写模式很有用。下面是一个例子：</p>
<pre><code class="language-lean">inductive Term where
  | var    (name : String)
  | num    (val : Nat)
  | app    (fn : Term) (arg : Term)
  | lambda (name : String) (type : Term) (body : Term)

def getBinderName : Term → Option String
  | Term.lambda (name := n) .. =&gt; some n
  | _ =&gt; none

def getBinderType : Term → Option Term
  | Term.lambda (type := t) .. =&gt; some t
  | _ =&gt; none
</code></pre>
<!--
Ellipses are also useful when explicit arguments can be automatically
inferred by Lean, and we want to avoid a sequence of `_`s.
-->
<p>当显式参数可以由 Lean 自动推断时，省略号也很有用，而我们想避免一连串的 <code>_</code>。</p>
<pre><code class="language-lean">example (f : Nat → Nat) (a b c : Nat) : f (a + b + c) = f (a + (b + c)) :=
  congrArg f (Nat.add_assoc ..)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
Inductive Types
===============
-->
<h1 id="归纳类型"><a class="header" href="#归纳类型">归纳类型</a></h1>
<!--
We have seen that Lean's formal foundation includes basic types,
``Prop, Type 0, Type 1, Type 2, ...``, and allows for the formation of
dependent function types, ``(x : α) → β``. In the examples, we have
also made use of additional types like ``Bool``, ``Nat``, and ``Int``,
and type constructors, like ``List``, and product, ``×``. In fact, in
Lean's library, every concrete type other than the universes and every
type constructor other than dependent arrows is an instance of a general family of
type constructions known as *inductive types*. It is remarkable that
it is possible to construct a substantial edifice of mathematics based
on nothing more than the type universes, dependent arrow types, and inductive
types; everything else follows from those.

Intuitively, an inductive type is built up from a specified list of
constructors. In Lean, the syntax for specifying such a type is as
follows:
-->
<p>我们已经看到Lean 的形式基础包括基本类型，<code>Prop, Type 0, Type 1, Type 2, ...</code>，并允许形成依值函数类型，<code>(x : α) → β</code>。在例子中，我们还使用了额外的类型，如 <code>Bool</code>、<code>Nat</code> 和 <code>Int</code>，以及类型构造子，如 <code>List</code> 和乘积 <code>×</code>。事实上，在Lean 的库中，除了宇宙之外的每一个具体类型和除了依值箭头之外的每一个类型构造子都是一个被称为<em>归纳类型</em>的类型构造的一般类别的实例。值得注意的是，仅用类型宇宙、依值箭头类型和归纳类型就可以构建一个内涵丰富的数学大厦；其他一切都源于这些。</p>
<p>直观地说，一个归纳类型是由一个指定的构造子列表建立起来的。在Lean 中，指定这种类型的语法如下：</p>
<pre><code>inductive Foo where
  | constructor₁ : ... → Foo
  | constructor₂ : ... → Foo
  ...
  | constructorₙ : ... → Foo
</code></pre>
<!--
The intuition is that each constructor specifies a way of building new
objects of ``Foo``, possibly from previously constructed values. The
type ``Foo`` consists of nothing more than the objects that are
constructed in this way. The first character ``|`` in an inductive
declaration is optional. We can also separate constructors using a
comma instead of ``|``.

We will see below that the arguments of the constructors can include
objects of type ``Foo``, subject to a certain "positivity" constraint,
which guarantees that elements of ``Foo`` are built from the bottom
up. Roughly speaking, each ``...`` can be any arrow type constructed from
``Foo`` and previously defined types, in which ``Foo`` appears, if at
all, only as the "target" of the dependent arrow type.

We will provide a number of examples of inductive types. We will also
consider slight generalizations of the scheme above, to mutually
defined inductive types, and so-called *inductive families*.

As with the logical connectives, every inductive type comes with
introduction rules, which show how to construct an element of the
type, and elimination rules, which show how to "use" an element of the
type in another construction. The analogy to the logical connectives
should not come as a surprise; as we will see below, they, too, are
examples of inductive type constructions. You have already seen the
introduction rules for an inductive type: they are just the
constructors that are specified in the definition of the type. The
elimination rules provide for a principle of recursion on the type,
which includes, as a special case, a principle of induction as well.

In the next chapter, we will describe Lean's function definition
package, which provides even more convenient ways to define functions
on inductive types and carry out inductive proofs. But because the
notion of an inductive type is so fundamental, we feel it is important
to start with a low-level, hands-on understanding. We will start with
some basic examples of inductive types, and work our way up to more
elaborate and complex examples.
-->
<p>我们的直觉是，每个构造子都指定了一种建立新的对象 <code>Foo</code> 的方法，可能是由以前构造的值构成。<code>Foo</code> 类型只不过是由以这种方式构建的对象组成。归纳式声明中的第一个字符也可以用逗号而不是 <code>|</code> 来分隔构造子。</p>
<p>我们将在下面看到，构造子的参数可以包括 <code>Foo</code> 类型的对象，但要遵守一定的「正向性」约束，即保证 <code>Foo</code> 的元素是自下而上构建的。粗略地说，每个<code>...</code>可以是由 <code>Foo</code> 和以前定义的类型构建的任何箭头类型，其中 <code>Foo</code> 如果出现，也只是作为依值箭头类型的「目标」。</p>
<p>我们将提供一些归纳类型的例子。我们还把上述方案稍微扩展，即相互定义的归纳类型，以及所谓的<em>归纳族</em>。</p>
<p>就像逻辑连接词一样，每个归纳类型都有引入规则，说明如何构造该类型的一个元素；还有消去规则，说明如何在另一个构造中「使用」该类型的一个元素。其实逻辑连接词也是归纳类型结构的例子。你已经看到了归纳类型的引入规则：它们只是在类型的定义中指定的构造子。消去规则提供了类型上的递归原则，其中也包括作为一种特殊情况的归纳原则。</p>
<p>在下一章中，我们将介绍Lean 的函数定义包，它提供了更方便的方法来定义归纳类型上的函数并进行归纳证明。但是由于归纳类型的概念是如此的基本，我们觉得从低级的、实践的理解开始是很重要的。我们将从归纳类型的一些基本例子开始，然后逐步上升到更详细和复杂的例子。</p>
<!--
Enumerated Types
----------------
-->
<h2 id="枚举式类型"><a class="header" href="#枚举式类型">枚举式类型</a></h2>
<!--
The simplest kind of inductive type is a type with a finite, enumerated list of elements.
-->
<p>最简单的归纳类型是一个具有有限的、可枚举的元素列表的类型。</p>
<pre><code class="language-lean">inductive Weekday where
  | sunday : Weekday
  | monday : Weekday
  | tuesday : Weekday
  | wednesday : Weekday
  | thursday : Weekday
  | friday : Weekday
  | saturday : Weekday
</code></pre>
<!--
The ``inductive`` command creates a new type, ``Weekday``. The
constructors all live in the ``Weekday`` namespace.
-->
<p><code>inductive</code> 命令创建了一个新类型 <code>Weekday</code>。构造子都在 <code>Weekday</code> 命名空间中。</p>
<pre><code class="language-lean"><span class="boring">inductive Weekday where
</span><span class="boring"> | sunday : Weekday
</span><span class="boring"> | monday : Weekday
</span><span class="boring"> | tuesday : Weekday
</span><span class="boring"> | wednesday : Weekday
</span><span class="boring"> | thursday : Weekday
</span><span class="boring"> | friday : Weekday
</span><span class="boring"> | saturday : Weekday
</span>#check Weekday.sunday
#check Weekday.monday

open Weekday

#check sunday
#check monday
</code></pre>
<!--
You can omit `: Weekday` when declaring the `Weekday` inductive type.
-->
<p>在声明<code>Weekday</code>的归纳类型时，可以省略<code>: Weekday</code>。</p>
<pre><code class="language-lean">inductive Weekday where
  | sunday
  | monday
  | tuesday
  | wednesday
  | thursday
  | friday
  | saturday
</code></pre>
<!--
Think of ``sunday``, ``monday``, ... , ``saturday`` as
being distinct elements of ``Weekday``, with no other distinguishing
properties. The elimination principle, ``Weekday.rec``, is defined
along with the type ``Weekday`` and its constructors. It is also known
as a *recursor*, and it is what makes the type "inductive": it allows
us to define a function on ``Weekday`` by assigning values
corresponding to each constructor. The intuition is that an inductive
type is exhaustively generated by the constructors, and has no
elements beyond those they construct.

We will use the `match` expression to define a function from ``Weekday``
to the natural numbers:
-->
<p>把 <code>sunday</code>、<code>monday</code>、... 、<code>saturday</code> 看作是 <code>Weekday</code> 的不同元素，没有其他有区别的属性。消去规则 <code>Weekday.rec</code>，与 <code>Weekday</code> 类型及其构造子一起定义。它也被称为 <strong>递归器（Recursor）</strong> ，它是使该类型「归纳」的原因：它允许我们通过给每个构造子分配相应的值来定义<code>Weekday</code>的函数。直观的说，归纳类型是由构造子详尽地生成的，除了它们构造的元素外，没有其他元素。</p>
<p>我们将使用<code>match</code>表达式来定义一个从 <code>Weekday</code> 到自然数的函数：</p>
<pre><code class="language-lean"><span class="boring">inductive Weekday where
</span><span class="boring"> | sunday : Weekday
</span><span class="boring"> | monday : Weekday
</span><span class="boring"> | tuesday : Weekday
</span><span class="boring"> | wednesday : Weekday
</span><span class="boring"> | thursday : Weekday
</span><span class="boring"> | friday : Weekday
</span><span class="boring"> | saturday : Weekday
</span>open Weekday

def numberOfDay (d : Weekday) : Nat :=
  match d with
  | sunday    =&gt; 1
  | monday    =&gt; 2
  | tuesday   =&gt; 3
  | wednesday =&gt; 4
  | thursday  =&gt; 5
  | friday    =&gt; 6
  | saturday  =&gt; 7

#eval numberOfDay Weekday.sunday  -- 1
#eval numberOfDay Weekday.monday  -- 2
#eval numberOfDay Weekday.tuesday -- 3
</code></pre>
<!--
Note that the `match` expression is compiled using the *recursor* `Weekday.rec` generated when
you declare the inductive type.
-->
<p>注意，<code>match</code>表达式是使用你声明归纳类型时生成的递归器<code>Weekday.rec</code>来编译的。</p>
<pre><code class="language-lean"><span class="boring">inductive Weekday where
</span><span class="boring"> | sunday : Weekday
</span><span class="boring"> | monday : Weekday
</span><span class="boring"> | tuesday : Weekday
</span><span class="boring"> | wednesday : Weekday
</span><span class="boring"> | thursday : Weekday
</span><span class="boring"> | friday : Weekday
</span><span class="boring"> | saturday : Weekday
</span>open Weekday

def numberOfDay (d : Weekday) : Nat :=
  match d with
  | sunday    =&gt; 1
  | monday    =&gt; 2
  | tuesday   =&gt; 3
  | wednesday =&gt; 4
  | thursday  =&gt; 5
  | friday    =&gt; 6
  | saturday  =&gt; 7

set_option pp.all true
#print numberOfDay
-- ... numberOfDay.match_1
#print numberOfDay.match_1
-- ... Weekday.casesOn ...
#print Weekday.casesOn
-- ... Weekday.rec ...
#check @Weekday.rec
/-
@Weekday.rec.{u}
 : {motive : Weekday → Sort u} →
    motive Weekday.sunday →
    motive Weekday.monday →
    motive Weekday.tuesday →
    motive Weekday.wednesday →
    motive Weekday.thursday →
    motive Weekday.friday →
    motive Weekday.saturday →
    (t : Weekday) → motive t
-/
</code></pre>
<!--
When declaring an inductive datatype, you can use `deriving Repr` to instruct
Lean to generate a function that converts `Weekday` objects into text.
This function is used by the `#eval` command to display `Weekday` objects.
-->
<blockquote>
<p>译者注：此处详细解释一下递归器<code>rec</code>。递归器作为归纳类型的消去规则，用于构造归纳类型到其他类型的函数。从最朴素的集合论直觉上讲，枚举类型的函数只需要规定每个元素的对应，也就是<code>match</code>的方式，但是要注意，<code>match</code>并不像其他Lean 关键字那样是一种简单的语法声明，它实际上是一种功能，而这并不是类型论自带的功能。因此<code>match</code>需要一个类型论实现，也就是递归器。现在我们通过<code>#check @Weekday.rec</code>命令的输出来看递归器是如何工作的。首先回忆<code>@</code>是显式参数的意思。递归器是一个复杂的函数，输入的信息有1）motive：一个「目的」函数，表明想要拿当前类型构造什么类型。这个输出类型足够一般所以在u上；2）motive函数对所有枚举元素的输出值(这里就显得它非常「递归」)。这两点是准备工作，下面是这个函数的实际工作：输入一个具体的属于这个枚举类型的项<code>t</code>，输出结果<code>motive t</code>。下文在非枚举类型中，会直接用到这些递归器，届时可以更清晰地看到它们如何被使用。</p>
</blockquote>
<p>当声明一个归纳数据类型时，你可以使用<code>deriving Repr</code>来指示Lean 生成一个函数，将<code>Weekday</code>对象转换为文本。这个函数被<code>#eval</code>命令用来显示<code>Weekday</code>对象。</p>
<pre><code class="language-lean">inductive Weekday where
  | sunday
  | monday
  | tuesday
  | wednesday
  | thursday
  | friday
  | saturday
  deriving Repr

open Weekday

#eval tuesday   -- Weekday.tuesday
</code></pre>
<!--
It is often useful to group definitions and theorems related to a
structure in a namespace with the same name. For example, we can put
the ``numberOfDay`` function in the ``Weekday`` namespace. We are
then allowed to use the shorter name when we open the namespace.

We can define functions from ``Weekday`` to ``Weekday``:
-->
<p>将与某一结构相关的定义和定理归入同名的命名空间通常很有用。例如，我们可以将 <code>numberOfDay</code> 函数放在 <code>Weekday</code> 命名空间中。然后当我们打开命名空间时，我们就可以使用较短的名称。</p>
<p>我们可以定义从 <code>Weekday</code> 到 <code>Weekday</code> 的函数：</p>
<pre><code class="language-lean"><span class="boring">inductive Weekday where
</span><span class="boring"> | sunday : Weekday
</span><span class="boring"> | monday : Weekday
</span><span class="boring"> | tuesday : Weekday
</span><span class="boring"> | wednesday : Weekday
</span><span class="boring"> | thursday : Weekday
</span><span class="boring"> | friday : Weekday
</span><span class="boring"> | saturday : Weekday
</span><span class="boring"> deriving Repr
</span>namespace Weekday
def next (d : Weekday) : Weekday :=
  match d with
  | sunday    =&gt; monday
  | monday    =&gt; tuesday
  | tuesday   =&gt; wednesday
  | wednesday =&gt; thursday
  | thursday  =&gt; friday
  | friday    =&gt; saturday
  | saturday  =&gt; sunday

def previous (d : Weekday) : Weekday :=
  match d with
  | sunday    =&gt; saturday
  | monday    =&gt; sunday
  | tuesday   =&gt; monday
  | wednesday =&gt; tuesday
  | thursday  =&gt; wednesday
  | friday    =&gt; thursday
  | saturday  =&gt; friday

#eval next (next tuesday)      -- Weekday.thursday
#eval next (previous tuesday)  -- Weekday.tuesday

example : next (previous tuesday) = tuesday :=
  rfl

end Weekday
</code></pre>
<!--
How can we prove the general theorem that ``next (previous d) = d``
for any Weekday ``d``? You can use `match` to provide a proof of the claim for each
constructor:
-->
<p>我们如何证明 <code>next (previous d) = d</code> 对于任何Weekday<code>d</code> 的一般定理？你可以使用<code>match</code>来为每个构造子提供一个证明：</p>
<pre><code class="language-lean"><span class="boring">inductive Weekday where
</span><span class="boring"> | sunday : Weekday
</span><span class="boring"> | monday : Weekday
</span><span class="boring"> | tuesday : Weekday
</span><span class="boring"> | wednesday : Weekday
</span><span class="boring"> | thursday : Weekday
</span><span class="boring"> | friday : Weekday
</span><span class="boring"> | saturday : Weekday
</span><span class="boring"> deriving Repr
</span><span class="boring">namespace Weekday
</span><span class="boring">def next (d : Weekday) : Weekday :=
</span><span class="boring"> match d with
</span><span class="boring"> | sunday    =&gt; monday
</span><span class="boring"> | monday    =&gt; tuesday
</span><span class="boring"> | tuesday   =&gt; wednesday
</span><span class="boring"> | wednesday =&gt; thursday
</span><span class="boring"> | thursday  =&gt; friday
</span><span class="boring"> | friday    =&gt; saturday
</span><span class="boring"> | saturday  =&gt; sunday
</span><span class="boring">def previous (d : Weekday) : Weekday :=
</span><span class="boring"> match d with
</span><span class="boring"> | sunday    =&gt; saturday
</span><span class="boring"> | monday    =&gt; sunday
</span><span class="boring"> | tuesday   =&gt; monday
</span><span class="boring"> | wednesday =&gt; tuesday
</span><span class="boring"> | thursday  =&gt; wednesday
</span><span class="boring"> | friday    =&gt; thursday
</span><span class="boring"> | saturday  =&gt; friday
</span>def next_previous (d : Weekday) : next (previous d) = d :=
  match d with
  | sunday    =&gt; rfl
  | monday    =&gt; rfl
  | tuesday   =&gt; rfl
  | wednesday =&gt; rfl
  | thursday  =&gt; rfl
  | friday    =&gt; rfl
  | saturday  =&gt; rfl
</code></pre>
<!--
Using a tactic proof, we can be even more concise:
-->
<p>用策略证明更简洁：（复习：组合器<code>tac1 &lt;;&gt; tac2</code>，意为将<code>tac2</code>应用于策略<code>tac1</code>产生的每个子目标。）</p>
<pre><code class="language-lean"><span class="boring">inductive Weekday where
</span><span class="boring"> | sunday : Weekday
</span><span class="boring"> | monday : Weekday
</span><span class="boring"> | tuesday : Weekday
</span><span class="boring"> | wednesday : Weekday
</span><span class="boring"> | thursday : Weekday
</span><span class="boring"> | friday : Weekday
</span><span class="boring"> | saturday : Weekday
</span><span class="boring"> deriving Repr
</span><span class="boring">namespace Weekday
</span><span class="boring">def next (d : Weekday) : Weekday :=
</span><span class="boring"> match d with
</span><span class="boring"> | sunday    =&gt; monday
</span><span class="boring"> | monday    =&gt; tuesday
</span><span class="boring"> | tuesday   =&gt; wednesday
</span><span class="boring"> | wednesday =&gt; thursday
</span><span class="boring"> | thursday  =&gt; friday
</span><span class="boring"> | friday    =&gt; saturday
</span><span class="boring"> | saturday  =&gt; sunday
</span><span class="boring">def previous (d : Weekday) : Weekday :=
</span><span class="boring"> match d with
</span><span class="boring"> | sunday    =&gt; saturday
</span><span class="boring"> | monday    =&gt; sunday
</span><span class="boring"> | tuesday   =&gt; monday
</span><span class="boring"> | wednesday =&gt; tuesday
</span><span class="boring"> | thursday  =&gt; wednesday
</span><span class="boring"> | friday    =&gt; thursday
</span><span class="boring"> | saturday  =&gt; friday
</span>def next_previous (d : Weekday) : next (previous d) = d := by
  cases d &lt;;&gt; rfl
</code></pre>
<!--
[Tactics for Inductive Types](#tactics-for-inductive-types) below will introduce additional
tactics that are specifically designed to make use of inductive types.

Notice that, under the propositions-as-types correspondence, we can
use ``match`` to prove theorems as well as define functions.  In other
words, under the propositions-as-types correspondence, the proof by
cases is a kind of definition by cases, where what is being "defined"
is a proof instead of a piece of data.

The `Bool` type in the Lean library is an instance of
enumerated type.
-->
<p>下面的<a href="inductive_types.html#%E5%BD%92%E7%BA%B3%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%AD%96%E7%95%A5">归纳类型的策略</a>一节将介绍额外的策略，这些策略是专门为利用归纳类型而设计。</p>
<p>命题即类型的对应原则下，我们可以使用 <code>match</code> 来证明定理和定义函数。换句话说，逐情况证明是一种逐情况定义的另一表现形式，其中被「定义」的是一个证明而不是一段数据。</p>
<p>Lean 库中的<code>Bool</code>类型是一个枚举类型的实例。</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>inductive Bool where
  | false : Bool
  | true  : Bool
<span class="boring">end Hidden
</span></code></pre>
<!--
(To run these examples, we put them in a namespace called ``Hidden``,
so that a name like ``Bool`` does not conflict with the ``Bool`` in
the standard library. This is necessary because these types are part
of the Lean "prelude" that is automatically imported when the system
is started.)

As an exercise, you should think about what the introduction and
elimination rules for these types do. As a further exercise, we
suggest defining boolean operations ``and``, ``or``, ``not`` on the
``Bool`` type, and verifying common identities. Note that you can define a
binary operation like ``and`` using `match`:
-->
<p>（为了运行这个例子，我们把它们放在一个叫做 <code>Hidden</code> 的命名空间中，这样像 <code>Bool</code> 这样的名字就不会和标准库中的 <code>Bool</code> 冲突。这是必要的，因为这些类型是Lean「启动工作」的一部分，在系统启动时被自动导入）。</p>
<p>作为一个练习，你应该思考这些类型的引入和消去规则的作用。作为进一步的练习，我们建议在 <code>Bool</code> 类型上定义布尔运算 <code>and</code>、<code>or</code>、<code>not</code>，并验证其共性。提示，你可以使用<code>match</code>来定义像<code>and</code>这样的二元运算：</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>def and (a b : Bool) : Bool :=
  match a with
  | true  =&gt; b
  | false =&gt; false
<span class="boring">end Hidden
</span></code></pre>
<!--
Similarly, most identities can be proved by introducing suitable `match`, and then using ``rfl``.
-->
<p>同样地，大多数等式可以通过引入合适的<code>match</code>，然后使用 <code>rfl</code> 来证明。</p>
<!--
Constructors with Arguments
---------------------------
-->
<h2 id="带参数的构造子"><a class="header" href="#带参数的构造子">带参数的构造子</a></h2>
<!--
Enumerated types are a very special case of inductive types, in which
the constructors take no arguments at all. In general, a
"construction" can depend on data, which is then represented in the
constructed argument. Consider the definitions of the product type and
sum type in the library:
-->
<p>枚举类型是归纳类型的一种非常特殊的情况，其中构造子根本不需要参数。一般来说，「构造」可以依赖于数据，然后在构造参数中表示。考虑一下库中的乘积类型和求和类型的定义:</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>inductive Prod (α : Type u) (β : Type v)
  | mk : α → β → Prod α β

inductive Sum (α : Type u) (β : Type v) where
  | inl : α → Sum α β
  | inr : β → Sum α β
<span class="boring">end Hidden
</span></code></pre>
<!--
Consider what is going on in these examples.
The product type has one constructor, ``Prod.mk``,
which takes two arguments. To define a function on ``Prod α β``, we
can assume the input is of the form ``Prod.mk a b``, and we have to
specify the output, in terms of ``a`` and ``b``. We can use this to
define the two projections for ``Prod``. Remember that the standard
library defines notation ``α × β`` for ``Prod α β`` and ``(a, b)`` for
``Prod.mk a b``.
-->
<p>思考一下这些例子中发生了什么。乘积类型有一个构造子 <code>Prod.mk</code>，它需要两个参数。要在 <code>Prod α β</code> 上定义一个函数，我们可以假设输入的形式是 <code>Prod.mk a b</code>，而我们必须指定输出，用 <code>a</code> 和 <code>b</code> 来表示。我们可以用它来定义 <code>Prod</code> 的两个投影。标准库定义的符号 <code>α × β</code> 表示 <code>Prod α β</code>，<code>(a, b)</code> 表示 <code>Prod.mk a b</code>。</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span><span class="boring">inductive Prod (α : Type u) (β : Type v)
</span><span class="boring">  | mk : α → β → Prod α β
</span>def fst {α : Type u} {β : Type v} (p : Prod α β) : α :=
  match p with
  | Prod.mk a b =&gt; a

def snd {α : Type u} {β : Type v} (p : Prod α β) : β :=
  match p with
  | Prod.mk a b =&gt; b
<span class="boring">end Hidden
</span></code></pre>
<!--
The function ``fst`` takes a pair, ``p``. The `match` interprets
``p`` as a pair, ``Prod.mk a b``. Recall also from [Dependent Type Theory](./dependent_type_theory.md)
that to give these definitions the greatest generality possible, we allow
the types ``α`` and ``β`` to belong to any universe.

Here is another example where we use the recursor `Prod.casesOn` instead
of `match`.
-->
<p>函数 <code>fst</code> 接收一个对 <code>p</code>。<code>match</code> 将<code>p</code>解释为一个对 <code>Prod.mk a b</code>。还记得在<a href="./dependent_type_theory.html">依值类型论</a>中，为了给这些定义以最大的通用性，我们允许类型 <code>α</code> 和 <code>β</code> 属于任何宇宙。</p>
<p>下面是另一个例子，我们用递归器<code>Prod.casesOn</code>代替<code>match</code>。</p>
<pre><code class="language-lean">def prod_example (p : Bool × Nat) : Nat :=
  Prod.casesOn (motive := fun _ =&gt; Nat) p (fun b n =&gt; cond b (2 * n) (2 * n + 1))

#eval prod_example (true, 3)
#eval prod_example (false, 3)
</code></pre>
<!--
The argument `motive` is used to specify the type of the object you want to
construct, and it is a function because it may depend on the pair.
The ``cond`` function is a boolean conditional: ``cond b t1 t2``
returns ``t1`` if ``b`` is true, and ``t2`` otherwise.
The function ``prod_example`` takes a pair consisting of a boolean,
``b``, and a number, ``n``, and returns either ``2 * n`` or ``2 * n + 1``
according to whether ``b`` is true or false.

In contrast, the sum type has *two* constructors, ``inl`` and ``inr``
(for "insert left" and "insert right"), each of which takes *one*
(explicit) argument. To define a function on ``Sum α β``, we have to
handle two cases: either the input is of the form ``inl a``, in which
case we have to specify an output value in terms of ``a``, or the
input is of the form ``inr b``, in which case we have to specify an
output value in terms of ``b``.
-->
<p>参数<code>motive</code>是用来指定你要构造的对象的类型，它是一个依值的函数，<code>_</code>是被自动推断出的类型，此处即<code>Bool × Nat</code>。函数<code>cond</code>是一个布尔条件：<code>cond b t1 t2</code>，如果<code>b</code>为真，返回<code>t1</code>，否则返回<code>t2</code>。函数<code>prod_example</code>接收一个由布尔值<code>b</code>和一个数字<code>n</code>组成的对，并根据<code>b</code>为真或假返回<code>2 * n</code>或<code>2 * n + 1</code>。</p>
<p>相比之下，求和类型有<em>两个</em>构造子<code>inl</code>和<code>inr</code>（表示「从左引入」和「从右引入」），每个都需要 <strong>一个</strong> （显式的）参数。要在 <code>Sum α β</code> 上定义一个函数，我们必须处理两种情况：要么输入的形式是 <code>inl a</code>，由此必须依据 <code>a</code> 指定一个输出值；要么输入的形式是 <code>inr b</code>，由此必须依据 <code>b</code> 指定一个输出值。</p>
<pre><code class="language-lean">def sum_example (s : Sum Nat Nat) : Nat :=
  Sum.casesOn (motive := fun _ =&gt; Nat) s
    (fun n =&gt; 2 * n)
    (fun n =&gt; 2 * n + 1)

#eval sum_example (Sum.inl 3)
#eval sum_example (Sum.inr 3)
</code></pre>
<!--
This example is similar to the previous one, but now an input to
``sum_example`` is implicitly either of the form ``inl n`` or ``inr n``.
In the first case, the function returns ``2 * n``, and the second
case, it returns ``2 * n + 1``.

Notice that the product type depends on parameters ``α β : Type``
which are arguments to the constructors as well as ``Prod``. Lean
detects when these arguments can be inferred from later arguments to a
constructor or the return type, and makes them implicit in that case.

In [Section Defining the Natural Numbers](#defining-the-natural-numbers)
we will see what happens when the
constructor of an inductive type takes arguments from the inductive
type itself. What characterizes the examples we consider in this
section is that each constructor relies only on previously specified types.

Notice that a type with multiple constructors is disjunctive: an
element of ``Sum α β`` is either of the form ``inl a`` *or* of the
form ``inl b``. A constructor with multiple arguments introduces
conjunctive information: from an element ``Prod.mk a b`` of
``Prod α β`` we can extract ``a`` *and* ``b``. An arbitrary inductive type can
include both features, by having any number of constructors, each of
which takes any number of arguments.

As with function definitions, Lean's inductive definition syntax will
let you put named arguments to the constructors before the colon:
-->
<p>这个例子与前面的例子类似，但现在输入到<code>sum_example</code>的内容隐含了<code>inl n</code>或<code>inr n</code>的形式。在第一种情况下，函数返回 <code>2 * n</code>，第二种情况下，它返回 <code>2 * n + 1</code>。</p>
<p>注意，乘积类型取决于参数<code>α β : Type</code>，这些参数是构造子和<code>Prod</code>的参数。Lean 会检测这些参数何时可以从构造子的参数或返回类型中推断出来，并在这种情况下使其隐式。</p>
<p>在<a href="inductive_types.html#%E5%AE%9A%E4%B9%89%E8%87%AA%E7%84%B6%E6%95%B0">定义自然数</a>一节中，我们将看到当归纳类型的构造子从归纳类型本身获取参数时会发生什么。本节考虑的例子暂时不是这样：每个构造子只依赖于先前指定的类型。</p>
<p>一个有多个构造子的类型是析取的：<code>Sum α β</code> 的一个元素要么是 <code>inl a</code> 的形式，要么是 <code>inl b</code> 的形式。一个有多个参数的构造子引入了合取信息：从 <code>Prod.mk a b</code> 的元素 <code>Prod α β</code> 中我们可以提取 <code>a</code><em>和</em><code>b</code>。一个任意的归纳类型可以包括这两个特征：拥有任意数量的构造子，每个构造子都需要任意数量的参数。</p>
<p>和函数定义一样，Lean 的归纳定义语法可以让你把构造子的命名参数放在冒号之前：</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>inductive Prod (α : Type u) (β : Type v) where
  | mk (fst : α) (snd : β) : Prod α β

inductive Sum (α : Type u) (β : Type v) where
  | inl (a : α) : Sum α β
  | inr (b : β) : Sum α β
<span class="boring">end Hidden
</span></code></pre>
<!--
The results of these definitions are essentially the same as the ones given earlier in this section.

A type, like ``Prod``, that has only one constructor is purely
conjunctive: the constructor simply packs the list of arguments into a
single piece of data, essentially a tuple where the type of subsequent
arguments can depend on the type of the initial argument. We can also
think of such a type as a "record" or a "structure". In Lean, the
keyword ``structure`` can be used to define such an inductive type as
well as its projections, at the same time.
-->
<p>这些定义的结果与本节前面给出的定义基本相同。</p>
<p>像 <code>Prod</code> 这样只有一个构造子的类型是纯粹的合取型：构造子只是将参数列表打包成一块数据，基本上是一个元组，后续参数的类型可以取决于初始参数的类型。我们也可以把这样的类型看作是一个「记录」或「结构体」。在Lean 中，关键词 <code>structure</code> 可以用来同时定义这样一个归纳类型以及它的投影。</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>structure Prod (α : Type u) (β : Type v) where
  mk :: (fst : α) (snd : β)
<span class="boring">end Hidden
</span></code></pre>
<!--
This example simultaneously introduces the inductive type, ``Prod``,
its constructor, ``mk``, the usual eliminators (``rec`` and
``recOn``), as well as the projections, ``fst`` and ``snd``, as
defined above.

If you do not name the constructor, Lean uses ``mk`` as a default. For
example, the following defines a record to store a color as a triple
of RGB values:
-->
<p>这个例子同时引入了归纳类型 <code>Prod</code>，它的构造子 <code>mk</code>，通常的消去器（<code>rec</code> 和 <code>recOn</code>），以及投影 <code>fst</code> 和 <code>snd</code>。</p>
<p>如果你没有命名构造子，Lean 使用<code>mk</code>作为默认值。例如，下面定义了一个记录，将一个颜色存储为RGB值的三元组：</p>
<pre><code class="language-lean">structure Color where
  (red : Nat) (green : Nat) (blue : Nat)
  deriving Repr

def yellow := Color.mk 255 255 0

#eval Color.red yellow
</code></pre>
<!--
The definition of ``yellow`` forms the record with the three values
shown, and the projection ``Color.red`` returns the red component.

You can avoid the parentheses if you add a line break between each field.
-->
<p><code>yellow</code> 的定义形成了有三个值的记录，而投影 <code>Color.red</code> 则返回红色成分。</p>
<p>如果你在每个字段之间加一个换行符，就可以不用括号。</p>
<pre><code class="language-lean">structure Color where
  red : Nat
  green : Nat
  blue : Nat
  deriving Repr
</code></pre>
<!--
The ``structure`` command is especially useful for defining algebraic
structures, and Lean provides substantial infrastructure to support
working with them. Here, for example, is the definition of a
semigroup:
-->
<p><code>structure</code> 命令对于定义代数结构特别有用，Lean 提供了大量的基础设施来支持对它们的处理。例如，这里是一个半群的定义：</p>
<pre><code class="language-lean">structure Semigroup where
  carrier : Type u
  mul : carrier → carrier → carrier
  mul_assoc : ∀ a b c, mul (mul a b) c = mul a (mul b c)
</code></pre>
<!--
We will see more examples in [Chapter Structures and Records](./structures_and_records.md).

We have already discussed the dependent product type `Sigma`:
-->
<p>更多例子见<a href="./structures_and_records.html">结构体和记录</a>。</p>
<p>我们已经讨论了依值乘积类型<code>Sigma</code>：</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>inductive Sigma {α : Type u} (β : α → Type v) where
  | mk : (a : α) → β a → Sigma β
<span class="boring">end Hidden
</span></code></pre>
<!--
Two more examples of inductive types in the library are the following:
-->
<p>库中另两个归纳类型的例子：</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>inductive Option (α : Type u) where
  | none : Option α
  | some : α → Option α

inductive Inhabited (α : Type u) where
  | mk : α → Inhabited α
<span class="boring">end Hidden
</span></code></pre>
<!--
In the semantics of dependent type theory, there is no built-in notion
of a partial function. Every element of a function type ``α → β`` or a
dependent function type ``(a : α) → β`` is assumed to have a value
at every input. The ``Option`` type provides a way of representing partial functions. An
element of ``Option β`` is either ``none`` or of the form ``some b``,
for some value ``b : β``. Thus we can think of an element ``f`` of the
type ``α → Option β`` as being a partial function from ``α`` to ``β``:
for every ``a : α``, ``f a`` either returns ``none``, indicating
``f a`` is "undefined", or ``some b``.

An element of ``Inhabited α`` is simply a witness to the fact that
there is an element of ``α``. Later, we will see that ``Inhabited`` is
an example of a *type class* in Lean: Lean can be instructed that
suitable base types are inhabited, and can automatically infer that
other constructed types are inhabited on that basis.

As exercises, we encourage you to develop a notion of composition for
partial functions from ``α`` to ``β`` and ``β`` to ``γ``, and show
that it behaves as expected. We also encourage you to show that
``Bool`` and ``Nat`` are inhabited, that the product of two inhabited
types is inhabited, and that the type of functions to an inhabited
type is inhabited.
-->
<p>在依值类型论的语义中，没有内置的部分函数的概念。一个函数类型 <code>α → β</code> 或一个依值函数类型 <code>(a : α) → β</code> 的每个元素都被假定为在每个输入端有一个值。<code>Option</code> 类型提供了一种表示部分函数的方法。<code>Option β</code>的一个元素要么是<code>none</code>，要么是<code>some b</code>的形式，用于某个值<code>b : β</code>。因此我们可以认为<code>α → Option β</code>类型的元素<code>f</code>是一个从<code>α</code>到<code>β</code>的部分函数：对于每一个<code>a : α</code>，<code>f a</code>要么返回<code>none</code>，表示<code>f a</code>是「未定义」，要么返回<code>some b</code>。</p>
<p><code>Inhabited α</code>的一个元素只是证明了<code>α</code>有一个元素的事实。稍后，我们将看到 <code>Inhabited</code> 是Lean 中<em>类型类</em>的一个例子：Lean 可以被告知合适的基础类型是含有元素的，并且可以在此基础上自动推断出其他构造类型是含有元素的。</p>
<p>作为练习，我们鼓励你建立一个从 <code>α</code> 到 <code>β</code> 和 <code>β</code> 到 <code>γ</code> 的部分函数的组合概念，并证明其行为符合预期。我们也鼓励你证明 <code>Bool</code> 和 <code>Nat</code> 是含有元素的，两个含有元素的类型的乘积是含有元素的，以及到一个含有元素的类型的函数类型是含有元素的。</p>
<!--
Inductively Defined Propositions
--------------------------------
-->
<h2 id="归纳定义的命题"><a class="header" href="#归纳定义的命题">归纳定义的命题</a></h2>
<!--
Inductively defined types can live in any type universe, including the
bottom-most one, ``Prop``. In fact, this is exactly how the logical
connectives are defined.
-->
<p>归纳定义的类型可以存在于任何类型宇宙中，包括最底层的类型，<code>Prop</code>。事实上，这正是逻辑连接词的定义方式。</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>inductive False : Prop

inductive True : Prop where
  | intro : True

inductive And (a b : Prop) : Prop where
  | intro : a → b → And a b

inductive Or (a b : Prop) : Prop where
  | inl : a → Or a b
  | inr : b → Or a b
<span class="boring">end Hidden
</span></code></pre>
<!--
You should think about how these give rise to the introduction and
elimination rules that you have already seen. There are rules that
govern what the eliminator of an inductive type can eliminate *to*,
that is, what kinds of types can be the target of a recursor. Roughly
speaking, what characterizes inductive types in ``Prop`` is that one
can only eliminate to other types in ``Prop``. This is consistent with
the understanding that if ``p : Prop``, an element ``hp : p`` carries
no data. There is a small exception to this rule, however, which we
will discuss below, in [Section Inductive Families](#inductive-families).

Even the existential quantifier is inductively defined:
-->
<p>你应该想一想这些是如何产生你已经看到的引入和消去规则的。有一些规则规定了归纳类型的消去器可以去消去什么，或者说，哪些类型可以成为递归器的目标。粗略地说，<code>Prop</code> 中的归纳类型的特点是，只能消去成 <code>Prop</code> 中的其他类型。这与以下理解是一致的：如果 <code>p : Prop</code>，一个元素 <code>hp : p</code> 不携带任何数据。然而，这个规则有一个小的例外，我们将在<a href="inductive_types.html#%E5%BD%92%E7%BA%B3%E6%97%8F">归纳族</a>一节中讨论。</p>
<p>甚至存在量词也是归纳式定义的：</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>inductive Exists {α : Sort u} (p : α → Prop) : Prop where
  | intro (w : α) (h : p w) : Exists p
<span class="boring">end Hidden
</span></code></pre>
<!--
Keep in mind that the notation ``∃ x : α, p`` is syntactic sugar for ``Exists (fun x : α => p)``.

The definitions of ``False``, ``True``, ``And``, and ``Or`` are
perfectly analogous to the definitions of ``Empty``, ``Unit``,
``Prod``, and ``Sum``. The difference is that the first group yields
elements of ``Prop``, and the second yields elements of ``Type u`` for
some ``u``. In a similar way, ``∃ x : α, p`` is a ``Prop``-valued
variant of ``Σ x : α, p``.

This is a good place to mention another inductive type, denoted
``{x : α // p}``, which is sort of a hybrid between
``∃ x : α, P`` and ``Σ x : α, P``.
-->
<p>请记住，符号 <code>∃ x : α, p</code> 是 <code>Exists (fun x : α =&gt; p)</code> 的语法糖。</p>
<p><code>False</code>, <code>True</code>, <code>And</code>和<code>Or</code>的定义与<code>Empty</code>, <code>Unit</code>, <code>Prod</code>和<code>Sum</code>的定义完全类似。不同的是，第一组产生的是<code>Prop</code>的元素，第二组产生的是<code>Type u</code>的元素，适用于某些<code>u</code>。类似地，<code>∃ x : α, p</code> 是 <code>Σ x : α, p</code> 的 <code>Prop</code> 值的变体。</p>
<p>这里可以提到另一个归纳类型，表示为<code>{x : α // p}</code>，它有点像<code>∃ x : α, P</code>和<code>Σ x : α, P</code>之间的混合。</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>inductive Subtype {α : Type u} (p : α → Prop) where
  | mk : (x : α) → p x → Subtype p
<span class="boring">end Hidden
</span></code></pre>
<!--
In fact, in Lean, ``Subtype`` is defined using the structure command:
-->
<p>事实上，在Lean 中，<code>Subtype</code> 是用结构体命令定义的。</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>structure Subtype {α : Sort u} (p : α → Prop) where
  val : α
  property : p val
<span class="boring">end Hidden
</span></code></pre>
<!--
The notation ``{x : α // p x}`` is syntactic sugar for ``Subtype (fun x : α => p x)``.
It is modeled after subset notation in set theory: the idea is that ``{x : α // p x}``
denotes the collection of elements of ``α`` that have property ``p``.
-->
<p>符号<code>{x : α // p x}</code>是 <code>Subtype (fun x : α =&gt; p x)</code> 的语法糖。它仿照集合理论中的子集表示法：<code>{x : α // p x}</code>表示具有属性<code>p</code>的<code>α</code>元素的集合。</p>
<!--
Defining the Natural Numbers
----------------------------
-->
<h2 id="定义自然数"><a class="header" href="#定义自然数">定义自然数</a></h2>
<!--
The inductively defined types we have seen so far are "flat":
constructors wrap data and insert it into a type, and the
corresponding recursor unpacks the data and acts on it. Things get
much more interesting when the constructors act on elements of the
very type being defined. A canonical example is the type ``Nat`` of
natural numbers:
-->
<p>到目前为止，我们所看到的归纳定义的类型都是「无趣的」：构造子打包数据并将其插入到一个类型中，而相应的递归器则解压数据并对其进行操作。当构造子作用于被定义的类型中的元素时，事情就变得更加有趣了。一个典型的例子是自然数 <code>Nat</code> 类型：</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>inductive Nat where
  | zero : Nat
  | succ : Nat → Nat
<span class="boring">end Hidden
</span></code></pre>
<!--
There are two constructors. We start with ``zero : Nat``; it takes
no arguments, so we have it from the start. In contrast, the
constructor ``succ`` can only be applied to a previously constructed
``Nat``. Applying it to ``zero`` yields ``succ zero : Nat``. Applying
it again yields ``succ (succ zero) : Nat``, and so on. Intuitively,
``Nat`` is the "smallest" type with these constructors, meaning that
it is exhaustively (and freely) generated by starting with ``zero``
and applying ``succ`` repeatedly.

As before, the recursor for ``Nat`` is designed to define a dependent
function ``f`` from ``Nat`` to any domain, that is, an element ``f``
of ``(n : Nat) → motive n`` for some ``motive : Nat → Sort u``.
It has to handle two cases: the case where the input is ``zero``, and the case where
the input is of the form ``succ n`` for some ``n : Nat``. In the first
case, we simply specify a target value with the appropriate type, as
before. In the second case, however, the recursor can assume that a
value of ``f`` at ``n`` has already been computed. As a result, the
next argument to the recursor specifies a value for ``f (succ n)`` in
terms of ``n`` and ``f n``. If we check the type of the recursor,
-->
<p>有两个构造子，我们从 <code>zero : Nat</code> 开始；它不需要参数，所以我们一开始就有了它。相反，构造子<code>succ</code>只能应用于先前构造的<code>Nat</code>。将其应用于 <code>zero</code>，得到 <code>succ zero : Nat</code>。再次应用它可以得到<code>succ (succ zero) : Nat</code>，依此类推。直观地说，<code>Nat</code>是具有这些构造子的「最小」类型，这意味着它是通过从<code>zero</code>开始并重复应用<code>succ</code>这样无穷无尽地（并且自由地）生成的。</p>
<p>和以前一样，<code>Nat</code> 的递归器被设计用来定义一个从 <code>Nat</code> 到任何域的依值函数<code>f</code>，也就是一个<code>(n : nat) → motive n</code>的元素<code>f</code>，其中<code>motive : Nat → Sort u</code>。它必须处理两种情况：一种是输入为 <code>zero</code> 的情况，另一种是输入为 <code>succ n</code> 的情况，其中 <code>n : Nat</code>。在第一种情况下，我们只需指定一个适当类型的目标值，就像以前一样。但是在第二种情况下，递归器可以假设在<code>n</code>处的<code>f</code>的值已经被计算过了。因此，递归器的下一个参数是以<code>n</code>和<code>f n</code>来指定<code>f (succ n)</code>的值。</p>
<p>如果我们检查递归器的类型：</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span><span class="boring">inductive Nat where
</span><span class="boring"> | zero : Nat
</span><span class="boring"> | succ : Nat → Nat
</span>#check @Nat.rec
<span class="boring">end Hidden
</span></code></pre>
<!--
you find the following:
-->
<p>你会得到：</p>
<pre><code>  {motive : Nat → Sort u}
  → motive Nat.zero
  → ((n : Nat) → motive n → motive (Nat.succ n))
  → (t : Nat) → motive t
</code></pre>
<!--
The implicit argument, ``motive``, is the codomain of the function being defined.
In type theory it is common to say ``motive`` is the *motive* for the elimination/recursion,
since it describes the kind of object we wish to construct.
The next two arguments specify how to compute the zero and successor cases, as described above.
They are also known as the *minor premises*.
Finally, the ``t : Nat``, is the input to the function. It is also known as the *major premise*.

The `Nat.recOn` is similar to `Nat.rec` but the major premise occurs before the minor premises.
-->
<p>隐参数 <code>motive</code>，是被定义的函数的陪域。在类型论中，通常说 <code>motive</code> 是消去/递归的 <strong>目的</strong> ，因为它描述了我们希望构建的对象类型。接下来的两个参数指定了如何计算零和后继的情况，如上所述。它们也被称为小前提 <code>minor premises</code>。最后，<code>t : Nat</code>，是函数的输入。它也被称为大前提 <code>major premise</code>。</p>
<p><code>Nat.recOn</code>与<code>Nat.rec</code>类似，但大前提发生在小前提之前。</p>
<pre><code>@Nat.recOn :
  {motive : Nat → Sort u}
  → (t : Nat)
  → motive Nat.zero
  → ((n : Nat) → motive n → motive (Nat.succ n))
  → motive t
</code></pre>
<!--
Consider, for example, the addition function ``add m n`` on the
natural numbers. Fixing ``m``, we can define addition by recursion on
``n``. In the base case, we set ``add m zero`` to ``m``. In the
successor step, assuming the value ``add m n`` is already determined,
we define ``add m (succ n)`` to be ``succ (add m n)``.
-->
<p>例如，考虑自然数上的加法函数 <code>add m n</code>。固定<code>m</code>，我们可以通过递归来定义<code>n</code>的加法。在基本情况下，我们将<code>add m zero</code>设为<code>m</code>。在后续步骤中，假设<code>add m n</code>的值已经确定，我们将<code>add m (succ n)</code>定义为<code>succ (add m n)</code>。</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>inductive Nat where
  | zero : Nat
  | succ : Nat → Nat
  deriving Repr

def add (m n : Nat) : Nat :=
  match n with
  | Nat.zero   =&gt; m
  | Nat.succ n =&gt; Nat.succ (add m n)

open Nat

#eval add (succ (succ zero)) (succ zero)
<span class="boring">end Hidden
</span></code></pre>
<!--
It is useful to put such definitions into a namespace, ``Nat``. We can
then go on to define familiar notation in that namespace. The two
defining equations for addition now hold definitionally:
-->
<p>将这些定义放入一个命名空间 <code>Nat</code> 是很有用的。然后我们可以继续在这个命名空间中定义熟悉的符号。现在加法的两个定义方程是成立的：</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span><span class="boring">inductive Nat where
</span><span class="boring"> | zero : Nat
</span><span class="boring"> | succ : Nat → Nat
</span><span class="boring"> deriving Repr
</span>namespace Nat

def add (m n : Nat) : Nat :=
  match n with
  | Nat.zero   =&gt; m
  | Nat.succ n =&gt; Nat.succ (add m n)

instance : Add Nat where
  add := add

theorem add_zero (m : Nat) : m + zero = m := rfl
theorem add_succ (m n : Nat) : m + succ n = succ (m + n) := rfl

end Nat
<span class="boring">end Hidden
</span></code></pre>
<!--
We will explain how the ``instance`` command works in
[Chapter Type Classes](./type_classes.md). In the examples below, we will use
Lean's version of the natural numbers.

Proving a fact like ``zero + m = m``, however, requires a proof by induction.
As observed above, the induction principle is just a special case of the recursion principle,
when the codomain ``motive n`` is an element of ``Prop``. It represents the familiar
pattern of an inductive proof: to prove ``∀ n, motive n``, first prove ``motive 0``,
and then, for arbitrary ``n``, assume ``ih : motive n`` and prove ``motive (succ n)``.
-->
<p>我们将在<a href="./type_classes.html">类型类</a>一章中解释 <code>instance</code> 命令如何工作。我们以后的例子将使用Lean 自己的自然数版本。</p>
<p>然而，证明像 <code>zero + m = m</code> 这样的事实，需要用归纳法证明。如上所述，归纳原则只是递归原则的一个特例，其中陪域 <code>motive n</code> 是 <code>Prop</code> 的一个元素。它代表了熟悉的归纳证明模式：要证明 <code>∀ n, motive n</code>，首先要证明 <code>motive 0</code>，然后对于任意的 <code>n</code>，假设 <code>ih : motive n</code> 并证明 <code>motive (succ n)</code>。</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>open Nat

theorem zero_add (n : Nat) : 0 + n = n :=
  Nat.recOn (motive := fun x =&gt; 0 + x = x)
   n
   (show 0 + 0 = 0 from rfl)
   (fun (n : Nat) (ih : 0 + n = n) =&gt;
    show 0 + succ n = succ n from
    calc 0 + succ n
      _ = succ (0 + n) := rfl
      _ = succ n       := by rw [ih])
<span class="boring">end Hidden
</span></code></pre>
<!--
Notice that, once again, when ``Nat.recOn`` is used in the context of
a proof, it is really the induction principle in disguise. The
``rewrite`` and ``simp`` tactics tend to be very effective in proofs
like these. In this case, each can be used to reduce the proof to:
-->
<p>请注意，当 <code>Nat.recOn</code> 在证明中使用时，它实际上是变相的归纳原则。<code>rewrite</code> 和 <code>simp</code> 策略在这样的证明中往往非常有效。在这种情况下，证明可以化简成：</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>open Nat

theorem zero_add (n : Nat) : 0 + n = n :=
  Nat.recOn (motive := fun x =&gt; 0 + x = x) n
    rfl
    (fun n ih =&gt; by simp [add_succ, ih])
<span class="boring">end Hidden
</span></code></pre>
<!--
As another example, let us prove the associativity of addition,
``∀ m n k, m + n + k = m + (n + k)``.
(The notation ``+``, as we have defined it, associates to the left, so ``m + n + k`` is really ``(m + n) + k``.)
The hardest part is figuring out which variable to do the induction on. Since addition is defined by recursion on the second argument,
``k`` is a good guess, and once we make that choice the proof almost writes itself:
-->
<p>另一个例子，让我们证明加法结合律，<code>∀ m n k, m + n + k = m + (n + k)</code>。(我们定义的符号<code>+</code>是向左结合的，所以<code>m + n + k</code>实际上是<code>(m + n) + k</code>。) 最难的部分是确定在哪个变量上做归纳。由于加法是由第二个参数的递归定义的，<code>k</code> 是一个很好的猜测，一旦我们做出这个选择，证明几乎是顺理成章的：</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>open Nat
theorem add_assoc (m n k : Nat) : m + n + k = m + (n + k) :=
  Nat.recOn (motive := fun k =&gt; m + n + k = m + (n + k)) k
    (show m + n + 0 = m + (n + 0) from rfl)
    (fun k (ih : m + n + k = m + (n + k)) =&gt;
      show m + n + succ k = m + (n + succ k) from
      calc m + n + succ k
        _ = succ (m + n + k)   := rfl
        _ = succ (m + (n + k)) := by rw [ih]
        _ = m + succ (n + k)   := rfl
        _ = m + (n + succ k)   := rfl)
<span class="boring">end Hidden
</span></code></pre>
<!--
Once again, you can reduce the proof to:
-->
<p>你又可以化简证明：</p>
<pre><code class="language-lean">open Nat
theorem add_assoc (m n k : Nat) : m + n + k = m + (n + k) :=
  Nat.recOn (motive := fun k =&gt; m + n + k = m + (n + k)) k
    rfl
    (fun k ih =&gt; by simp [Nat.add_succ, ih])
</code></pre>
<!--
Suppose we try to prove the commutativity of addition. Choosing induction on the second argument, we might begin as follows:
-->
<p>假设我们试图证明加法交换律。选择第二个参数做归纳法，我们可以这样开始：</p>
<pre><code class="language-lean">open Nat
theorem add_comm (m n : Nat) : m + n = n + m :=
  Nat.recOn (motive := fun x =&gt; m + x = x + m) n
   (show m + 0 = 0 + m by rw [Nat.zero_add, Nat.add_zero])
   (fun (n : Nat) (ih : m + n = n + m) =&gt;
    show m + succ n = succ n + m from
    calc m + succ n
      _ = succ (m + n) := rfl
      _ = succ (n + m) := by rw [ih]
      _ = succ n + m   := sorry)
</code></pre>
<!--
At this point, we see that we need another supporting fact, namely, that ``succ (n + m) = succ n + m``.
You can prove this by induction on ``m``:
-->
<p>在这一点上，我们看到我们需要另一个事实，即 <code>succ (n + m) = succ n + m</code>。你可以通过对 <code>m</code> 的归纳来证明这一点：</p>
<pre><code class="language-lean">open Nat

theorem succ_add (n m : Nat) : succ n + m = succ (n + m) :=
  Nat.recOn (motive := fun x =&gt; succ n + x = succ (n + x)) m
    (show succ n + 0 = succ (n + 0) from rfl)
    (fun (m : Nat) (ih : succ n + m = succ (n + m)) =&gt;
     show succ n + succ m = succ (n + succ m) from
     calc succ n + succ m
       _ = succ (succ n + m)   := rfl
       _ = succ (succ (n + m)) := by rw [ih]
       _ = succ (n + succ m)   := rfl)
</code></pre>
<!--
You can then replace the ``sorry`` in the previous proof with ``succ_add``. Yet again, the proofs can be compressed:
-->
<p>然后你可以用 <code>succ_add</code> 代替前面证明中的 <code>sorry</code>。然而，证明可以再次压缩：</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>open Nat
theorem succ_add (n m : Nat) : succ n + m = succ (n + m) :=
  Nat.recOn (motive := fun x =&gt; succ n + x = succ (n + x)) m
    rfl
    (fun m ih =&gt; by simp only [add_succ, ih])

theorem add_comm (m n : Nat) : m + n = n + m :=
  Nat.recOn (motive := fun x =&gt; m + x = x + m) n
    (by simp)
    (fun m ih =&gt; by simp [add_succ, succ_add, ih])
<span class="boring">end Hidden
</span></code></pre>
<!--
Other Recursive Data Types
--------------------------
-->
<h2 id="其他递归数据类型"><a class="header" href="#其他递归数据类型">其他递归数据类型</a></h2>
<!--
Let us consider some more examples of inductively defined types. For
any type, ``α``, the type ``List α`` of lists of elements of ``α`` is
defined in the library.
-->
<p>让我们再考虑一些归纳定义类型的例子。对于任何类型 <code>α</code>，在库中定义了 <code>α</code> 的元素列表 <code>List α</code> 类型。</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>inductive List (α : Type u) where
  | nil  : List α
  | cons : α → List α → List α

namespace List

def append (as bs : List α) : List α :=
  match as with
  | nil       =&gt; bs
  | cons a as =&gt; cons a (append as bs)

theorem nil_append (as : List α) : append nil as = as :=
  rfl

theorem cons_append (a : α) (as bs : List α)
                    : append (cons a as) bs = cons a (append as bs) :=
  rfl

end List
<span class="boring">end Hidden
</span></code></pre>
<!--
A list of elements of type ``α`` is either the empty list, ``nil``, or
an element ``h : α`` followed by a list ``t : List α``.
The first element, ``h``, is commonly known as the "head" of the list,
and the remainder, ``t``, is known as the "tail."

As an exercise, prove the following:
-->
<p>一个 <code>α</code> 类型的元素列表，要么是空列表 <code>nil</code>，要么是一个元素 <code>h : α</code>，后面是一个列表 <code>t : List α</code>。第一个元素<code>h</code>，通常被称为列表的「头」，最后一个<code>t</code>，被称为「尾」。</p>
<p>作为一个练习，请证明以下内容：</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span><span class="boring">inductive List (α : Type u) where
</span><span class="boring">| nil  : List α
</span><span class="boring">| cons : α → List α → List α
</span><span class="boring">namespace List
</span><span class="boring">def append (as bs : List α) : List α :=
</span><span class="boring"> match as with
</span><span class="boring"> | nil       =&gt; bs
</span><span class="boring"> | cons a as =&gt; cons a (append as bs)
</span><span class="boring">theorem nil_append (as : List α) : append nil as = as :=
</span><span class="boring"> rfl
</span><span class="boring">theorem cons_append (a : α) (as bs : List α)
</span><span class="boring">                    : append (cons a as) bs = cons a (append as bs) :=
</span><span class="boring"> rfl
</span>theorem append_nil (as : List α) : append as nil = as :=
  sorry

theorem append_assoc (as bs cs : List α)
        : append (append as bs) cs = append as (append bs cs) :=
  sorry
<span class="boring">end List
</span><span class="boring">end Hidden
</span></code></pre>
<!--
Try also defining the function ``length : {α : Type u} → List α → Nat`` that returns the length of a list,
and prove that it behaves as expected (for example, ``length (append as bs) = length as + length bs``).

For another example, we can define the type of binary trees:
-->
<p>还可以尝试定义函数 <code>length : {α : Type u} → List α → Nat</code>，返回一个列表的长度，并证明它的行为符合我们的期望（例如，<code>length (append as bs) = length as + length bs</code>）。</p>
<p>另一个例子，我们可以定义二叉树的类型：</p>
<pre><code class="language-lean">inductive BinaryTree where
  | leaf : BinaryTree
  | node : BinaryTree → BinaryTree → BinaryTree
</code></pre>
<!--
In fact, we can even define the type of countably branching trees:
-->
<p>事实上，我们甚至可以定义可数多叉树的类型：</p>
<pre><code class="language-lean">inductive CBTree where
  | leaf : CBTree
  | sup : (Nat → CBTree) → CBTree

namespace CBTree

def succ (t : CBTree) : CBTree :=
  sup (fun _ =&gt; t)

def toCBTree : Nat → CBTree
  | 0 =&gt; leaf
  | n+1 =&gt; succ (toCBTree n)

def omega : CBTree :=
  sup toCBTree

end CBTree
</code></pre>
<!--
Tactics for Inductive Types
---------------------------
-->
<h2 id="归纳类型的策略"><a class="header" href="#归纳类型的策略">归纳类型的策略</a></h2>
<!--
Given the fundamental importance of inductive types in Lean, it should
not be surprising that there are a number of tactics designed to work
with them effectively. We describe some of them here.

The ``cases`` tactic works on elements of an inductively defined type,
and does what the name suggests: it decomposes the element according
to each of the possible constructors. In its most basic form, it is
applied to an element ``x`` in the local context. It then reduces the
goal to cases in which ``x`` is replaced by each of the constructions.
-->
<p>归纳类型在Lean 中有最根本的重要性，因此设计了一些方便使用的策略，这里讲几种。</p>
<p><code>cases</code> 策略适用于归纳定义类型的元素，正如其名称所示：它根据每个可能的构造子分解元素。在其最基本的形式中，它被应用于局部环境中的元素<code>x</code>。然后，它将目标还原为 <code>x</code> 被每个构成体所取代的情况。</p>
<pre><code class="language-lean">example (p : Nat → Prop) (hz : p 0) (hs : ∀ n, p (Nat.succ n)) : ∀ n, p n := by
  intro n
  cases n
  . exact hz  -- goal is p 0
  . apply hs  -- goal is a : Nat ⊢ p (succ a)
</code></pre>
<!--
There are extra bells and whistles. For one thing, ``cases`` allows
you to choose the names for each alternative using a
``with`` clause. In the next example, for example, we choose the name
``m`` for the argument to ``succ``, so that the second case refers to
``succ m``. More importantly, the cases tactic will detect any items
in the local context that depend on the target variable. It reverts
these elements, does the split, and reintroduces them. In the example
below, notice that the hypothesis ``h : n ≠ 0`` becomes ``h : 0 ≠ 0``
in the first branch, and ``h : succ m ≠ 0`` in the second.
-->
<p>还有一些额外的修饰功能。首先，<code>cases</code> 允许你使用 <code>with</code> 子句来选择每个选项的名称。例如在下一个例子中，我们为 <code>succ</code> 的参数选择<code>m</code>这个名字，这样第二个情况就指的是<code>succ m</code>。更重要的是，cases策略将检测局部环境中任何依赖于目标变量的项目。它将这些元素还原，进行拆分，并重新引入它们。在下面的例子中，注意假设<code>h : n ≠ 0</code>在第一个分支中变成<code>h : 0 ≠ 0</code>，在第二个分支中变成<code>h : succ m ≠ 0</code>。</p>
<pre><code class="language-lean">open Nat

example (n : Nat) (h : n ≠ 0) : succ (pred n) = n := by
  cases n with
  | zero =&gt;
    -- goal: h : 0 ≠ 0 ⊢ succ (pred 0) = 0
    apply absurd rfl h
  | succ m =&gt;
    -- second goal: h : succ m ≠ 0 ⊢ succ (pred (succ m)) = succ m
    rfl
</code></pre>
<!--
Notice that ``cases`` can be used to produce data as well as prove propositions.
-->
<p><code>cases</code> 可以用来产生数据，也可以用来证明命题。</p>
<pre><code class="language-lean">def f (n : Nat) : Nat := by
  cases n; exact 3; exact 7

example : f 0 = 3 := rfl
example : f 5 = 7 := rfl
</code></pre>
<!--
Once again, cases will revert, split, and then reintroduce dependencies in the context.
-->
<p>再一次，cases将被还原，分隔，然后在背景中重新引入依赖。</p>
<pre><code class="language-lean">def Tuple (α : Type) (n : Nat) :=
  { as : List α // as.length = n }

def f {n : Nat} (t : Tuple α n) : Nat := by
  cases n; exact 3; exact 7

def myTuple : Tuple Nat 3 :=
  ⟨[0, 1, 2], rfl⟩

example : f myTuple = 7 :=
  rfl
</code></pre>
<!--
Here is an example of multiple constructors with arguments.
-->
<p>下面是一个带有参数的多个构造子的例子。</p>
<pre><code class="language-lean">inductive Foo where
  | bar1 : Nat → Nat → Foo
  | bar2 : Nat → Nat → Nat → Foo

def silly (x : Foo) : Nat := by
  cases x with
  | bar1 a b =&gt; exact b
  | bar2 c d e =&gt; exact e
</code></pre>
<!--
The alternatives for each constructor don't need to be solved
in the order the constructors were declared.
-->
<p>每个构造子的备选项不需要按照构造子的声明顺序来求解。</p>
<pre><code class="language-lean"><span class="boring">inductive Foo where
</span><span class="boring">  | bar1 : Nat → Nat → Foo
</span><span class="boring">  | bar2 : Nat → Nat → Nat → Foo
</span>def silly (x : Foo) : Nat := by
  cases x with
  | bar2 c d e =&gt; exact e
  | bar1 a b =&gt; exact b
</code></pre>
<!--
The syntax of the ``with`` is convenient for writing structured proofs.
Lean also provides a complementary ``case`` tactic, which allows you to focus on goal
assign variable names.
-->
<p><code>with</code>的语法对于编写结构化证明很方便。Lean 还提供了一个补充的<code>case</code>策略，它允许你专注于目标分配变量名。</p>
<pre><code class="language-lean"><span class="boring">inductive Foo where
</span><span class="boring">  | bar1 : Nat → Nat → Foo
</span><span class="boring">  | bar2 : Nat → Nat → Nat → Foo
</span>def silly (x : Foo) : Nat := by
  cases x
  case bar1 a b =&gt; exact b
  case bar2 c d e =&gt; exact e
</code></pre>
<!--
The ``case`` tactic is clever, in that it will match the constructor to the appropriate goal. For example, we can fill the goals above in the opposite order:
-->
<p><code>case</code> 策略很聪明，它将把构造子与适当的目标相匹配。例如，我们可以按照相反的顺序填充上面的目标：</p>
<pre><code class="language-lean"><span class="boring">inductive Foo where
</span><span class="boring">  | bar1 : Nat → Nat → Foo
</span><span class="boring">  | bar2 : Nat → Nat → Nat → Foo
</span>def silly (x : Foo) : Nat := by
  cases x
  case bar2 c d e =&gt; exact e
  case bar1 a b =&gt; exact b
</code></pre>
<!--
You can also use ``cases`` with an arbitrary expression. Assuming that
expression occurs in the goal, the cases tactic will generalize over
the expression, introduce the resulting universally quantified
variable, and case on that.
-->
<p>你也可以使用 <code>cases</code> 伴随一个任意的表达式。假设该表达式出现在目标中，cases策略将概括该表达式，引入由此产生的全称变量，并对其进行处理。</p>
<pre><code class="language-lean">open Nat

example (p : Nat → Prop) (hz : p 0) (hs : ∀ n, p (succ n)) (m k : Nat)
        : p (m + 3 * k) := by
  cases m + 3 * k
  exact hz   -- goal is p 0
  apply hs   -- goal is a : Nat ⊢ p (succ a)
</code></pre>
<!--
Think of this as saying "split on cases as to whether ``m + 3 * k`` is
zero or the successor of some number." The result is functionally
equivalent to the following:
-->
<p>可以认为这是在说「把 <code>m + 3 * k</code> 是零或者某个数字的后继的情况拆开」。其结果在功能上等同于以下：</p>
<pre><code class="language-lean">open Nat

example (p : Nat → Prop) (hz : p 0) (hs : ∀ n, p (succ n)) (m k : Nat)
        : p (m + 3 * k) := by
  generalize m + 3 * k = n
  cases n
  exact hz   -- goal is p 0
  apply hs   -- goal is a : Nat ⊢ p (succ a)
</code></pre>
<!--
Notice that the expression ``m + 3 * k`` is erased by ``generalize``; all
that matters is whether it is of the form ``0`` or ``succ a``. This
form of ``cases`` will *not* revert any hypotheses that also mention
the expression in the equation (in this case, ``m + 3 * k``). If such a
term appears in a hypothesis and you want to generalize over that as
well, you need to ``revert`` it explicitly.

If the expression you case on does not appear in the goal, the
``cases`` tactic uses ``have`` to put the type of the expression into
the context. Here is an example:
-->
<p>注意，表达式 <code>m + 3 * k</code> 被 <code>generalize</code> 删除了；重要的只是它的形式是 <code>0</code> 还是 <code>succ a</code>。这种形式的 <code>cases</code><em>不会</em>恢复任何同时提到方程中的表达式的假设（在本例中是<code>m + 3 * k</code>）。如果这样的术语出现在一个假设中，而你也想对其进行概括，你需要明确地恢复 <code>revert</code> 它。</p>
<p>如果你所涉及的表达式没有出现在目标中，<code>cases</code> 策略使用 <code>have</code> 来把表达式的类型放到上下文中。下面是一个例子：</p>
<pre><code class="language-lean">example (p : Prop) (m n : Nat)
        (h₁ : m &lt; n → p) (h₂ : m ≥ n → p) : p := by
  cases Nat.lt_or_ge m n
  case inl hlt =&gt; exact h₁ hlt
  case inr hge =&gt; exact h₂ hge
</code></pre>
<!--
The theorem ``Nat.lt_or_ge m n`` says ``m < n ∨ m ≥ n``, and it is
natural to think of the proof above as splitting on these two
cases. In the first branch, we have the hypothesis ``hlt : m < n``, and
in the second we have the hypothesis ``hge : m ≥ n``. The proof above
is functionally equivalent to the following:
-->
<p>定理 <code>Nat.lt_or_ge m n</code> 说 <code>m &lt; n ∨ m ≥ n</code>，很自然地认为上面的证明是在这两种情况下的分割。在第一个分支中，我们有假设 <code>h₁ : m &lt; n</code>，在第二个分支中，我们有假设 <code>h₂ : m ≥ n</code>。上面的证明在功能上等同于以下：</p>
<pre><code class="language-lean">example (p : Prop) (m n : Nat)
        (h₁ : m &lt; n → p) (h₂ : m ≥ n → p) : p := by
  have h : m &lt; n ∨ m ≥ n := Nat.lt_or_ge m n
  cases h
  case inl hlt =&gt; exact h₁ hlt
  case inr hge =&gt; exact h₂ hge
</code></pre>
<!--
After the first two lines, we have ``h : m < n ∨ m ≥ n`` as a
hypothesis, and we simply do cases on that.

Here is another example, where we use the decidability of equality on
the natural numbers to split on the cases ``m = n`` and ``m ≠ n``.
-->
<p>在前两行之后，我们有 <code>h : m &lt; n ∨ m ≥ n</code> 作为假设，我们只需在此基础上做cases。</p>
<p>下面是另一个例子，我们利用自然数相等的可判定性，对<code>m = n</code>和<code>m ≠ n</code>的情况进行拆分。</p>
<pre><code class="language-lean">#check Nat.sub_self

example (m n : Nat) : m - n = 0 ∨ m ≠ n := by
  cases Decidable.em (m = n) with
  | inl heq =&gt; rw [heq]; apply Or.inl; exact Nat.sub_self n
  | inr hne =&gt; apply Or.inr; exact hne
</code></pre>
<!--
Remember that if you ``open Classical``, you can use the law of the
excluded middle for any proposition at all. But using type class
inference (see [Chapter Type Classes](./type_classes.md)), Lean can actually
find the relevant decision procedure, which means that you can use the
case split in a computable function.

Just as the ``cases`` tactic can be used to carry out proof by cases,
the ``induction`` tactic can be used to carry out proofs by
induction. The syntax is similar to that of ``cases``, except that the
argument can only be a term in the local context. Here is an example:
-->
<p>如果你 <code>open Classical</code>，你可以对任何命题使用排中律。但是使用<a href="./type_classes.html">类型类</a>推理，Lean 实际上可以找到相关的决策程序，这意味着你可以在可计算函数中使用情况拆分。</p>
<p>正如 <code>cases</code> 项可以用来进行分情况证明，<code>induction</code> 项可以用来进行归纳证明。其语法与<code>cases</code>相似，只是参数只能是局部上下文中的一个项。下面是一个例子：</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>theorem zero_add (n : Nat) : 0 + n = n := by
  induction n with
  | zero =&gt; rfl
  | succ n ih =&gt; rw [Nat.add_succ, ih]
<span class="boring">end Hidden
</span></code></pre>
<!--
As with ``cases``, we can use the ``case`` tactic instead of `with`.
-->
<p>和 <code>cases</code> 一样，我们可以使用 <code>case</code> 代替<code>with</code>。</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>theorem zero_add (n : Nat) : 0 + n = n := by
  induction n
  case zero =&gt; rfl
  case succ n ih =&gt; rw [Nat.add_succ, ih]
<span class="boring">end Hidden
</span></code></pre>
<!--
Here are some additional examples:
-->
<p>更多例子：</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span><span class="boring">theorem add_zero (n : Nat) : n + 0 = n := Nat.add_zero n
</span>open Nat

theorem zero_add (n : Nat) : 0 + n = n := by
  induction n &lt;;&gt; simp [*, add_zero, add_succ]

theorem succ_add (m n : Nat) : succ m + n = succ (m + n) := by
  induction n &lt;;&gt; simp [*, add_zero, add_succ]

theorem add_comm (m n : Nat) : m + n = n + m := by
  induction n &lt;;&gt; simp [*, add_zero, add_succ, succ_add, zero_add]

theorem add_assoc (m n k : Nat) : m + n + k = m + (n + k) := by
  induction k &lt;;&gt; simp [*, add_zero, add_succ]
<span class="boring">end Hidden
</span></code></pre>
<!--
The `induction` tactic also supports user-defined induction principles with
multiple targets (aka major premises).
-->
<p><code>induction</code>策略也支持用户定义的具有多个目标（又称主前提）的归纳原则。</p>
<pre><code class="language-lean">/-
theorem Nat.mod.inductionOn
      {motive : Nat → Nat → Sort u}
      (x y  : Nat)
      (ind  : ∀ x y, 0 &lt; y ∧ y ≤ x → motive (x - y) y → motive x y)
      (base : ∀ x y, ¬(0 &lt; y ∧ y ≤ x) → motive x y)
      : motive x y :=
-/

example (x : Nat) {y : Nat} (h : y &gt; 0) : x % y &lt; y := by
  induction x, y using Nat.mod.inductionOn with
  | ind x y h₁ ih =&gt;
    rw [Nat.mod_eq_sub_mod h₁.2]
    exact ih h
  | base x y h₁ =&gt;
    have : ¬ 0 &lt; y ∨ ¬ y ≤ x := Iff.mp (Decidable.not_and_iff_or_not ..) h₁
    match this with
    | Or.inl h₁ =&gt; exact absurd h h₁
    | Or.inr h₁ =&gt;
      have hgt : y &gt; x := Nat.gt_of_not_le h₁
      rw [← Nat.mod_eq_of_lt hgt] at hgt
      assumption
</code></pre>
<!--
You can use the `match` notation in tactics too:
-->
<p>你也可以在策略中使用<code>match</code>符号：</p>
<pre><code class="language-lean">example : p ∨ q → q ∨ p := by
  intro h
  match h with
  | Or.inl _  =&gt; apply Or.inr; assumption
  | Or.inr h2 =&gt; apply Or.inl; exact h2
</code></pre>
<!--
As a convenience, pattern-matching has been integrated into tactics such as `intro` and `funext`.
-->
<p>为了方便起见，模式匹配已经被整合到诸如<code>intro</code>和<code>funext</code>等策略中。</p>
<pre><code class="language-lean">example : s ∧ q ∧ r → p ∧ r → q ∧ p := by
  intro ⟨_, ⟨hq, _⟩⟩ ⟨hp, _⟩
  exact ⟨hq, hp⟩

example :
    (fun (x : Nat × Nat) (y : Nat × Nat) =&gt; x.1 + y.2)
    =
    (fun (x : Nat × Nat) (z : Nat × Nat) =&gt; z.2 + x.1) := by
  funext (a, b) (c, d)
  show a + d = d + a
  rw [Nat.add_comm]
</code></pre>
<!--
We close this section with one last tactic that is designed to
facilitate working with inductive types, namely, the ``injection``
tactic. By design, the elements of an inductive type are freely
generated, which is to say, the constructors are injective and have
disjoint ranges. The ``injection`` tactic is designed to make use of
this fact:
-->
<p>我们用最后一个策略来结束本节，这个策略旨在促进归纳类型的工作，即 <code>injection</code> 注入策略。归纳类型的元素是自由生成的，也就是说，构造子是注入式的，并且有不相交的作用范围。<code>injection</code> 策略是为了利用这一事实：</p>
<pre><code class="language-lean">open Nat

example (m n k : Nat) (h : succ (succ m) = succ (succ n))
        : n + k = m + k := by
  injection h with h'
  injection h' with h''
  rw [h'']
</code></pre>
<!--
The first instance of the tactic adds ``h' : succ m = succ n`` to the
context, and the second adds ``h'' : m = n``.

The ``injection`` tactic also detects contradictions that arise when different constructors
are set equal to one another, and uses them to close the goal.
-->
<p>该策略的第一个实例在上下文中加入了 <code>h' : succ m = succ n</code>，第二个实例加入了 <code>h'' : m = n</code>。</p>
<p><code>injection</code> 策略还可以检测不同构造子被设置为相等时产生的矛盾，并使用它们来关闭目标。</p>
<pre><code class="language-lean">open Nat

example (m n : Nat) (h : succ m = 0) : n = n + 7 := by
  injection h

example (m n : Nat) (h : succ m = 0) : n = n + 7 := by
  contradiction

example (h : 7 = 4) : False := by
  contradiction
</code></pre>
<!--
As the second example shows, the ``contradiction`` tactic also detects contradictions of this form.
-->
<p>如第二个例子所示，<code>contradiction</code> 策略也能检测出这种形式的矛盾。</p>
<!--
Inductive Families
------------------
-->
<h2 id="归纳族"><a class="header" href="#归纳族">归纳族</a></h2>
<!--
We are almost done describing the full range of inductive definitions
accepted by Lean. So far, you have seen that Lean allows you to
introduce inductive types with any number of recursive
constructors. In fact, a single inductive definition can introduce an
indexed *family* of inductive types, in a manner we now describe.

An inductive family is an indexed family of types defined by a
simultaneous induction of the following form:
-->
<p>我们几乎已经完成了对Lean 所接受的全部归纳定义的描述。到目前为止，你已经看到Lean 允许你用任何数量的递归构造子引入归纳类型。事实上，一个归纳定义可以引入一个有索引的归纳类型的 <strong>族（Family）</strong> 。</p>
<p>归纳族是一个由以下形式的同时归纳定义的有索引的家族：</p>
<pre><code>inductive foo : ... → Sort u where
  | constructor₁ : ... → foo ...
  | constructor₂ : ... → foo ...
  ...
  | constructorₙ : ... → foo ...
</code></pre>
<!--
In contrast to an ordinary inductive definition, which constructs an
element of some ``Sort u``, the more general version constructs a
function ``... → Sort u``, where "``...``" denotes a sequence of
argument types, also known as *indices*. Each constructor then
constructs an element of some member of the family. One example is the
definition of ``Vector α n``, the type of vectors of elements of ``α``
of length ``n``:
-->
<p>与普通的归纳定义不同，它构造了某个 <code>Sort u</code> 的元素，更一般的版本构造了一个函数 <code>... → Sort u</code>，其中 <code>...</code> 表示一串参数类型，也称为 <strong>索引</strong> 。然后，每个构造子都会构造一个家族中某个成员的元素。一个例子是 <code>Vector α n</code> 的定义，它是长度为 <code>n</code> 的 <code>α</code> 元素的向量的类型：</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>inductive Vector (α : Type u) : Nat → Type u where
  | nil  : Vector α 0
  | cons : α → {n : Nat} → Vector α n → Vector α (n+1)
<span class="boring">end Hidden
</span></code></pre>
<!--
Notice that the ``cons`` constructor takes an element of
``Vector α n`` and returns an element of ``Vector α (n+1)``, thereby using an
element of one member of the family to build an element of another.

A more exotic example is given by the definition of the equality type in Lean:
-->
<p>注意，<code>cons</code> 构造子接收 <code>Vector α n</code> 的一个元素，并返回 <code>Vector α (n+1)</code> 的一个元素，从而使用家族中的一个成员的元素来构建另一个成员的元素。</p>
<p>一个更奇特的例子是由Lean 中相等类型的定义：</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>inductive Eq {α : Sort u} (a : α) : α → Prop where
  | refl : Eq a a
<span class="boring">end Hidden
</span></code></pre>
<!--
For each fixed ``α : Sort u`` and ``a : α``, this definition
constructs a family of types ``Eq a x``, indexed by ``x : α``.
Notably, however, there is only one constructor, ``refl``, which
is an element of ``Eq a a``.
Intuitively, the only way to construct a proof of ``Eq a x``
is to use reflexivity, in the case where ``x`` is ``a``.
Note that ``Eq a a`` is the only inhabited type in the family of types
``Eq a x``. The elimination principle generated by Lean is as follows:
-->
<p>对于每个固定的 <code>α : Sort u</code> 和 <code>a : α</code>，这个定义构造了一个 <code>Eq a x</code> 的类型类，由 <code>x : α</code> 索引。然而，只有一个构造子<code>refl</code>，它是<code>Eq a a</code>的一个元素，构造子后面的大括号告诉Lean 要把<code>refl</code>的参数明确化。直观地说，在<code>x</code>是<code>a</code>的情况下，构建<code>Eq a x</code>证明的唯一方法是使用自反性。请注意，<code>Eq a a</code>是<code>Eq a x</code>这个类型家族中唯一的类型。由Lean 产生的消去规则如下：</p>
<pre><code class="language-lean">universe u v

#check (@Eq.rec : {α : Sort u} → {a : α} → {motive : (x : α) → a = x → Sort v}
                  → motive a rfl → {b : α} → (h : a = b) → motive b h)
</code></pre>
<!--
It is a remarkable fact that all the basic axioms for equality follow
from the constructor, ``refl``, and the eliminator, ``Eq.rec``. The
definition of equality is atypical, however; see the discussion in [Section Axiomatic Details](#axiomatic-details).

The recursor ``Eq.rec`` is also used to define substitution:
-->
<p>一个显著的事实是，所有关于相等的基本公理都来自构造子<code>refl</code>和消去器<code>Eq.rec</code>。然而，相等的定义是不典型的，见<a href="inductive_types.html#%E5%85%AC%E7%90%86%E5%8C%96%E7%BB%86%E8%8A%82">公理化细节</a>一节的讨论。</p>
<p>递归器<code>Eq.rec</code>也被用来定义代换：</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>theorem subst {α : Type u} {a b : α} {p : α → Prop} (h₁ : Eq a b) (h₂ : p a) : p b :=
  Eq.rec (motive := fun x _ =&gt; p x) h₂ h₁
<span class="boring">end Hidden
</span></code></pre>
<!--
You can also define `subst` using `match`.
-->
<p>可以使用<code>match</code>定义<code>subst</code>。</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>theorem subst {α : Type u} {a b : α} {p : α → Prop} (h₁ : Eq a b) (h₂ : p a) : p b :=
  match h₁ with
  | rfl =&gt; h₂
<span class="boring">end Hidden
</span></code></pre>
<!--
Actually, Lean compiles the `match` expressions using a definition based on
`Eq.rec`.
-->
<p>实际上，Lean 使用基于<code>Eq.rec</code>的定义来编译<code>match</code>表达式。</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>theorem subst {α : Type u} {a b : α} {p : α → Prop} (h₁ : Eq a b) (h₂ : p a) : p b :=
  match h₁ with
  | rfl =&gt; h₂

set_option pp.all true
#print subst
  -- ... subst.match_1 ...
#print subst.match_1
  -- ... Eq.casesOn ...
#print Eq.casesOn
  -- ... Eq.rec ...
<span class="boring">end Hidden
</span></code></pre>
<!--
Using the recursor or `match` with ``h₁ : a = b``, we may assume ``a`` and ``b`` are the same,
in which case, ``p b`` and ``p a`` are the same.

It is not hard to prove that ``Eq`` is symmetric and transitive.
In the following example, we prove ``symm`` and leave as exercises the theorems ``trans`` and ``congr`` (congruence).
-->
<p>使用递归器或<code>match</code>与<code>h₁ : a = b</code>，我们可以假设<code>a</code>和<code>b</code>相同，在这种情况下，<code>p b</code>和<code>p a</code>相同。</p>
<p>证明 <code>Eq</code> 的对称和传递性并不难。在下面的例子中，我们证明<code>symm</code>，并留下<code>trans</code>和<code>congr</code> （congruence）定理作为练习。</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>theorem symm {α : Type u} {a b : α} (h : Eq a b) : Eq b a :=
  match h with
  | rfl =&gt; rfl

theorem trans {α : Type u} {a b c : α} (h₁ : Eq a b) (h₂ : Eq b c) : Eq a c :=
  sorry

theorem congr {α β : Type u} {a b : α} (f : α → β) (h : Eq a b) : Eq (f a) (f b) :=
  sorry
<span class="boring">end Hidden
</span></code></pre>
<!--
In the type theory literature, there are further generalizations of
inductive definitions, for example, the principles of
*induction-recursion* and *induction-induction*. These are not
supported by Lean.
-->
<p>在类型论文献中，有对归纳定义的进一步推广，例如，「归纳-递归」和「归纳-归纳」的原则。这些东西Lean 暂不支持。</p>
<!--
Axiomatic Details
-----------------
-->
<h2 id="公理化细节"><a class="header" href="#公理化细节">公理化细节</a></h2>
<!--
We have described inductive types and their syntax through
examples. This section provides additional information for those
interested in the axiomatic foundations.

We have seen that the constructor to an inductive type takes
*parameters* --- intuitively, the arguments that remain fixed
throughout the inductive construction --- and *indices*, the arguments
parameterizing the family of types that is simultaneously under
construction. Each constructor should have a type, where the
argument types are built up from previously defined types, the
parameter and index types, and the inductive family currently being
defined. The requirement is that if the latter is present at all, it
occurs only *strictly positively*. This means simply that any argument
to the constructor in which it occurs is a dependent arrow type in which the
inductive type under definition occurs only as the resulting type,
where the indices are given in terms of constants and previous
arguments.

Since an inductive type lives in ``Sort u`` for some ``u``, it is
reasonable to ask *which* universe levels ``u`` can be instantiated
to. Each constructor ``c`` in the definition of a family ``C`` of
inductive types is of the form
-->
<p>我们已经通过例子描述了归纳类型和它们的语法。本节为那些对公理基础感兴趣的人提供额外的信息。</p>
<p>我们已经看到，归纳类型的构造子需要 <strong>参量</strong> （parameter，与argument都有「参数」译义，为区别此处译为参量）——即在整个归纳构造过程中保持固定的参数——和 <strong>索引</strong> ，即同时在构造中的类型类的参数。每个构造子都应该有一个类型，其中的参数类型是由先前定义的类型、参量和索引类型以及当前正在定义的归纳族建立起来的。要求是，如果后者存在，它只 <strong>严格正向</strong> 出现。这意味着它所出现的构造子的任何参数都是一个依值箭头类型，其中定义中的归纳类型只作为结果类型出现，其中的索引是以常量和先前的参数来给出。</p>
<p>既然一个归纳类型对于某些 <code>u</code> 来说存在于在 <code>Sort u</code> 中，那么我们有理由问 <strong>哪些</strong> 宇宙层次的 <code>u</code> 可以被实例化。归纳类型类 <code>C</code> 的定义中的每个构造子 <code>c</code> 的形式为</p>
<pre><code>  c : (a : α) → (b : β[a]) → C a p[a,b]
</code></pre>
<!--
where ``a`` is a sequence of data type parameters, ``b`` is the
sequence of arguments to the constructors, and ``p[a, b]`` are the
indices, which determine which element of the inductive family the
construction inhabits. (Note that this description is somewhat
misleading, in that the arguments to the constructor can appear in any
order as long as the dependencies make sense.) The constraints on the
universe level of ``C`` fall into two cases, depending on whether or
not the inductive type is specified to land in ``Prop`` (that is,
``Sort 0``).

Let us first consider the case where the inductive type is *not*
specified to land in ``Prop``. Then the universe level ``u`` is
constrained to satisfy the following:

> For each constructor ``c`` as above, and each ``βk[a]`` in the sequence ``β[a]``, if ``βk[a] : Sort v``, we have ``u`` ≥ ``v``.

In other words, the universe level ``u`` is required to be at least as
large as the universe level of each type that represents an argument
to a constructor.

When the inductive type is specified to land in ``Prop``, there are no
constraints on the universe levels of the constructor arguments. But
these universe levels do have a bearing on the elimination
rule. Generally speaking, for an inductive type in ``Prop``, the
motive of the elimination rule is required to be in ``Prop``.

There is an exception to this last rule: we are allowed to eliminate
from an inductively defined ``Prop`` to an arbitrary ``Sort`` when
there is only one constructor and each constructor argument is either
in ``Prop`` or an index. The intuition is that in this case the
elimination does not make use of any information that is not already
given by the mere fact that the type of argument is inhabited. This
special case is known as *singleton elimination*.

We have already seen singleton elimination at play in applications of
``Eq.rec``, the eliminator for the inductively defined equality
type. We can use an element ``h : Eq a b`` to cast an element
``t' : p a`` to ``p b`` even when ``p a`` and ``p b`` are arbitrary types,
because the cast does not produce new data; it only reinterprets the
data we already have. Singleton elimination is also used with
heterogeneous equality and well-founded recursion, which will be
discussed in a [Chapter Induction and Recursion](./induction_and_recursion.md#well-founded-recursion-and-induction).
-->
<p>其中<code>a</code>是一列数据类型的参量，<code>b</code>是一列构造子的参数，<code>p[a, b]</code>是索引，用于确定构造所处的归纳族的元素。（请注意，这种描述有些误导，因为构造子的参数可以以任何顺序出现，只要依赖关系是合理的）。对 <code>C</code> 的宇宙层级的约束分为两种情况，取决于归纳类型是否被指定落在 <code>Prop</code>（即 <code>Sort 0</code>）。</p>
<p>我们首先考虑归纳类型<em>不</em>指定落在 <code>Prop</code> 的情况。那么宇宙等级<code>u'</code>被限制为满足以下条件：</p>
<blockquote>
<p>对于上面的每个构造子<code>c</code>，以及序列<code>β[a]</code>中的每个<code>βk[a]</code>，如果<code>βk[a] : Sort v</code>，我们有<code>u</code>≥<code>v</code>。</p>
</blockquote>
<p>换句话说，宇宙等级 <code>u</code> 被要求至少与代表构造子参数的每个类型的宇宙等级一样大。</p>
<p>当归纳类型被指定落在 <code>Prop</code> 中时，对构造子参数的宇宙等级没有任何限制。但是这些宇宙等级对消去规则有影响。一般来说，对于 <code>Prop</code> 中的归纳类型，消去规则的motive被要求在 <code>Prop</code> 中。</p>
<p>这最后一条规则有一个例外：当只有一个构造子，并且每个构造子参数都在<code>Prop</code>中或者是一个索引时，我们可以从一个归纳定义的<code>Prop</code>中消除到一个任意的<code>Sort</code>。直观的说，在这种情况下，消除并不利用任何信息，而这些信息并不是由参数类型被栖息这一简单的事实所提供的。这种特殊情况被称为<em>单子消除</em>（singleton elimination）。</p>
<p>我们已经在<code>Eq.rec</code>的应用中看到了单子消除的作用，这是归纳定义的相等类型的消去器。我们可以使用一个元素 <code>h : Eq a b</code> 来将一个元素 <code>t' : p a</code> 转换为 <code>p b</code>，即使 <code>p a</code> 和 <code>p b</code> 是任意类型，因为转换并不产生新的数据；它只是重新解释了我们已经有的数据。单子消除法也用于异质等价和良基的递归，这将在<a href="./induction_and_recursion.html">归纳和递归</a>一章中讨论。</p>
<!--
Mutual and Nested Inductive Types
---------------------------------
-->
<h2 id="相互和嵌套的归纳类型"><a class="header" href="#相互和嵌套的归纳类型">相互和嵌套的归纳类型</a></h2>
<!--
We now consider two generalizations of inductive types that are often
useful, which Lean supports by "compiling" them down to the more
primitive kinds of inductive types described above. In other words,
Lean parses the more general definitions, defines auxiliary inductive
types based on them, and then uses the auxiliary types to define the
ones we really want. Lean's equation compiler, described in the next
chapter, is needed to make use of these types
effectively. Nonetheless, it makes sense to describe the declarations
here, because they are straightforward variations on ordinary
inductive definitions.

First, Lean supports *mutually defined* inductive types. The idea is
that we can define two (or more) inductive types at the same time,
where each one refers to the other(s).
-->
<p>我们现在考虑两个经常有用的归纳类型的推广，Lean 通过「编译」它们来支持上述更原始的归纳类型种类。换句话说，Lean 解析了更一般的定义，在此基础上定义了辅助的归纳类型，然后使用辅助类型来定义我们真正想要的类型。下一章将介绍Lean 的方程编译器，它需要有效地利用这些类型。尽管如此，在这里描述这些声明还是有意义的，因为它们是普通归纳定义的直接变形。</p>
<p>首先，Lean 支持 <strong>相互定义</strong> 的归纳类型。这个想法是，我们可以同时定义两个（或更多）归纳类型，其中每个类型都指代其他类型。</p>
<pre><code class="language-lean">mutual
  inductive Even : Nat → Prop where
    | even_zero : Even 0
    | even_succ : (n : Nat) → Odd n → Even (n + 1)

  inductive Odd : Nat → Prop where
    | odd_succ : (n : Nat) → Even n → Odd (n + 1)
end
</code></pre>
<!--
In this example, two types are defined simultaneously: a natural
number ``n`` is ``Even`` if it is ``0`` or one more than an ``Odd``
number, and ``Odd`` if it is one more than an ``Even`` number.
In the exercises below, you are asked to spell out the details.

A mutual inductive definition can also be used to define the notation
of a finite tree with nodes labelled by elements of ``α``:
-->
<p>在这个例子中，同时定义了两种类型：一个自然数<code>n</code>如果是<code>0</code>或比<code>Even</code>多一个，就是<code>Odd</code>；如果是比<code>Odd</code>多一个，就是<code>Even</code>。在下面的练习中，要求你写出细节。</p>
<p>相互的归纳定义也可以用来定义有限树的符号，节点由<code>α</code>的元素标记：</p>
<pre><code class="language-lean">mutual
    inductive Tree (α : Type u) where
      | node : α → TreeList α → Tree α

    inductive TreeList (α : Type u) where
      | nil  : TreeList α
      | cons : Tree α → TreeList α → TreeList α
end
</code></pre>
<!--
With this definition, one can construct an element of ``Tree α`` by
giving an element of ``α`` together with a list of subtrees, possibly
empty. The list of subtrees is represented by the type ``TreeList α``,
which is defined to be either the empty list, ``nil``, or the
``cons`` of a tree and an element of ``TreeList α``.

This definition is inconvenient to work with, however. It would be
much nicer if the list of subtrees were given by the type
``List (Tree α)``, especially since Lean's library contains a number of functions
and theorems for working with lists. One can show that the type
``TreeList α`` is *isomorphic* to ``List (Tree α)``, but translating
results back and forth along this isomorphism is tedious.

In fact, Lean allows us to define the inductive type we really want:
-->
<p>有了这个定义，我们可以通过给出一个 <code>α</code> 的元素和一个子树列表（可能是空的）来构造 <code>Tree α</code> 的元素。子树列表由<code>TreeList α</code>类型表示，它被定义为空列表<code>nil</code>，或者是一棵树的<code>cons</code>和<code>TreeList α</code>的一个元素。</p>
<p>然而，这个定义在工作中是不方便的。如果子树的列表是由 <code>List (Tree α)</code> 类型给出的，那就更好了，尤其是Lean 的库中包含了一些处理列表的函数和定理。我们可以证明 <code>TreeList α</code> 类型与 <code>List (Tree α)</code> 是<em>同构</em>的，但是沿着这个同构关系来回翻译结果是很乏味的。</p>
<p>事实上，Lean 允许我们定义我们真正想要的归纳类型：</p>
<pre><code class="language-lean">inductive Tree (α : Type u) where
  | mk : α → List (Tree α) → Tree α
</code></pre>
<!--
This is known as a *nested* inductive type. It falls outside the
strict specification of an inductive type given in the last section
because ``Tree`` does not occur strictly positively among the
arguments to ``mk``, but, rather, nested inside the ``List`` type
constructor. Lean then automatically builds the
isomorphism between ``TreeList α`` and ``List (Tree α)`` in its kernel,
and defines the constructors for ``Tree`` in terms of the isomorphism.
-->
<p>这就是所谓的 <strong>嵌套</strong> 归纳类型。它不属于上一节给出的归纳类型的严格规范，因为<code>Tree</code>不是严格意义上出现在<code>mk</code>的参数中，而是嵌套在<code>List</code>类型构造子中。然后Lean 在其内核中自动建立了 <code>TreeList α</code> 和 <code>List (Tree α)</code> 之间的同构关系，并根据同构关系定义了 <code>Tree</code> 的构造子。</p>
<!--
Exercises
---------
-->
<h2 id="练习-3"><a class="header" href="#练习-3">练习</a></h2>
<!--
1. Try defining other operations on the natural numbers, such as
   multiplication, the predecessor function (with ``pred 0 = 0``),
   truncated subtraction (with ``n - m = 0`` when ``m`` is greater
   than or equal to ``n``), and exponentiation. Then try proving some
   of their basic properties, building on the theorems we have already
   proved.

   Since many of these are already defined in Lean's core library, you
   should work within a namespace named ``Hidden``, or something like
   that, in order to avoid name clashes.

2. Define some operations on lists, like a ``length`` function or the
   ``reverse`` function. Prove some properties, such as the following:

   a. ``length (s ++ t) = length s + length t``

   b. ``length (reverse t) = length t``

   c. ``reverse (reverse t) = t``

3. Define an inductive data type consisting of terms built up from the following constructors:

   - ``const n``, a constant denoting the natural number ``n``
   - ``var n``, a variable, numbered ``n``
   - ``plus s t``, denoting the sum of ``s`` and ``t``
   - ``times s t``, denoting the product of ``s`` and ``t``

   Recursively define a function that evaluates any such term with respect to an assignment of values to the variables.

4. Similarly, define the type of propositional formulas, as well as
   functions on the type of such formulas: an evaluation function,
   functions that measure the complexity of a formula, and a function
   that substitutes another formula for a given variable.

-->
<ol>
<li>尝试定义自然数的其他运算，如乘法、前继函数（定义<code>pred 0 = 0</code>）、截断减法（当<code>m</code>大于或等于<code>n</code>时，<code>n - m = 0</code>）和乘方。然后在我们已经证明的定理的基础上，尝试证明它们的一些基本属性。</li>
</ol>
<p>由于其中许多已经在Lean 的核心库中定义，你应该在一个名为 <code>Hidden</code> 或类似的命名空间中工作，以避免名称冲突。</p>
<ol start="2">
<li>定义一些对列表的操作，如 <code>length</code> 函数或 <code>reverse</code> 函数。证明一些属性，比如下面这些。</li>
</ol>
<p>a. <code>length (s ++ t) = length s + length t</code></p>
<p>b. <code>length (reverse t) = length t</code></p>
<p>c. <code>reverse (reverse t) = t</code></p>
<ol start="3">
<li>定义一个归纳数据类型，由以下构造子建立的项组成。</li>
</ol>
<ul>
<li><code>const n</code>，一个表示自然数<code>n</code>的常数</li>
<li><code>var n</code>，一个变量，编号为<code>n</code></li>
<li><code>plus s t</code>，表示<code>s</code>和<code>t</code>的总和</li>
<li><code>times s t</code>，表示<code>s</code>和<code>t</code>的乘积</li>
</ul>
<p>递归地定义一个函数，根据变量的赋值来计算任何这样的项。</p>
<ol start="4">
<li>同样，定义命题公式的类型，以及关于这类公式类型的函数：求值函数、衡量公式复杂性的函数，以及用另一个公式替代给定变量的函数。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><!--
Induction and Recursion
=======================
-->
<h1 id="归纳和递归"><a class="header" href="#归纳和递归">归纳和递归</a></h1>
<!--
In the previous chapter, we saw that inductive definitions provide a
powerful means of introducing new types in Lean. Moreover, the
constructors and the recursors provide the only means of defining
functions on these types. By the propositions-as-types correspondence,
this means that induction is the fundamental method of proof.

Lean provides natural ways of defining recursive functions, performing
pattern matching, and writing inductive proofs. It allows you to
define a function by specifying equations that it should satisfy, and
it allows you to prove a theorem by specifying how to handle various
cases that can arise. Behind the scenes, these descriptions are
"compiled" down to primitive recursors, using a procedure that we
refer to as the "equation compiler." The equation compiler is not part
of the trusted code base; its output consists of terms that are
checked independently by the kernel.
-->
<p>在上一章中，我们看到归纳定义提供了在 Lean 中引入新类型的强大手段。此外，构造子和递归器提供了在这些类型上定义函数的唯一手段。命题即类型的对应关系，意味着归纳法是证明的基本方法。</p>
<p>Lean 提供了定义递归函数、执行模式匹配和编写归纳证明的自然方法。它允许你通过指定它应该满足的方程来定义一个函数，它允许你通过指定如何处理可能出现的各种情况来证明一个定理。在它内部，这些描述被「方程编译器」程序「编译」成原始递归器。方程编译器不是可信代码库的一部分；它的输出包括由内核独立检查的项。</p>
<!--
Pattern Matching
----------------
-->
<h2 id="模式匹配"><a class="header" href="#模式匹配">模式匹配</a></h2>
<!--
The interpretation of schematic patterns is the first step of the
compilation process. We have seen that the ``casesOn`` recursor can
be used to define functions and prove theorems by cases, according to
the constructors involved in an inductively defined type. But
complicated definitions may use several nested ``casesOn``
applications, and may be hard to read and understand. Pattern matching
provides an approach that is more convenient, and familiar to users of
functional programming languages.

Consider the inductively defined type of natural numbers. Every
natural number is either ``zero`` or ``succ x``, and so you can define
a function from the natural numbers to an arbitrary type by specifying
a value in each of those cases:
-->
<p>对示意图模式的解释是编译过程的第一步。我们已经看到，<code>casesOn</code> 递归器可以通过分情况讨论来定义函数和证明定理，根据归纳定义类型所涉及的构造子。但是复杂的定义可能会使用几个嵌套的 <code>casesOn</code> 应用，而且可能很难阅读和理解。模式匹配提供了一种更方便的方法，并且为函数式编程语言的用户所熟悉。</p>
<p>考虑一下自然数的归纳定义类型。每个自然数要么是 <code>zero</code>，要么是 <code>succ x</code>，因此你可以通过在每个情况下指定一个值来定义一个从自然数到任意类型的函数：</p>
<pre><code class="language-lean">open Nat

def sub1 : Nat → Nat
  | zero   =&gt; zero
  | succ x =&gt; x

def isZero : Nat → Bool
  | zero   =&gt; true
  | succ x =&gt; false
</code></pre>
<!--
The equations used to define these functions hold definitionally:
-->
<p>用来定义这些函数的方程在定义上是成立的：</p>
<pre><code class="language-lean"><span class="boring">open Nat
</span><span class="boring">def sub1 : Nat → Nat
</span><span class="boring">  | zero   =&gt; zero
</span><span class="boring">  | succ x =&gt; x
</span><span class="boring">def isZero : Nat → Bool
</span><span class="boring">  | zero   =&gt; true
</span><span class="boring">  | succ x =&gt; false
</span>example : sub1 0 = 0 := rfl
example (x : Nat) : sub1 (succ x) = x := rfl

example : isZero 0 = true := rfl
example (x : Nat) : isZero (succ x) = false := rfl

example : sub1 7 = 6 := rfl
example (x : Nat) : isZero (x + 3) = false := rfl
</code></pre>
<!--
Instead of ``zero`` and ``succ``, we can use more familiar notation:
-->
<p>我们可以用一些更耳熟能详的符号，而不是 <code>zero</code> 和 <code>succ</code>：</p>
<pre><code class="language-lean">def sub1 : Nat → Nat
  | 0   =&gt; 0
  | x+1 =&gt; x

def isZero : Nat → Bool
  | 0   =&gt; true
  | x+1 =&gt; false
</code></pre>
<!--
Because addition and the zero notation have been assigned the
``[match_pattern]`` attribute, they can be used in pattern matching. Lean
simply normalizes these expressions until the constructors ``zero``
and ``succ`` are exposed.

Pattern matching works with any inductive type, such as products and option types:
-->
<p>因为加法和零符号已经被赋予 <code>[matchPattern]</code> 属性，它们可以被用于模式匹配。Lean 简单地将这些表达式规范化，直到显示构造子 <code>zero</code> 和 <code>succ</code>。</p>
<p>模式匹配适用于任何归纳类型，如乘积和 Option 类型：</p>
<pre><code class="language-lean">def swap : α × β → β × α
  | (a, b) =&gt; (b, a)

def foo : Nat × Nat → Nat
  | (m, n) =&gt; m + n

def bar : Option Nat → Nat
  | some n =&gt; n + 1
  | none   =&gt; 0
</code></pre>
<!--
Here we use it not only to define a function, but also to carry out a
proof by cases:
-->
<p>在这里，我们不仅用它来定义一个函数，而且还用它来进行逐情况证明：</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>def not : Bool → Bool
  | true  =&gt; false
  | false =&gt; true

theorem not_not : ∀ (b : Bool), not (not b) = b
  | true  =&gt; rfl  -- proof that not (not true) = true
  | false =&gt; rfl  -- proof that not (not false) = false
<span class="boring">end Hidden
</span></code></pre>
<!--
Pattern matching can also be used to destruct inductively defined propositions:
-->
<p>模式匹配也可以用来解构归纳定义的命题：</p>
<pre><code class="language-lean">example (p q : Prop) : p ∧ q → q ∧ p
  | And.intro h₁ h₂ =&gt; And.intro h₂ h₁

example (p q : Prop) : p ∨ q → q ∨ p
  | Or.inl hp =&gt; Or.inr hp
  | Or.inr hq =&gt; Or.inl hq
</code></pre>
<!--
This provides a compact way of unpacking hypotheses that make use of logical connectives.

In all these examples, pattern matching was used to carry out a single
case distinction. More interestingly, patterns can involve nested
constructors, as in the following examples.
-->
<p>这样解决带逻辑连接词的命题就很紧凑。</p>
<p>在所有这些例子中，模式匹配被用来进行单一情况的区分。更有趣的是，模式可以涉及嵌套的构造子，如下面的例子。</p>
<pre><code class="language-lean">def sub2 : Nat → Nat
  | 0   =&gt; 0
  | 1   =&gt; 0
  | x+2 =&gt; x
</code></pre>
<!--
The equation compiler first splits on cases as to whether the input is
``zero`` or of the form ``succ x``.  It then does a case split on
whether ``x`` is of the form ``zero`` or ``succ x``.  It determines
the necessary case splits from the patterns that are presented to it,
and raises an error if the patterns fail to exhaust the cases. Once
again, we can use arithmetic notation, as in the version below. In
either case, the defining equations hold definitionally.
-->
<p>方程编译器首先对输入是 <code>zero</code> 还是 <code>succ x</code> 的形式进行分类讨论，然后对 <code>x</code> 是 <code>zero</code> 还是 <code>succ x</code> 的形式进行分类讨论。它从提交给它的模式中确定必要的情况拆分，如果模式不能穷尽情况，则会引发错误。同时，我们可以使用算术符号，如下面的版本。在任何一种情况下，定义方程都是成立的。</p>
<pre><code class="language-lean"><span class="boring">def sub2 : Nat → Nat
</span><span class="boring">  | 0   =&gt; 0
</span><span class="boring">  | 1   =&gt; 0
</span><span class="boring">  | x+2 =&gt; x
</span>example : sub2 0 = 0 := rfl
example : sub2 1 = 0 := rfl
example : sub2 (x+2) = x := rfl

example : sub2 5 = 3 := rfl
</code></pre>
<!--
You can write ``#print sub2`` to see how the function was compiled to
recursors. (Lean will tell you that ``sub2`` has been defined in terms
of an internal auxiliary function, ``sub2.match_1``, but you can print
that out too.) Lean uses these auxiliary functions to compile `match` expressions.
Actually, the definition above is expanded to
-->
<p>你可以写 <code>#print sub2</code> 来看看这个函数是如何被编译成递归器的。（Lean 会告诉你 <code>sub2</code> 已经被定义为内部辅助函数 <code>sub2.match_1</code>，但你也可以把它打印出来）。Lean 使用这些辅助函数来编译 <code>match</code> 表达式。实际上，上面的定义被扩展为</p>
<pre><code class="language-lean">def sub2 : Nat → Nat :=
  fun x =&gt;
    match x with
    | 0   =&gt; 0
    | 1   =&gt; 0
    | x+2 =&gt; x
</code></pre>
<!--
Here are some more examples of nested pattern matching:
-->
<p>下面是一些嵌套模式匹配的例子：</p>
<pre><code class="language-lean">example (p q : α → Prop)
        : (∃ x, p x ∨ q x) → (∃ x, p x) ∨ (∃ x, q x)
  | Exists.intro x (Or.inl px) =&gt; Or.inl (Exists.intro x px)
  | Exists.intro x (Or.inr qx) =&gt; Or.inr (Exists.intro x qx)

def foo : Nat × Nat → Nat
  | (0, n)     =&gt; 0
  | (m+1, 0)   =&gt; 1
  | (m+1, n+1) =&gt; 2
</code></pre>
<!--
The equation compiler can process multiple arguments sequentially. For
example, it would be more natural to define the previous example as a
function of two arguments:
-->
<p>方程编译器可以按顺序处理多个参数。例如，将前面的例子定义为两个参数的函数会更自然：</p>
<pre><code class="language-lean">def foo : Nat → Nat → Nat
  | 0,   n   =&gt; 0
  | m+1, 0   =&gt; 1
  | m+1, n+1 =&gt; 2
</code></pre>
<!--
Here is another example:
-->
<p>另一例：</p>
<pre><code class="language-lean">def bar : List Nat → List Nat → Nat
  | [],      []      =&gt; 0
  | a :: as, []      =&gt; a
  | [],      b :: bs =&gt; b
  | a :: as, b :: bs =&gt; a + b
</code></pre>
<!--
Note that the patterns are separated by commas.

In each of the following examples, splitting occurs on only the first
argument, even though the others are included among the list of
patterns.
-->
<p>这些模式是由逗号分隔的。</p>
<p>在下面的每个例子中，尽管其他参数包括在模式列表中，但只对第一个参数进行了分割。</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>def and : Bool → Bool → Bool
  | true,  a =&gt; a
  | false, _ =&gt; false

def or : Bool → Bool → Bool
  | true,  _ =&gt; true
  | false, a =&gt; a

def cond : Bool → α → α → α
  | true,  x, y =&gt; x
  | false, x, y =&gt; y
<span class="boring">end Hidden
</span></code></pre>
<!--
Notice also that, when the value of an argument is not needed in the
definition, you can use an underscore instead. This underscore is
known as a *wildcard pattern*, or an *anonymous variable*. In contrast
to usage outside the equation compiler, here the underscore does *not*
indicate an implicit argument. The use of underscores for wildcards is
common in functional programming languages, and so Lean adopts that
notation. [Section Wildcards and Overlapping Patterns](#wildcards-and-overlapping-patterns)
expands on the notion of a wildcard, and [Section Inaccessible Patterns](#inaccessible-patterns) explains how
you can use implicit arguments in patterns as well.

As described in [Chapter Inductive Types](./inductive_types.md),
inductive data types can depend on parameters. The following example defines
the ``tail`` function using pattern matching. The argument ``α : Type u``
is a parameter and occurs before the colon to indicate it does not participate in the pattern matching.
Lean also allows parameters to occur after ``:``, but it cannot pattern match on them.
-->
<p>还要注意的是，当定义中不需要一个参数的值时，你可以用下划线来代替。这个下划线被称为 <strong>通配符模式</strong> ，或 <strong>匿名变量</strong> 。与方程编译器之外的用法不同，这里的下划线 <strong>并不</strong> 表示一个隐参数。使用下划线表示通配符在函数式编程语言中是很常见的，所以 Lean 采用了这种符号。<a href="induction_and_recursion.html#%E9%80%9A%E9%85%8D%E7%AC%A6%E5%92%8C%E9%87%8D%E5%8F%A0%E6%A8%A1%E5%BC%8F">通配符和重叠模式</a>一节阐述了通配符的概念，而<a href="induction_and_recursion.html#%E4%B8%8D%E5%8F%AF%E8%AE%BF%E9%97%AE%E6%A8%A1%E5%BC%8F">不可访问模式</a>一节解释了你如何在模式中使用隐参数。</p>
<p>正如<a href="./inductive_types.html">归纳类型</a>一章中所描述的，归纳数据类型可以依赖于参数。下面的例子使用模式匹配定义了 <code>tail</code> 函数。参数 <code>α : Type</code> 是一个参数，出现在冒号之前，表示它不参与模式匹配。Lean 也允许参数出现在 <code>:</code> 之后，但它不能对其进行模式匹配。</p>
<pre><code class="language-lean">def tail1 {α : Type u} : List α → List α
  | []      =&gt; []
  | a :: as =&gt; as

def tail2 : {α : Type u} → List α → List α
  | α, []      =&gt; []
  | α, a :: as =&gt; as
</code></pre>
<!--
Despite the different placement of the parameter ``α`` in these two
examples, in both cases it is treated in the same way, in that it does
not participate in a case split.

Lean can also handle more complex forms of pattern matching, in which
arguments to dependent types pose additional constraints on the
various cases. Such examples of *dependent pattern matching* are
considered in the [Section Dependent Pattern Matching](#dependent-pattern-matching).

-->
<p>尽管参数 <code>α</code> 在这两个例子中的位置不同，但在这两种情况下，它的处理方式是一样的，即它不参与情况分割。</p>
<p>Lean 也可以处理更复杂的模式匹配形式，其中从属类型的参数对各种情况构成了额外的约束。这种 <strong>依值模式匹配</strong> 的例子在<a href="induction_and_recursion.html#%E4%BE%9D%E5%80%BC%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D">依值模式匹配</a>一节中考虑。</p>
<!--
Wildcards and Overlapping Patterns
----------------------------------
-->
<h2 id="通配符和重叠模式"><a class="header" href="#通配符和重叠模式">通配符和重叠模式</a></h2>
<!--
Consider one of the examples from the last section:
-->
<p>考虑上节的一个例子：</p>
<pre><code class="language-lean">def foo : Nat → Nat → Nat
  | 0,   n   =&gt; 0
  | m+1, 0   =&gt; 1
  | m+1, n+1 =&gt; 2
</code></pre>
<!--
An alternative presentation is:
-->
<p>也可以表述成</p>
<pre><code class="language-lean">def foo : Nat → Nat → Nat
  | 0, n =&gt; 0
  | m, 0 =&gt; 1
  | m, n =&gt; 2
</code></pre>
<!--
In the second presentation, the patterns overlap; for example, the
pair of arguments ``0 0`` matches all three cases. But Lean handles
the ambiguity by using the first applicable equation, so in this example
the net result is the same. In particular, the following equations hold
definitionally:
-->
<p>在第二种表述中，模式是重叠的；例如，一对参数 <code>0 0</code> 符合所有三种情况。但是Lean 通过使用第一个适用的方程来处理这种模糊性，所以在这个例子中，最终结果是一样的。特别是，以下方程在定义上是成立的：</p>
<pre><code class="language-lean"><span class="boring">def foo : Nat → Nat → Nat
</span><span class="boring">  | 0, n =&gt; 0
</span><span class="boring">  | m, 0 =&gt; 1
</span><span class="boring">  | m, n =&gt; 2
</span>example : foo 0     0     = 0 := rfl
example : foo 0     (n+1) = 0 := rfl
example : foo (m+1) 0     = 1 := rfl
example : foo (m+1) (n+1) = 2 := rfl
</code></pre>
<!--
Since the values of ``m`` and ``n`` are not needed, we can just as well use wildcard patterns instead.
-->
<p>由于不需要 <code>m</code> 和 <code>n</code> 的值，我们也可以用通配符模式代替。</p>
<pre><code class="language-lean">def foo : Nat → Nat → Nat
  | 0, _ =&gt; 0
  | _, 0 =&gt; 1
  | _, _ =&gt; 2
</code></pre>
<!--
You can check that this definition of ``foo`` satisfies the same
definitional identities as before.

Some functional programming languages support *incomplete
patterns*. In these languages, the interpreter produces an exception
or returns an arbitrary value for incomplete cases. We can simulate
the arbitrary value approach using the ``Inhabited`` type
class. Roughly, an element of ``Inhabited α`` is a witness to the fact
that there is an element of ``α``; in the [Chapter Type Classes](./type_classes.md)
we will see that Lean can be instructed that suitable
base types are inhabited, and can automatically infer that other
constructed types are inhabited. On this basis, the
standard library provides a default element, ``default``, of
any inhabited type.

We can also use the type ``Option α`` to simulate incomplete patterns.
The idea is to return ``some a`` for the provided patterns, and use
``none`` for the incomplete cases. The following example demonstrates
both approaches.
-->
<p>你可以检查这个 <code>foo</code> 的定义是否满足与之前相同的定义特性。</p>
<p>一些函数式编程语言支持 <strong>不完整的模式</strong> 。在这些语言中，解释器对不完整的情况产生一个异常或返回一个任意的值。我们可以使用 <code>Inhabited</code> （含元素的）类型类来模拟任意值的方法。粗略的说，<code>Inhabited α</code> 的一个元素是对 <code>α</code> 拥有一个元素的见证；在<a href="./type_classes.html">类型类</a>中，我们将看到 Lean 可以被告知合适的基础类型是含元素的，并且可以自动推断出其他构造类型是含元素的。在此基础上，标准库提供了一个任意元素 <code>arbitrary</code>，任何含元素的类型。</p>
<p>我们还可以使用类型<code>Option α</code>来模拟不完整的模式。我们的想法是对所提供的模式返回<code>some a</code>，而对不完整的情况使用<code>none</code>。下面的例子演示了这两种方法。</p>
<!--
```lean
def f1 : Nat → Nat → Nat
  | 0, _  => 1
  | _, 0  => 2
  | _, _  => default  -- the "incomplete" case

example : f1 0     0     = 1       := rfl
example : f1 0     (a+1) = 1       := rfl
example : f1 (a+1) 0     = 2       := rfl
example : f1 (a+1) (b+1) = default := rfl

def f2 : Nat → Nat → Option Nat
  | 0, _  => some 1
  | _, 0  => some 2
  | _, _  => none     -- the "incomplete" case

example : f2 0     0     = some 1 := rfl
example : f2 0     (a+1) = some 1 := rfl
example : f2 (a+1) 0     = some 2 := rfl
example : f2 (a+1) (b+1) = none   := rfl
```
-->
<pre><code class="language-lean">def f1 : Nat → Nat → Nat
  | 0, _  =&gt; 1
  | _, 0  =&gt; 2
  | _, _  =&gt; default  -- 不完整的模式

example : f1 0     0     = 1       := rfl
example : f1 0     (a+1) = 1       := rfl
example : f1 (a+1) 0     = 2       := rfl
example : f1 (a+1) (b+1) = default := rfl

def f2 : Nat → Nat → Option Nat
  | 0, _  =&gt; some 1
  | _, 0  =&gt; some 2
  | _, _  =&gt; none     -- 不完整的模式

example : f2 0     0     = some 1 := rfl
example : f2 0     (a+1) = some 1 := rfl
example : f2 (a+1) 0     = some 2 := rfl
example : f2 (a+1) (b+1) = none   := rfl
</code></pre>
<!--
The equation compiler is clever. If you leave out any of the cases in
the following definition, the error message will let you know what has
not been covered.
-->
<p>方程编译器是很智能的。如果你遗漏了以下定义中的任何一种情况，错误信息会告诉你遗漏了哪个。</p>
<pre><code class="language-lean">def bar : Nat → List Nat → Bool → Nat
  | 0,   _,      false =&gt; 0
  | 0,   b :: _, _     =&gt; b
  | 0,   [],     true  =&gt; 7
  | a+1, [],     false =&gt; a
  | a+1, [],     true  =&gt; a + 1
  | a+1, b :: _, _     =&gt; a + b
</code></pre>
<!--
It will also use an "if ... then ... else" instead of a ``casesOn`` in appropriate situations.
-->
<p>某些情况也可以用「if ... then ... else」代替 <code>casesOn</code>。</p>
<pre><code class="language-lean">def foo : Char → Nat
  | 'A' =&gt; 1
  | 'B' =&gt; 2
  | _   =&gt; 3

#print foo.match_1
</code></pre>
<!--
Structural Recursion and Induction
----------------------------------
-->
<h2 id="结构化递归和归纳"><a class="header" href="#结构化递归和归纳">结构化递归和归纳</a></h2>
<!--
What makes the equation compiler powerful is that it also supports
recursive definitions. In the next three sections, we will describe,
respectively:

- structurally recursive definitions
- well-founded recursive definitions
- mutually recursive definitions

Generally speaking, the equation compiler processes input of the following form:

-->
<p>方程编译器的强大之处在于，它还支持递归定义。在接下来的三节中，我们将分别介绍。</p>
<ul>
<li>结构性递归定义</li>
<li>良基的递归定义</li>
<li>相互递归的定义</li>
</ul>
<p>一般来说，方程编译器处理以下形式的输入。</p>
<pre><code>def foo (a : α) : (b : β) → γ
  | [patterns₁] =&gt; t₁
  ...
  | [patternsₙ] =&gt; tₙ
</code></pre>
<!--
Here ``(a : α)`` is a sequence of parameters, ``(b : β)`` is the
sequence of arguments on which pattern matching takes place, and ``γ``
is any type, which can depend on ``a`` and ``b``. Each line should
contain the same number of patterns, one for each element of ``β``. As we
have seen, a pattern is either a variable, a constructor applied to
other patterns, or an expression that normalizes to something of that
form (where the non-constructors are marked with the ``[match_pattern]``
attribute). The appearances of constructors prompt case splits, with
the arguments to the constructors represented by the given
variables. In [Section Dependent Pattern Matching](#dependent-pattern-matching),
we will see that it is sometimes necessary to include explicit terms in patterns that
are needed to make an expression type check, though they do not play a
role in pattern matching. These are called "inaccessible patterns" for
that reason. But we will not need to use such inaccessible patterns
before [Section Dependent Pattern Matching](#dependent-pattern-matching).

As we saw in the last section, the terms ``t₁, ..., tₙ`` can make use
of any of the parameters ``a``, as well as any of the variables that
are introduced in the corresponding patterns. What makes recursion and
induction possible is that they can also involve recursive calls to
``foo``. In this section, we will deal with *structural recursion*, in
which the arguments to ``foo`` occurring on the right-hand side of the
``=>`` are subterms of the patterns on the left-hand side. The idea is
that they are structurally smaller, and hence appear in the inductive
type at an earlier stage. Here are some examples of structural
recursion from the last chapter, now defined using the equation
compiler:
-->
<p>这里 <code>(a : α)</code> 是一个参数序列，<code>(b : β)</code> 是进行模式匹配的参数序列，<code>γ</code> 是任何类型，它可以取决于 <code>a</code> 和 <code>b </code>。每一行应该包含相同数量的模式，对应于 <code>β</code> 的每个元素。正如我们所看到的，模式要么是一个变量，要么是应用于其他模式的构造子，要么是一个正规化为该形式的表达式（其中非构造子用 <code>[matchPattern]</code> 属性标记）。构造子的出现会提示情况拆分，构造子的参数由给定的变量表示。在<a href="induction_and_recursion.html#%E4%BE%9D%E5%80%BC%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D">依值模式匹配</a>一节中，我们将看到有时有必要在模式中包含明确的项，这些项需要进行表达式类型检查，尽管它们在模式匹配中没有起到作用。由于这个原因，这些被称为「不可访问的模式」。但是在<a href="induction_and_recursion.html#%E4%BE%9D%E5%80%BC%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D">依值模式匹配</a>一节之前，我们将不需要使用这种不可访问的模式。</p>
<p>正如我们在上一节所看到的，项 <code>t₁,...,tₙ</code> 可以利用任何一个参数 <code>a</code>，以及在相应模式中引入的任何一个变量。使得递归和归纳成为可能的是，它们也可以涉及对 <code>foo</code> 的递归调用。在本节中，我们将处理 <strong>结构性递归</strong> ，其中 <code>foo</code> 的参数出现在 <code>:=</code> 的右侧，是左侧模式的子项。我们的想法是，它们在结构上更小，因此在归纳类型中出现在更早的阶段。下面是上一章的一些结构递归的例子，现在用方程编译器来定义。</p>
<pre><code class="language-lean">open Nat
def add : Nat → Nat → Nat
  | m, zero   =&gt; m
  | m, succ n =&gt; succ (add m n)

theorem add_zero (m : Nat)   : add m zero = m := rfl
theorem add_succ (m n : Nat) : add m (succ n) = succ (add m n) := rfl

theorem zero_add : ∀ n, add zero n = n
  | zero   =&gt; rfl
  | succ n =&gt; congrArg succ (zero_add n)

def mul : Nat → Nat → Nat
  | n, zero   =&gt; zero
  | n, succ m =&gt; add (mul n m) n
</code></pre>
<!--

The proof of ``zero_add`` makes it clear that proof by induction is
really a form of recursion in Lean.

The example above shows that the defining equations for ``add`` hold
definitionally, and the same is true of ``mul``. The equation compiler
tries to ensure that this holds whenever possible, as is the case with
straightforward structural induction. In other situations, however,
reductions hold only *propositionally*, which is to say, they are
equational theorems that must be applied explicitly. The equation
compiler generates such theorems internally. They are not meant to be
used directly by the user; rather, the `simp` tactic
is configured to use them when necessary. Thus both of the following
proofs of `zero_add` work:
-->
<p><code>zero_add</code> 的证明清楚地表明，归纳证明实际上是 Lean 中的一种递归形式。</p>
<p>上面的例子表明，<code>add</code> 的定义方程具有定义意义，<code> mul</code> 也是如此。方程编译器试图确保在任何可能的情况下都是这样，就像直接的结构归纳法一样。然而，在其他情况下，约简只在命题上成立，也就是说，它们是必须明确应用的方程定理。方程编译器在内部生成这样的定理。用户不能直接使用它们;相反，<code>simp</code> 策略被配置为在必要时使用它们。因此，对<code>zero_add</code>的以下两种证明都成立：</p>
<pre><code class="language-lean">open Nat
<span class="boring">def add : Nat → Nat → Nat
</span><span class="boring">  | m, zero   =&gt; m
</span><span class="boring">  | m, succ n =&gt; succ (add m n)
</span>theorem zero_add : ∀ n, add zero n = n
  | zero   =&gt; by simp [add]
  | succ n =&gt; by simp [add, zero_add]
</code></pre>
<!--
As with definition by pattern matching, parameters to a structural
recursion or induction may appear before the colon. Such parameters
are simply added to the local context before the definition is
processed. For example, the definition of addition may also be written
as follows:
-->
<p>与模式匹配定义一样，结构递归或归纳的参数可能出现在冒号之前。在处理定义之前，简单地将这些参数添加到本地上下文中。例如，加法的定义也可以写成这样:</p>
<pre><code class="language-lean">open Nat
def add (m : Nat) : Nat → Nat
  | zero   =&gt; m
  | succ n =&gt; succ (add m n)
</code></pre>
<!--
You can also write the example above using `match`.
-->
<p>你也可以用 <code>match</code> 来写上面的例子。</p>
<pre><code class="language-lean">open Nat
def add (m n : Nat) : Nat :=
  match n with
  | zero   =&gt; m
  | succ n =&gt; succ (add m n)
</code></pre>
<!--
A more interesting example of structural recursion is given by the Fibonacci function ``fib``.
-->
<p>一个更有趣的结构递归的例子是斐波那契函数 <code>fib</code>。</p>
<pre><code class="language-lean">def fib : Nat → Nat
  | 0   =&gt; 1
  | 1   =&gt; 1
  | n+2 =&gt; fib (n+1) + fib n

example : fib 0 = 1 := rfl
example : fib 1 = 1 := rfl
example : fib (n + 2) = fib (n + 1) + fib n := rfl

example : fib 7 = 21 := rfl
</code></pre>
<!--
Here, the value of the ``fib`` function at ``n + 2`` (which is
definitionally equal to ``succ (succ n)``) is defined in terms of the
values at ``n + 1`` (which is definitionally equivalent to ``succ n``)
and the value at ``n``. This is a notoriously inefficient way of
computing the Fibonacci function, however, with an execution time that
is exponential in ``n``. Here is a better way:
-->
<p>这里，<code>fib</code> 函数在 <code>n + 2</code> （定义上等于 <code>succ (succ n)</code> ）处的值是根据 <code>n + 1</code> （定义上等价于 <code>succ n</code> ）和 <code>n</code> 处的值定义的。然而，这是一种众所周知的计算斐波那契函数的低效方法，其执行时间是 <code>n</code> 的指数级。这里有一个更好的方法:</p>
<pre><code class="language-lean">def fibFast (n : Nat) : Nat :=
  (loop n).2
where
  loop : Nat → Nat × Nat
    | 0   =&gt; (0, 1)
    | n+1 =&gt; let p := loop n; (p.2, p.1 + p.2)

#eval fibFast 100
</code></pre>
<!--
Here is the same definition using a `let rec` instead of a `where`.
-->
<p>下面是相同的定义，使用 <code>let rec</code> 代替 <code>where</code>。</p>
<pre><code class="language-lean">def fibFast (n : Nat) : Nat :=
  let rec loop : Nat → Nat × Nat
    | 0   =&gt; (0, 1)
    | n+1 =&gt; let p := loop n; (p.2, p.1 + p.2)
  (loop n).2
</code></pre>
<!--
In both cases, Lean generates the auxiliary function `fibFast.loop`.

To handle structural recursion, the equation compiler uses
*course-of-values* recursion, using constants ``below`` and ``brecOn``
that are automatically generated with each inductively defined
type. You can get a sense of how it works by looking at the types of
``Nat.below`` and ``Nat.brecOn``:
-->
<p>在这两种情况下，Lean 都会生成辅助函数 <code>fibFast.loop</code>。</p>
<p>为了处理结构递归，方程编译器使用 <strong>值过程</strong> （course-of-values）递归，使用由每个归纳定义类型自动生成的常量 <code>below</code> 和 <code>brecOn</code>。你可以通过查看 <code>Nat.below</code> 和 <code>Nat.brecOn</code> 的类型来了解它是如何工作的。</p>
<pre><code class="language-lean">variable (C : Nat → Type u)

#check (@Nat.below C : Nat → Type u)

#reduce @Nat.below C (3 : Nat)

#check (@Nat.brecOn C : (n : Nat) → ((n : Nat) → @Nat.below C n → C n) → C n)
</code></pre>
<!--
The type ``@Nat.below C (3 : nat)`` is a data structure that stores elements of ``C 0``, ``C 1``, and ``C 2``.
The course-of-values recursion is implemented by ``Nat.brecOn``. It enables us to define the value of a dependent
function of type ``(n : Nat) → C n`` at a particular input ``n`` in terms of all the previous values of the function,
presented as an element of ``@Nat.below C n``.

The use of course-of-values recursion is one of the techniques the equation compiler uses to justify to
the Lean kernel that a function terminates. It does not affect the code generator which compiles recursive
functions as other functional programming language compilers. Recall that `#eval fib <n>` is exponential on `<n>`.
On the other hand, `#reduce fib <n>` is efficient because it uses the definition sent to the kernel that
is based on the `brecOn` construction.
-->
<p>类型 <code>@Nat.below C (3 : nat)</code> 是一个存储着 <code>C 0</code>，<code>C 1</code>，和 <code>C 2</code> 中元素的数据结构。值过程递归由 <code>Nat.brecOn</code> 实现。它根据该函数之前的所有值，定义类型为 <code>(n : Nat) → C n</code> 的依值函数在特定输入 <code>n</code> 时的值，表示为 <code>@Nat.below C n</code> 的一个元素。</p>
<p>值过程递归是方程编译器用来向 Lean 内核证明函数终止的技术之一。它不会像其他函数式编程语言编译器一样影响编译递归函数的代码生成器。回想一下，<code>#eval fib &lt;n&gt;</code> 是 <code>&lt;n&gt;</code> 的指数。另一方面，<code>#reduce fib &lt;n&gt;</code> 是有效的，因为它使用了发送到内核的基于 <code>brecOn</code> 结构的定义。</p>
<!--
```lean
def fib : Nat → Nat
  | 0   => 1
  | 1   => 1
  | n+2 => fib (n+1) + fib n

-- #eval fib 50 -- slow
#reduce fib 50  -- fast

#print fib
```
-->
<pre><code class="language-lean">def fib : Nat → Nat
  | 0   =&gt; 1
  | 1   =&gt; 1
  | n+2 =&gt; fib (n+1) + fib n

-- #eval fib 50 -- 这个很慢
#reduce fib 50  -- 用这个，这个快

#print fib
</code></pre>
<!--
Another good example of a recursive definition is the list ``append`` function.
-->
<p>另一个递归定义的好例子是列表的 <code>append</code> 函数。</p>
<pre><code class="language-lean">def append : List α → List α → List α
  | [],    bs =&gt; bs
  | a::as, bs =&gt; a :: append as bs

example : append [1, 2, 3] [4, 5] = [1, 2, 3, 4, 5] := rfl
</code></pre>
<!--
Here is another: it adds elements of the first list to elements of the second list, until one of the two lists runs out.
-->
<p>这里是另一个：它将第一个列表中的元素和第二个列表中的元素分别相加，直到两个列表中的一个用尽。</p>
<pre><code class="language-lean">def listAdd [Add α] : List α → List α → List α
  | [],      _       =&gt; []
  | _,       []      =&gt; []
  | a :: as, b :: bs =&gt; (a + b) :: listAdd as bs

#eval listAdd [1, 2, 3] [4, 5, 6, 6, 9, 10]
-- [5, 7, 9]
</code></pre>
<!--
You are encouraged to experiment with similar examples in the exercises below.
-->
<p>你可以在章末练习中尝试类似的例子。</p>
<!--
Local recursive declarations
---------
-->
<h2 id="局域递归声明"><a class="header" href="#局域递归声明">局域递归声明</a></h2>
<!--
You can define local recursive declarations using the `let rec` keyword.
-->
<p>可以使用 <code>let rec</code> 关键字定义局域递归声明。</p>
<pre><code class="language-lean">def replicate (n : Nat) (a : α) : List α :=
  let rec loop : Nat → List α → List α
    | 0,   as =&gt; as
    | n+1, as =&gt; loop n (a::as)
  loop n []

#check @replicate.loop
-- {α : Type} → α → Nat → List α → List α
</code></pre>
<!--
Lean creates an auxiliary declaration for each `let rec`. In the example above,
it created the declaration `replicate.loop` for the `let rec loop` occurring at `replicate`.
Note that, Lean "closes" the declaration by adding any local variable occurring in the
`let rec` declaration as additional parameters. For example, the local variable `a` occurs
at `let rec loop`.

You can also use `let rec` in tactic mode and for creating proofs by induction.
-->
<p>Lean 为每个 <code>let rec</code> 创建一个辅助声明。在上面的例子中，它对于出现在 <code>replicate</code> 的 <code>let rec loop</code> 创建了声明 <code>replication.loop</code>。请注意，Lean 通过添加 <code>let rec</code> 声明中出现的任何局部变量作为附加参数来「关闭」声明。例如，局部变量 <code>a</code> 出现在 <code>let rec</code> 循环中。</p>
<p>你也可以在策略证明模式中使用 <code>let rec</code>，并通过归纳来创建证明。</p>
<pre><code class="language-lean"><span class="boring">def replicate (n : Nat) (a : α) : List α :=
</span><span class="boring"> let rec loop : Nat → List α → List α
</span><span class="boring">   | 0,   as =&gt; as
</span><span class="boring">   | n+1, as =&gt; loop n (a::as)
</span><span class="boring"> loop n []
</span>theorem length_replicate (n : Nat) (a : α) : (replicate n a).length = n := by
  let rec aux (n : Nat) (as : List α)
              : (replicate.loop a n as).length = n + as.length := by
    match n with
    | 0   =&gt; simp [replicate.loop]
    | n+1 =&gt; simp [replicate.loop, aux n, Nat.add_succ, Nat.succ_add]
  exact aux n []
</code></pre>
<!--
You can also introduce auxiliary recursive declarations using `where` clause after your definition.
Lean converts them into a `let rec`.
-->
<p>还可以在定义后使用 <code>where</code> 子句引入辅助递归声明。Lean 将它们转换为 <code>let rec</code>。</p>
<pre><code class="language-lean">def replicate (n : Nat) (a : α) : List α :=
  loop n []
where
  loop : Nat → List α → List α
    | 0,   as =&gt; as
    | n+1, as =&gt; loop n (a::as)

theorem length_replicate (n : Nat) (a : α) : (replicate n a).length = n := by
  exact aux n []
where
  aux (n : Nat) (as : List α)
      : (replicate.loop a n as).length = n + as.length := by
    match n with
    | 0   =&gt; simp [replicate.loop]
    | n+1 =&gt; simp [replicate.loop, aux n, Nat.add_succ, Nat.succ_add]
</code></pre>
<!--
Well-Founded Recursion and Induction
------------------------------------
-->
<h2 id="良基递归和归纳"><a class="header" href="#良基递归和归纳">良基递归和归纳</a></h2>
<!--
When structural recursion cannot be used, we can prove termination using well-founded recursion.
We need a well-founded relation and a proof that each recursive application is decreasing with respect to
this relation. Dependent type theory is powerful enough to encode and justify
well-founded recursion. Let us start with the logical background that
is needed to understand how it works.

Lean's standard library defines two predicates, ``Acc r a`` and
``WellFounded r``, where ``r`` is a binary relation on a type ``α``,
and ``a`` is an element of type ``α``.
-->
<p>当不能使用结构递归时，我们可以使用良基递归（well-founded recursion）来证明终止性。我们需要一个良基关系和一个证明每个递归调用相对于该关系都是递减的证明。依值类型理论具有足够的表达能力来编码和证明良基递归。让我们从理解其工作原理所需的逻辑背景开始。</p>
<p>Lean 的标准库定义了两个谓词，<code>Acc r a</code> 和 <code>WellFounded r</code>，其中 <code>r</code> 是一个在类型 <code>α</code> 上的二元关系，而 <code>a</code> 是类型 <code>α</code> 的一个元素。</p>
<pre><code class="language-lean">variable (α : Sort u)
variable (r : α → α → Prop)

#check (Acc r : α → Prop)
#check (WellFounded r : Prop)
</code></pre>
<!--
The first, ``Acc``, is an inductively defined predicate. According to
its definition, ``Acc r x`` is equivalent to
``∀ y, r y x → Acc r y``. If you think of ``r y x`` as denoting a kind of order relation
``y ≺ x``, then ``Acc r x`` says that ``x`` is accessible from below,
in the sense that all its predecessors are accessible. In particular,
if ``x`` has no predecessors, it is accessible. Given any type ``α``,
we should be able to assign a value to each accessible element of
``α``, recursively, by assigning values to all its predecessors first.

The statement that ``r`` is well founded, denoted ``WellFounded r``,
is exactly the statement that every element of the type is
accessible. By the above considerations, if ``r`` is a well-founded
relation on a type ``α``, we should have a principle of well-founded
recursion on ``α``, with respect to the relation ``r``. And, indeed,
we do: the standard library defines ``WellFounded.fix``, which serves
exactly that purpose.
-->
<p>首先 <code>Acc</code> 是一个归纳定义的谓词。根据定义，<code>Acc r x</code> 等价于
<code>∀ y, r y x → Acc r y</code>。如果你把 <code>r y x</code> 考虑成一种序关系 <code>y ≺ x</code>，那么 <code>Acc r x</code> 说明 <code>x</code> 在下文中可访问，
从某种意义上说，它的所有前继都是可访问的。特别地，如果 <code>x</code> 没有前继，它是可访问的。给定任何类型 <code>α</code>，我们应该能够通过首先为 <code>α</code> 的所有前继元素赋值，递归地为 <code>α</code> 的每个可访问元素赋值。</p>
<p>使用 <code>WellFounded r</code> 来声明 <code>r</code> 是良基的，即说明该类型的每个元素都是可访问的。根据上述考虑，如果 <code>r</code> 是类型 <code>α</code> 上的一个成立良好的关系，那么对于关系 <code>r</code>，我们应该有一个关于 <code>α</code> 的成立良好的递归原则。确实，我们这样做了：标准库定义了 <code>WellFounded.fix</code>，它正好满足这个目的。</p>
<pre><code class="language-lean">noncomputable def f {α : Sort u}
      (r : α → α → Prop)
      (h : WellFounded r)
      (C : α → Sort v)
      (F : (x : α) → ((y : α) → r y x → C y) → C x)
      : (x : α) → C x := WellFounded.fix h F
</code></pre>
<!--
There is a long cast of characters here, but the first block we have
already seen: the type, ``α``, the relation, ``r``, and the
assumption, ``h``, that ``r`` is well founded. The variable ``C``
represents the motive of the recursive definition: for each element
``x : α``, we would like to construct an element of ``C x``. The
function ``F`` provides the inductive recipe for doing that: it tells
us how to construct an element ``C x``, given elements of ``C y`` for
each predecessor ``y`` of ``x``.

Note that ``WellFounded.fix`` works equally well as an induction
principle. It says that if ``≺`` is well founded and you want to prove
``∀ x, C x``, it suffices to show that for an arbitrary ``x``, if we
have ``∀ y ≺ x, C y``, then we have ``C x``.

In the example above we use the modifier `noncomputable` because the code
generator currently does not support `WellFounded.fix`. The function
`WellFounded.fix` is another tool Lean uses to justify that a function
terminates.

Lean knows that the usual order ``<`` on the natural numbers is well
founded. It also knows a number of ways of constructing new well
founded orders from others, for example, using lexicographic order.

Here is essentially the definition of division on the natural numbers that is found in the standard library.
-->
<p>这里有一大堆字，但我们熟悉第一块：类型 <code>α</code>，关系 <code>r</code> 和假设 <code>h</code>，即 <code>r</code> 是有良基的。变量' <code>C</code> 代表递归定义的动机：对于每个元素 <code>x : α</code>，我们想构造一个 <code>C x</code> 的元素。函数 <code>F</code> 提供了这样做的归纳方法：它告诉我们如何构造一个元素 <code>C x</code>，给定 <code>C y</code> 的元素对于 <code>x</code> 的每个 <code>y</code>。</p>
<p>注意 <code>WellFounded.fix</code> 和归纳法原理一样有效。它说如果 <code>≺</code> 是良基的，而你想要证明 <code>∀ x, C x</code>，那么只要证明对于任意的 <code>x</code>，如果我们有 <code>∀ y ≺ x, C y</code>，那么我们就有 <code>C x</code> 就足够了。</p>
<p>在上面的例子中，我们使用了修饰符 <code>noncomputable</code>，因为代码生成器目前不支持 <code>WellFounded.fix</code>。函数 <code>WellFounded.fix</code> 是 Lean 用来证明函数终止的另一个工具。</p>
<p>Lean 知道自然数上通常的序 <code>&lt;</code> 是良基的。它还知道许多从其他东西中构造新的良基的序的方法，例如字典序。</p>
<p>下面是标准库中自然数除法的定义。</p>
<pre><code class="language-lean">open Nat

theorem div_lemma {x y : Nat} : 0 &lt; y ∧ y ≤ x → x - y &lt; x :=
  fun h =&gt; sub_lt (Nat.lt_of_lt_of_le h.left h.right) h.left

def div.F (x : Nat) (f : (x₁ : Nat) → x₁ &lt; x → Nat → Nat) (y : Nat) : Nat :=
  if h : 0 &lt; y ∧ y ≤ x then
    f (x - y) (div_lemma h) y + 1
  else
    zero

noncomputable def div := WellFounded.fix (measure id).wf div.F

#reduce div 8 2 -- 4
</code></pre>
<!--
The definition is somewhat inscrutable. Here the recursion is on
``x``, and ``div.F x f : Nat → Nat`` returns the "divide by ``y``"
function for that fixed ``x``. You have to remember that the second
argument to ``div.F``, the recipe for the recursion, is a function
that is supposed to return the divide by ``y`` function for all values
``x₁`` smaller than ``x``.

The elaborator is designed to make definitions like this more
convenient. It accepts the following:
-->
<p>这个定义有点难以理解。这里递归在 <code>x</code> 上， <code>div.F x f : Nat → Nat</code> 为固定的 <code>x</code> 返回「除以 <code>y</code>」函数。你要记住 <code>div.F</code> 的第二个参数 <code>f</code> 是递归的具体实现，这个函数对所有小于 <code>x</code> 的自然数 <code>x₁</code> 返回「除以 <code>y</code>」函数。</p>
<p>繁饰器（Elaborator）可以使这样的定义更加方便。它接受下列内容:</p>
<pre><code class="language-lean">def div (x y : Nat) : Nat :=
  if h : 0 &lt; y ∧ y ≤ x then
    have : x - y &lt; x := Nat.sub_lt (Nat.lt_of_lt_of_le h.1 h.2) h.1
    div (x - y) y + 1
  else
    0
</code></pre>
<!--
When Lean encounters a recursive definition, it first
tries structural recursion, and only when that fails, does it fall
back on well-founded recursion. Lean uses the tactic `decreasing_tactic`
to show that the recursive applications are smaller. The auxiliary
proposition `x - y < x` in the example above should be viewed as a hint
for this tactic.

The defining equation for ``div`` does *not* hold definitionally, but
we can unfold `div` using the `unfold` tactic. We use [`conv`](./conv.md) to select which
`div` application we want to unfold.
-->
<p>当 Lean 遇到递归定义时，它首先尝试结构递归，失败时才返回到良基递归。Lean 使用 <code>decreasing_tactic</code> 来显示递归应用会越来越小。上面例子中的辅助命题 <code>x - y &lt; x</code> 应该被视为这种策略的提示。</p>
<p><code>div</code> 的定义公式不具有定义性，但我们可以使用 <code>unfold</code> 策略展开 <code>div</code>。我们使用 <a href="./conv.html"><code>conv</code></a> 来选择要展开的 <code>div</code> 应用。</p>
<!--
```lean
# def div (x y : Nat) : Nat :=
#  if h : 0 < y ∧ y ≤ x then
#    have : x - y < x := Nat.sub_lt (Nat.lt_of_lt_of_le h.1 h.2) h.1
#    div (x - y) y + 1
#  else
#    0
example (x y : Nat) : div x y = if 0 < y ∧ y ≤ x then div (x - y) y + 1 else 0 := by
  conv => lhs; unfold div -- unfold occurrence in the left-hand-side of the equation

example (x y : Nat) (h : 0 < y ∧ y ≤ x) : div x y = div (x - y) y + 1 := by
  conv => lhs; unfold div
  simp [h]
```
-->
<pre><code class="language-lean"><span class="boring">def div (x y : Nat) : Nat :=
</span><span class="boring"> if h : 0 &lt; y ∧ y ≤ x then
</span><span class="boring">   have : x - y &lt; x := Nat.sub_lt (Nat.lt_of_lt_of_le h.1 h.2) h.1
</span><span class="boring">   div (x - y) y + 1
</span><span class="boring"> else
</span><span class="boring">   0
</span>example (x y : Nat) : div x y = if 0 &lt; y ∧ y ≤ x then div (x - y) y + 1 else 0 := by
  conv =&gt; lhs; unfold div -- 展开方程左侧的div

example (x y : Nat) (h : 0 &lt; y ∧ y ≤ x) : div x y = div (x - y) y + 1 := by
  conv =&gt; lhs; unfold div
  simp [h]
</code></pre>
<!--
The following example is similar: it converts any natural number to a
binary expression, represented as a list of 0's and 1's. We have to
provide evidence that the recursive call is
decreasing, which we do here with a ``sorry``. The ``sorry`` does not
prevent the interpreter from evaluating the function successfully.
-->
<p>下面的示例与此类似：它将任何自然数转换为二进制表达式，表示为0和1的列表。我们必须提供递归调用正在递减的证据，我们在这里用 <code>sorry</code> 来做。<code>sorry</code> 并不会阻止解释器成功地对函数求值。</p>
<pre><code class="language-lean">def natToBin : Nat → List Nat
  | 0     =&gt; [0]
  | 1     =&gt; [1]
  | n + 2 =&gt;
    have : (n + 2) / 2 &lt; n + 2 := sorry
    natToBin ((n + 2) / 2) ++ [n % 2]

#eval natToBin 1234567
</code></pre>
<!--
As a final example, we observe that Ackermann's function can be
defined directly, because it is justified by the well foundedness of
the lexicographic order on the natural numbers. The `termination_by` clause
instructs Lean to use a lexicographic order. This clause is actually mapping
the function arguments to elements of type `Nat × Nat`. Then, Lean uses typeclass
resolution to synthesize an element of type `WellFoundedRelation (Nat × Nat)`.
-->
<p>最后一个例子，我们观察到Ackermann函数可以直接定义，因为它可以被自然数上字典序的良基性证明。<code>termination_by</code> 子句指示 Lean 使用字典序。这个子句实际上是将函数参数映射到类型为 <code>Nat × Nat</code> 的元素。然后，Lean 使用类型类解析来合成类型为 <code>WellFoundedRelation (Nat × Nat)</code> 的元素。</p>
<pre><code class="language-lean">def ack : Nat → Nat → Nat
  | 0,   y   =&gt; y+1
  | x+1, 0   =&gt; ack x 1
  | x+1, y+1 =&gt; ack x (ack (x+1) y)
termination_by x y =&gt; (x, y)
</code></pre>
<!--
Note that a lexicographic order is used in the example above because the instance
`WellFoundedRelation (α × β)` uses a lexicographic order. Lean also defines the instance
-->
<p>注意，在上面的例子中使用了字典序，因为实例 <code>WellFoundedRelation (α × β)</code> 使用了字典序。Lean 还定义了实例</p>
<pre><code class="language-lean">instance (priority := low) [SizeOf α] : WellFoundedRelation α :=
  sizeOfWFRel
</code></pre>
<!--
In the following example, we prove termination by showing that `as.size - i` is decreasing
in the recursive application.
-->
<p>在下面的例子中，我们通过显示 <code>as.size - i</code> 在递归应用中是递减的来证明它会终止。</p>
<pre><code class="language-lean">def takeWhile (p : α → Bool) (as : Array α) : Array α :=
  go 0 #[]
where
  go (i : Nat) (r : Array α) : Array α :=
    if h : i &lt; as.size then
      let a := as.get ⟨i, h⟩
      if p a then
        go (i+1) (r.push a)
      else
        r
    else
      r
  termination_by as.size - i
</code></pre>
<!--
Note that, auxiliary function `go` is recursive in this example, but `takeWhile` is not.

By default, Lean uses the tactic `decreasing_tactic` to prove recursive applications are decreasing. The modifier `decreasing_by` allows us to provide our own tactic. Here is an example.
-->
<p>注意，辅助函数 <code>go</code> 在这个例子中是递归的，但 <code>takeWhile</code> 不是。</p>
<p>默认情况下，Lean 使用 <code>decreasing_tactic</code> 来证明递归应用正在递减。修饰词 <code>decreasing_by</code> 允许我们提供自己的策略。这里有一个例子。</p>
<pre><code class="language-lean">theorem div_lemma {x y : Nat} : 0 &lt; y ∧ y ≤ x → x - y &lt; x :=
  fun ⟨ypos, ylex⟩ =&gt; Nat.sub_lt (Nat.lt_of_lt_of_le ypos ylex) ypos

def div (x y : Nat) : Nat :=
  if h : 0 &lt; y ∧ y ≤ x then
    div (x - y) y + 1
  else
    0
decreasing_by apply div_lemma; assumption
</code></pre>
<!--
Note that `decreasing_by` is not replacement for `termination_by`, they complement each other. `termination_by` is used to specify a well-founded relation, and `decreasing_by` for providing our own tactic for showing recursive applications are decreasing. In the following example, we use both of them.
-->
<p>注意 <code>decreasing_by</code> 不是 <code>termination_by</code> 的替代，它们是互补的。 <code>termination_by</code> 用于指定一个良基关系， <code>decreasing_by</code> 用于提供我们自己的策略来显示递归应用正在递减。在下面的示例中，我们将同时使用它们。</p>
<!--
```lean
def ack : Nat → Nat → Nat
  | 0,   y   => y+1
  | x+1, 0   => ack x 1
  | x+1, y+1 => ack x (ack (x+1) y)
termination_by x y => (x, y)
decreasing_by
  all_goals simp_wf -- unfolds well-founded recursion auxiliary definitions
  · apply Prod.Lex.left; simp_arith
  · apply Prod.Lex.right; simp_arith
  · apply Prod.Lex.left; simp_arith
```

-->
<pre><code class="language-lean">def ack : Nat → Nat → Nat
  | 0,   y   =&gt; y+1
  | x+1, 0   =&gt; ack x 1
  | x+1, y+1 =&gt; ack x (ack (x+1) y)
termination_by x y =&gt; (x, y)
decreasing_by
  all_goals simp_wf -- 展开良基的递归辅助定义
  · apply Prod.Lex.left; simp_arith
  · apply Prod.Lex.right; simp_arith
  · apply Prod.Lex.left; simp_arith
</code></pre>
<!--
We can use `decreasing_by sorry` to instruct Lean to "trust" us that the function terminates.
-->
<p>我们可以使用 <code>decreasing_by sorry</code> 来指示 Lean 「相信」函数可以终止。</p>
<pre><code class="language-lean">def natToBin : Nat → List Nat
  | 0     =&gt; [0]
  | 1     =&gt; [1]
  | n + 2 =&gt; natToBin ((n + 2) / 2) ++ [n % 2]
decreasing_by sorry

#eval natToBin 1234567
</code></pre>
<!--
Recall that using `sorry` is equivalent to using a new axiom, and should be avoided. In the following example, we used the `sorry` to prove `False`. The command `#print axioms` shows that `unsound` depends on the unsound axiom `sorryAx` used to implement `sorry`.
-->
<p>回想一下，使用 <code>sorry</code> 相当于使用一个新的公理，应该避免使用。在下面的例子中，我们用 <code>sorry</code> 来证明 <code>False</code>。命令 <code>#print axioms</code> 显示，<code>unsound</code> 依赖于用于实现 <code>sorry</code> 的不健全公理 <code>sorryAx</code>。</p>
<!--
```lean
def unsound (x : Nat) : False :=
  unsound (x + 1)
decreasing_by sorry

#check unsound 0
-- `unsound 0` is a proof of `False`

#print axioms unsound
-- 'unsound' depends on axioms: [sorryAx]
```
-->
<pre><code class="language-lean">def unsound (x : Nat) : False :=
  unsound (x + 1)
decreasing_by sorry

#check unsound 0
-- `unsound 0` 是 `False` 的一个证明

#print axioms unsound
-- 'unsound' 依赖于公理：[sorryAx]
</code></pre>
<!--
Summary:

- If there is no `termination_by`, a well-founded relation is derived (if possible) by selecting an argument and then using typeclass resolution to synthesize a well-founded relation for this argument's type.

- If `termination_by` is specified, it maps the arguments of the function to a type `α` and type class resolution is again used. Recall that, the default instance for `β × γ` is a lexicographic order based on the well-founded relations for `β` and `γ`.

- The default well-founded relation instance for `Nat` is `<`.

- By default, the tactic `decreasing_tactic` is used to show that recursive applications are smaller with respect to the selected well-founded relation. If `decreasing_tactic` fails, the error message includes the remaining goal `... |- G`. Note that, the `decreasing_tactic` uses `assumption`. So, you can include a `have`-expression to prove goal `G`. You can also provide your own tactic using `decreasing_by`.
-->
<p>总结：</p>
<ul>
<li>
<p>如果没有 <code>termination_by</code>，良基关系（可能）可以这样被导出：选择一个参数，然后使用类型类解析为该参数的类型合成一个良基关系。</p>
</li>
<li>
<p>如果指定了 <code>termination_by</code>，它将函数的参数映射为类型 <code>α</code>，并再次使用类型类解析。 回想一下，<code>β × γ</code> 的默认实例是基于 <code>β</code> 和 <code>γ</code>的良基关系的字典序。</p>
</li>
<li></li>
<li>
<p><code>Nat</code> 的默认良基关系实例是 <code>&lt;</code>。</p>
</li>
<li>
<p>默认情况下，策略 <code>decreasing_tactic</code> 用于显示递归应用小于选择的良基关系。如果 <code>decreasing_tactic</code> 失败，错误信息包括剩余目标 <code>... |- G</code>。注意，<code>decreasing_tactic</code> 使用 <code>assumption</code>。所以，你可以用 <code>have</code> 表达式来证明目标 <code>G</code>。你也可以使用 <code>decreasing_by</code> 来提供你自己的策略。</p>
</li>
</ul>
<!--
Mutual Recursion
-->
<h2 id="相互递归"><a class="header" href="#相互递归">相互递归</a></h2>
<!--
Lean also supports mutual recursive definitions. The syntax is similar to that for mutual inductive types. Here is an example:
-->
<p>Lean 还提供相互递归定义，语法类似相互归纳类型。例子：</p>
<pre><code class="language-lean">mutual
  def even : Nat → Bool
    | 0   =&gt; true
    | n+1 =&gt; odd n

  def odd : Nat → Bool
    | 0   =&gt; false
    | n+1 =&gt; even n
end

example : even (a + 1) = odd a := by
  simp [even]

example : odd (a + 1) = even a := by
  simp [odd]

theorem even_eq_not_odd : ∀ a, even a = not (odd a) := by
  intro a; induction a
  . simp [even, odd]
  . simp [even, odd, *]
</code></pre>
<p>这是一个相互的定义，因为 <code>even</code> 是用 <code>odd</code> 递归定义的，而 <code>odd</code> 是用 <code>even</code> 递归定义的。在底层，它被编译为单个递归定义。内部定义的函数接受sum类型的元素作为参数，可以是 <code>even</code> 的输入，也可以是 <code>odd</code> 的输入。然后，它返回与输入相适应的输出。为了定义这个功能，Lean 使用了一个合适的、良基的度量。内部是对用户隐藏的；使用这些定义的规范方法是使用 <code>simp</code> （或 <code>unfold</code>），正如我们上面所做的那样。</p>
<p>相互递归定义还提供了处理相互和嵌套归纳类型的自然方法。回想一下前面提到的 <code>Even</code> 和 <code>Odd</code> 作为相互归纳谓词的定义。</p>
<pre><code class="language-lean">mutual
  inductive Even : Nat → Prop where
    | even_zero : Even 0
    | even_succ : ∀ n, Odd n → Even (n + 1)

  inductive Odd : Nat → Prop where
    | odd_succ : ∀ n, Even n → Odd (n + 1)
end
</code></pre>
<!--
The constructors, ``even_zero``, ``even_succ``, and ``odd_succ`` provide positive means for showing that a number is even or odd. We need to use the fact that the inductive type is generated by these constructors to know that zero is not odd, and that the latter two implications reverse. As usual, the constructors are kept in a namespace that is named after the type being defined, and the command ``open Even Odd`` allows us to access them more conveniently.
-->
<p>构造子 <code>even_zero</code>、<code>even_succ</code> 和 <code>odd_succ</code> 提供了显示数字是偶数还是奇数的积极方法。我们需要利用归纳类型是由这些构造子生成的这一事实来知道零不是奇数，并且后两个含义是相反的。像往常一样，构造子保存在以定义的类型命名的命名空间中，并且命令 <code>open Even Odd</code> 允许我们更方便地访问它们。</p>
<pre><code class="language-lean"><span class="boring">mutual
</span><span class="boring"> inductive Even : Nat → Prop where
</span><span class="boring">   | even_zero : Even 0
</span><span class="boring">   | even_succ : ∀ n, Odd n → Even (n + 1)
</span><span class="boring"> inductive Odd : Nat → Prop where
</span><span class="boring">   | odd_succ : ∀ n, Even n → Odd (n + 1)
</span><span class="boring">end
</span>open Even Odd

theorem not_odd_zero : ¬ Odd 0 :=
  fun h =&gt; nomatch h

theorem even_of_odd_succ : ∀ n, Odd (n + 1) → Even n
  | _, odd_succ n h =&gt; h

theorem odd_of_even_succ : ∀ n, Even (n + 1) → Odd n
  | _, even_succ n h =&gt; h
</code></pre>
<!--
For another example, suppose we use a nested inductive type to define a set of terms inductively, so that a term is either a constant (with a name given by a string), or the result of applying a constant to a list of constants.
-->
<p>另一个例子，假设我们使用嵌套归纳类型来归纳定义一组项，这样，项要么是常量(由字符串给出名称)，要么是将常量应用于常量列表的结果。</p>
<pre><code class="language-lean">inductive Term where
  | const : String → Term
  | app   : String → List Term → Term
</code></pre>
<!--
We can then use a mutual recursive definition to count the number of constants occurring in a term, as well as the number occurring in a list of terms.
-->
<p>然后，我们可以使用一个相互递归的定义来计算在一个项中出现的常量的数量，以及在一个项列表中出现的常量的数量。</p>
<pre><code class="language-lean"><span class="boring">inductive Term where
</span><span class="boring"> | const : String → Term
</span><span class="boring"> | app   : String → List Term → Term
</span>namespace Term

mutual
  def numConsts : Term → Nat
    | const _ =&gt; 1
    | app _ cs =&gt; numConstsLst cs

  def numConstsLst : List Term → Nat
    | [] =&gt; 0
    | c :: cs =&gt; numConsts c + numConstsLst cs
end

def sample := app &quot;f&quot; [app &quot;g&quot; [const &quot;x&quot;], const &quot;y&quot;]

#eval numConsts sample

end Term
</code></pre>
<!--
As a final example, we define a function `replaceConst a b e` that replaces a constant `a` with `b` in a term `e`, and then prove the number of constants is the same. Note that, our proof uses mutual recursion (aka induction).
-->
<p>作为最后一个例子，我们定义了一个函数 <code>replaceConst a b e</code>，它将项 <code>e</code> 中的常数 <code>a</code> 替换为 <code>b</code>，然后证明常数的数量是相同的。注意，我们的证明使用了相互递归（即归纳法）。</p>
<pre><code class="language-lean"><span class="boring">inductive Term where
</span><span class="boring"> | const : String → Term
</span><span class="boring"> | app   : String → List Term → Term
</span><span class="boring">namespace Term
</span><span class="boring">mutual
</span><span class="boring"> def numConsts : Term → Nat
</span><span class="boring">   | const _ =&gt; 1
</span><span class="boring">   | app _ cs =&gt; numConstsLst cs
</span><span class="boring">  def numConstsLst : List Term → Nat
</span><span class="boring">   | [] =&gt; 0
</span><span class="boring">   | c :: cs =&gt; numConsts c + numConstsLst cs
</span><span class="boring">end
</span>mutual
  def replaceConst (a b : String) : Term → Term
    | const c =&gt; if a == c then const b else const c
    | app f cs =&gt; app f (replaceConstLst a b cs)

  def replaceConstLst (a b : String) : List Term → List Term
    | [] =&gt; []
    | c :: cs =&gt; replaceConst a b c :: replaceConstLst a b cs
end

mutual
  theorem numConsts_replaceConst (a b : String) (e : Term)
            : numConsts (replaceConst a b e) = numConsts e := by
    match e with
    | const c =&gt; simp [replaceConst]; split &lt;;&gt; simp [numConsts]
    | app f cs =&gt; simp [replaceConst, numConsts, numConsts_replaceConstLst a b cs]

  theorem numConsts_replaceConstLst (a b : String) (es : List Term)
            : numConstsLst (replaceConstLst a b es) = numConstsLst es := by
    match es with
    | [] =&gt; simp [replaceConstLst, numConstsLst]
    | c :: cs =&gt;
      simp [replaceConstLst, numConstsLst, numConsts_replaceConst a b c,
            numConsts_replaceConstLst a b cs]
end
</code></pre>
<!--
Dependent Pattern Matching
--------------------------
-->
<h2 id="依值模式匹配"><a class="header" href="#依值模式匹配">依值模式匹配</a></h2>
<!--
All the examples of pattern matching we considered in
[Section Pattern Matching](#pattern-matching) can easily be written using ``casesOn``
and ``recOn``. However, this is often not the case with indexed
inductive families such as ``Vector α n``, since case splits impose
constraints on the values of the indices. Without the equation
compiler, we would need a lot of boilerplate code to define very
simple functions such as ``map``, ``zip``, and ``unzip`` using
recursors. To understand the difficulty, consider what it would take
to define a function ``tail`` which takes a vector
``v : Vector α (succ n)`` and deletes the first element. A first thought might be to
use the ``casesOn`` function:
-->
<p>我们在<a href="induction_and_recursion.html#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D">模式匹配</a>一节中考虑的所有模式匹配示例都可以很容易地使用 <code>casesOn</code> 和 <code>recOn</code> 来编写。然而，对于索引归纳族，如 <code>Vector α n</code>，通常不是这种情况，因为区分情况要对索引的值施加约束。如果没有方程编译器，我们将需要大量的样板代码来定义非常简单的函数，例如使用递归定义 <code>map</code>、<code>zip</code> 和 <code>unzip</code>。为了理解其中的困难，考虑一下如何定义一个函数 <code>tail</code>，它接受一个向量 <code>v : Vector α (succ n)</code> 并删除第一个元素。首先想到的可能是使用 <code>casesOn</code> 函数:</p>
<pre><code class="language-lean">inductive Vector (α : Type u) : Nat → Type u
  | nil  : Vector α 0
  | cons : α → {n : Nat} → Vector α n → Vector α (n+1)

namespace Vector

#check @Vector.casesOn
/-
  {α : Type u}
  → {motive : (a : Nat) → Vector α a → Sort v} →
  → {a : Nat} → (t : Vector α a)
  → motive 0 nil
  → ((a : α) → {n : Nat} → (a_1 : Vector α n) → motive (n + 1) (cons a a_1))
  → motive a t
-/

end Vector
</code></pre>
<!--
But what value should we return in the ``nil`` case? Something funny
is going on: if ``v`` has type ``Vector α (succ n)``, it *can't* be
nil, but it is not clear how to tell that to ``casesOn``.

One solution is to define an auxiliary function:
-->
<p>但是在 <code>nil</code> 的情况下我们应该返回什么值呢？有趣的事情来了：如果 <code>v</code> 具有 <code>Vector α (succ n)</code> 类型，它「不能」为nil，但很难告诉 <code>casesOn</code>。</p>
<p>一种解决方案是定义一个辅助函数:</p>
<pre><code class="language-lean"><span class="boring">inductive Vector (α : Type u) : Nat → Type u
</span><span class="boring">  | nil  : Vector α 0
</span><span class="boring">  | cons : α → {n : Nat} → Vector α n → Vector α (n+1)
</span><span class="boring">namespace Vector
</span>def tailAux (v : Vector α m) : m = n + 1 → Vector α n :=
  Vector.casesOn (motive := fun x _ =&gt; x = n + 1 → Vector α n) v
    (fun h : 0 = n + 1 =&gt; Nat.noConfusion h)
    (fun (a : α) (m : Nat) (as : Vector α m) =&gt;
     fun (h : m + 1 = n + 1) =&gt;
       Nat.noConfusion h (fun h1 : m = n =&gt; h1 ▸ as))

def tail (v : Vector α (n+1)) : Vector α n :=
  tailAux v rfl
<span class="boring">end Vector
</span></code></pre>
<!--
In the ``nil`` case, ``m`` is instantiated to ``0``, and
``noConfusion`` makes use of the fact that ``0 = succ n`` cannot
occur.  Otherwise, ``v`` is of the form ``a :: w``, and we can simply
return ``w``, after casting it from a vector of length ``m`` to a
vector of length ``n``.

The difficulty in defining ``tail`` is to maintain the relationships between the indices.
The hypothesis ``e : m = n + 1`` in ``tailAux`` is used to communicate the relationship
between ``n`` and the index associated with the minor premise.
Moreover, the ``zero = n + 1`` case is unreachable, and the canonical way to discard such
a case is to use ``noConfusion``.

The ``tail`` function is, however, easy to define using recursive
equations, and the equation compiler generates all the boilerplate
code automatically for us. Here are a number of similar examples:
-->
<p>在 <code>nil</code> 的情况下，<code>m</code> 被实例化为 <code>0</code>，<code>noConfusion</code> 利用了 <code>0 = succ n</code> 不能出现的事实。否则，<code>v</code> 的形式为 <code>a :: w</code>，我们可以简单地将 <code>w</code> 从长度 <code>m</code> 的向量转换为长度 <code>n</code> 的向量后返回 <code>w</code>。</p>
<p>定义 <code>tail</code> 的困难在于维持索引之间的关系。 <code>tailAux</code> 中的假设 <code>e : m = n + 1</code> 用于传达 <code>n</code> 与与小前提相关的索引之间的关系。此外，<code>zero = n + 1</code> 的情况是不可达的，而放弃这种情况的规范方法是使用 <code>noConfusion</code>。</p>
<p>然而，<code>tail</code> 函数很容易使用递归方程来定义，并且方程编译器会自动为我们生成所有样板代码。下面是一些类似的例子:</p>
<pre><code class="language-lean"><span class="boring">inductive Vector (α : Type u) : Nat → Type u
</span><span class="boring">  | nil  : Vector α 0
</span><span class="boring">  | cons : α → {n : Nat} → Vector α n → Vector α (n+1)
</span><span class="boring">namespace Vector
</span>def head : {n : Nat} → Vector α (n+1) → α
  | n, cons a as =&gt; a

def tail : {n : Nat} → Vector α (n+1) → Vector α n
  | n, cons a as =&gt; as

theorem eta : ∀ {n : Nat} (v : Vector α (n+1)), cons (head v) (tail v) = v
  | n, cons a as =&gt; rfl

def map (f : α → β → γ) : {n : Nat} → Vector α n → Vector β n → Vector γ n
  | 0,   nil,       nil       =&gt; nil
  | n+1, cons a as, cons b bs =&gt; cons (f a b) (map f as bs)

def zip : {n : Nat} → Vector α n → Vector β n → Vector (α × β) n
  | 0,   nil,       nil       =&gt; nil
  | n+1, cons a as, cons b bs =&gt; cons (a, b) (zip as bs)
<span class="boring">end Vector
</span></code></pre>
<!--
Note that we can omit recursive equations for "unreachable" cases such
as ``head nil``. The automatically generated definitions for indexed
families are far from straightforward. For example:
-->
<p>注意，对于「不可达」的情况，例如 <code>head nil</code>，我们可以省略递归方程。为索引族自动生成的定义远非直截了当。例如:</p>
<pre><code class="language-lean"><span class="boring">inductive Vector (α : Type u) : Nat → Type u
</span><span class="boring">  | nil  : Vector α 0
</span><span class="boring">  | cons : α → {n : Nat} → Vector α n → Vector α (n+1)
</span><span class="boring">namespace Vector
</span>def map (f : α → β → γ) : {n : Nat} → Vector α n → Vector β n → Vector γ n
  | 0,   nil,       nil       =&gt; nil
  | n+1, cons a as, cons b bs =&gt; cons (f a b) (map f as bs)

#print map
#print map.match_1
<span class="boring">end Vector
</span></code></pre>
<!--
The ``map`` function is even more tedious to define by hand than the
``tail`` function. We encourage you to try it, using ``recOn``,
``casesOn`` and ``noConfusion``.
-->
<p>与 <code>tail</code> 函数相比，<code>map</code> 函数手工定义更加繁琐。我们鼓励您尝试使用 <code>recOn</code>、<code>casesOn</code> 和 <code>noConfusion</code>。</p>
<!--
Inaccessible Patterns
------------------
-->
<h2 id="不可访问模式"><a class="header" href="#不可访问模式">不可访问模式</a></h2>
<!--
Sometimes an argument in a dependent matching pattern is not essential
to the definition, but nonetheless has to be included to specialize
the type of the expression appropriately. Lean allows users to mark
such subterms as *inaccessible* for pattern matching. These
annotations are essential, for example, when a term occurring in the
left-hand side is neither a variable nor a constructor application,
because these are not suitable targets for pattern matching. We can
view such inaccessible patterns as "don't care" components of the
patterns. You can declare a subterm inaccessible by writing
``.(t)``. If the inaccessible pattern can be inferred, you can also write
``_``.

The following example, we declare an inductive type that defines the
property of "being in the image of ``f``". You can view an element of
the type ``ImageOf f b`` as evidence that ``b`` is in the image of
``f``, whereby the constructor ``imf`` is used to build such
evidence. We can then define any function ``f`` with an "inverse"
which takes anything in the image of ``f`` to an element that is
mapped to it. The typing rules forces us to write ``f a`` for the
first argument, but this term is neither a variable nor a constructor
application, and plays no role in the pattern-matching definition. To
define the function ``inverse`` below, we *have to* mark ``f a``
inaccessible.
-->
<p>有时候，依值匹配模式中的参数对定义来说并不是必需的，但是必须包含它来适当地确定表达式的类型。Lean 允许用户将这些子项标记为「不可访问」以进行模式匹配。例如，当左侧出现的项既不是变量也不是构造子应用时，这些注解是必不可少的，因为它们不适合用于模式匹配的目标。我们可以将这种不可访问的模式视为模式的「不关心」组件。你可以通过写 <code>.(t)</code> 来声明子项不可访问。如果不可访问的模式可以被推断出来，你也可以写 <code>_</code>。</p>
<p>下面的例子中，我们声明了一个归纳类型，它定义了「在 <code>f</code> 的像中」的属性。您可以将 <code>ImageOf f b</code> 类型的元素视为 <code>b</code> 位于 <code>f</code> 的像中的证据，构造子 <code>imf</code> 用于构建此类证据。然后，我们可以定义任何函数 <code>f</code> 的「逆」，逆函数将 <code>f</code> 的像中的任何元素赋给映射到它的元素。类型规则迫使我们为第一个参数写 <code>f a</code>，但是这个项既不是变量也不是构造子应用，并且在模式匹配定义中没有作用。为了定义下面的函数 <code>inverse</code>，我们必须将 <code>f a</code> 标记为不可访问。</p>
<pre><code class="language-lean">inductive ImageOf {α β : Type u} (f : α → β) : β → Type u where
  | imf : (a : α) → ImageOf f (f a)

open ImageOf

def inverse {f : α → β} : (b : β) → ImageOf f b → α
  | .(f a), imf a =&gt; a

def inverse' {f : α → β} : (b : β) → ImageOf f b → α
  | _, imf a =&gt; a
</code></pre>
<!--
In the example above, the inaccessible annotation makes it clear that
``f`` is *not* a pattern matching variable.

Inaccessible patterns can be used to clarify and control definitions that
make use of dependent pattern matching. Consider the following
definition of the function ``Vector.add``, which adds two vectors of
elements of a type, assuming that type has an associated addition
function:
-->
<p>在上面的例子中，不可访问记号清楚地表明 <code>f</code> 不是一个模式匹配变量。</p>
<p>不可访问模式可用于澄清和控制使用依值模式匹配的定义。考虑函数 <code>Vector.add</code> 的以下定义，假设该类型有满足结合律的加法函数，它将一个类型的两个元素向量相加:</p>
<pre><code class="language-lean">inductive Vector (α : Type u) : Nat → Type u
  | nil  : Vector α 0
  | cons : α → {n : Nat} → Vector α n → Vector α (n+1)

namespace Vector

def add [Add α] : {n : Nat} → Vector α n → Vector α n → Vector α n
  | 0,   nil,       nil       =&gt; nil
  | n+1, cons a as, cons b bs =&gt; cons (a + b) (add as bs)

end Vector
</code></pre>
<!--
The argument ``{n : Nat}`` appear after the colon, because it cannot
be held fixed throughout the definition.  When implementing this
definition, the equation compiler starts with a case distinction as to
whether the first argument is ``0`` or of the form ``n+1``.  This is
followed by nested case splits on the next two arguments, and in each
case the equation compiler rules out the cases are not compatible with
the first pattern.

But, in fact, a case split is not required on the first argument; the
``casesOn`` eliminator for ``Vector`` automatically abstracts this
argument and replaces it by ``0`` and ``n + 1`` when we do a case
split on the second argument. Using inaccessible patterns, we can prompt
the equation compiler to avoid the case split on ``n``
-->
<p>参数 <code>{n : Nat}</code> 出现在冒号之后，因为它不能在整个定义中保持固定。在实现这个定义时，方程编译器首先区分第一个参数是 <code>0</code> 还是 <code>n+1</code>。对接下来的两个参数嵌套地区分情况，在每种情况下，方程编译器都会排除与第一个模式不兼容的情况。</p>
<p>但事实上，在第一个参数上不需要区分情况；当我们对第二个参数区分情况时，<code>Vector</code> 的 <code>casesOn</code> 消去器会自动抽象该参数，并将其替换为 <code>0</code> 和 <code>n + 1</code>。使用不可访问的模式，我们可以提示方程编译器不要在 <code>n</code> 上区分情况。</p>
<pre><code class="language-lean"><span class="boring">inductive Vector (α : Type u) : Nat → Type u
</span><span class="boring">  | nil  : Vector α 0
</span><span class="boring">  | cons : α → {n : Nat} → Vector α n → Vector α (n+1)
</span><span class="boring">namespace Vector
</span>def add [Add α] : {n : Nat} → Vector α n → Vector α n → Vector α n
  | .(_), nil,       nil       =&gt; nil
  | .(_), cons a as, cons b bs =&gt; cons (a + b) (add as bs)
<span class="boring">end Vector
</span></code></pre>
<!--
Marking the position as an inaccessible pattern tells the
equation compiler first, that the form of the argument should be
inferred from the constraints posed by the other arguments, and,
second, that the first argument should *not* participate in pattern
matching.

The inaccessible pattern `.(_)` can be written as `_` for convenience.
-->
<p>将位置标记为不可访问模式首先告诉方程编译器，参数的形式应该从其他参数所构成的约束中推断出来，其次，第一个参数不应该参与模式匹配。</p>
<p>为简便起见，不可访问的模式 <code>.(_)</code> 可以写成 <code>_</code>。</p>
<pre><code class="language-lean"><span class="boring">inductive Vector (α : Type u) : Nat → Type u
</span><span class="boring">  | nil  : Vector α 0
</span><span class="boring">  | cons : α → {n : Nat} → Vector α n → Vector α (n+1)
</span><span class="boring">namespace Vector
</span>def add [Add α] : {n : Nat} → Vector α n → Vector α n → Vector α n
  | _, nil,       nil       =&gt; nil
  | _, cons a as, cons b bs =&gt; cons (a + b) (add as bs)
<span class="boring">end Vector
</span></code></pre>
<!--
As we mentioned above, the argument ``{n : Nat}`` is part of the
pattern matching, because it cannot be held fixed throughout the
definition. In previous Lean versions, users often found it cumbersome
to have to include these extra discriminants. Thus, Lean 4
implements a new feature, *discriminant refinement*, which includes
these extra discriminants automatically for us.
-->
<p>如前所述，参数 <code>{n : Nat}</code> 是模式匹配的一部分，因为它不能在整个定义中保持固定。在以前的 Lean 版本中，用户经常发现必须包含这些额外的判别符是很麻烦的。因此，Lean 4 实现了一个新特性， <strong>判别精炼（discriminant refinement）</strong> ，它自动为我们包含了这些额外的判别。</p>
<pre><code class="language-lean"><span class="boring">inductive Vector (α : Type u) : Nat → Type u
</span><span class="boring">  | nil  : Vector α 0
</span><span class="boring">  | cons : α → {n : Nat} → Vector α n → Vector α (n+1)
</span><span class="boring">namespace Vector
</span>def add [Add α] {n : Nat} : Vector α n → Vector α n → Vector α n
  | nil,       nil       =&gt; nil
  | cons a as, cons b bs =&gt; cons (a + b) (add as bs)
<span class="boring">end Vector
</span></code></pre>
<!--
When combined with the *auto bound implicits* feature, you can simplify
the declare further and write:
-->
<p>当与「自动绑定隐式」特性结合使用时，你可以进一步简化声明并这样写：</p>
<pre><code class="language-lean"><span class="boring">inductive Vector (α : Type u) : Nat → Type u
</span><span class="boring">  | nil  : Vector α 0
</span><span class="boring">  | cons : α → {n : Nat} → Vector α n → Vector α (n+1)
</span><span class="boring">namespace Vector
</span>def add [Add α] : Vector α n → Vector α n → Vector α n
  | nil,       nil       =&gt; nil
  | cons a as, cons b bs =&gt; cons (a + b) (add as bs)
<span class="boring">end Vector
</span></code></pre>
<!--
Using these new features, you can write the other vector functions defined
in the previous sections more compactly as follows:
-->
<p>使用这些新特性，您可以更紧凑地编写在前几节中定义的其他向量函数，如下所示:</p>
<pre><code class="language-lean"><span class="boring">inductive Vector (α : Type u) : Nat → Type u
</span><span class="boring">  | nil  : Vector α 0
</span><span class="boring">  | cons : α → {n : Nat} → Vector α n → Vector α (n+1)
</span><span class="boring">namespace Vector
</span>def head : Vector α (n+1) → α
  | cons a as =&gt; a

def tail : Vector α (n+1) → Vector α n
  | cons a as =&gt; as

theorem eta : (v : Vector α (n+1)) → cons (head v) (tail v) = v
  | cons a as =&gt; rfl

def map (f : α → β → γ) : Vector α n → Vector β n → Vector γ n
  | nil,       nil       =&gt; nil
  | cons a as, cons b bs =&gt; cons (f a b) (map f as bs)

def zip : Vector α n → Vector β n → Vector (α × β) n
  | nil,       nil       =&gt; nil
  | cons a as, cons b bs =&gt; cons (a, b) (zip as bs)
<span class="boring">end Vector
</span></code></pre>
<!--
Match Expressions
-----------------
-->
<h2 id="match-表达式"><a class="header" href="#match-表达式">Match 表达式</a></h2>
<!--
Lean also provides a compiler for *match-with* expressions found in
many functional languages.
-->
<p>Lean 还提供「match-with」表达式，它在很多函数式语言中都能找到。</p>
<pre><code class="language-lean">def isNotZero (m : Nat) : Bool :=
  match m with
  | 0   =&gt; false
  | n+1 =&gt; true
</code></pre>
<!--
This does not look very different from an ordinary pattern matching
definition, but the point is that a ``match`` can be used anywhere in
an expression, and with arbitrary arguments.
-->
<p>这看起来与普通的模式匹配定义没有太大的不同，但关键是 <code>match</code> 可以在表达式中的任何地方使用，并带有任意参数。</p>
<pre><code class="language-lean">def isNotZero (m : Nat) : Bool :=
  match m with
  | 0   =&gt; false
  | n+1 =&gt; true

def filter (p : α → Bool) : List α → List α
  | []      =&gt; []
  | a :: as =&gt;
    match p a with
    | true =&gt; a :: filter p as
    | false =&gt; filter p as

example : filter isNotZero [1, 0, 0, 3, 0] = [1, 3] := rfl
</code></pre>
<!--
Here is another example:
-->
<p>另一例：</p>
<pre><code class="language-lean">def foo (n : Nat) (b c : Bool) :=
  5 + match n - 5, b &amp;&amp; c with
      | 0,   true  =&gt; 0
      | m+1, true  =&gt; m + 7
      | 0,   false =&gt; 5
      | m+1, false =&gt; m + 3

#eval foo 7 true false

example : foo 7 true false = 9 := rfl
</code></pre>
<!--
Lean uses the ``match`` construct internally to implement pattern-matching in all parts of the system.
Thus, all four of these definitions have the same net effect.
-->
<p>Lean 使用内建的 <code>match</code> 来实现系统所有地方的模式匹配。因此，这四种定义具有相同的净效果。</p>
<pre><code class="language-lean">def bar₁ : Nat × Nat → Nat
  | (m, n) =&gt; m + n

def bar₂ (p : Nat × Nat) : Nat :=
  match p with
  | (m, n) =&gt; m + n

def bar₃ : Nat × Nat → Nat :=
  fun (m, n) =&gt; m + n

def bar₄ (p : Nat × Nat) : Nat :=
  let (m, n) := p; m + n
</code></pre>
<!--
These variations are equally useful for destructing propositions:
-->
<p>这些变体在解构命题中也是同样有用的：</p>
<pre><code class="language-lean">variable (p q : Nat → Prop)

example : (∃ x, p x) → (∃ y, q y) → ∃ x y, p x ∧ q y
  | ⟨x, px⟩, ⟨y, qy⟩ =&gt; ⟨x, y, px, qy⟩

example (h₀ : ∃ x, p x) (h₁ : ∃ y, q y)
        : ∃ x y, p x ∧ q y :=
  match h₀, h₁ with
  | ⟨x, px⟩, ⟨y, qy⟩ =&gt; ⟨x, y, px, qy⟩

example : (∃ x, p x) → (∃ y, q y) → ∃ x y, p x ∧ q y :=
  fun ⟨x, px⟩ ⟨y, qy⟩ =&gt; ⟨x, y, px, qy⟩

example (h₀ : ∃ x, p x) (h₁ : ∃ y, q y)
        : ∃ x y, p x ∧ q y :=
  let ⟨x, px⟩ := h₀
  let ⟨y, qy⟩ := h₁
  ⟨x, y, px, qy⟩
</code></pre>
<!--
Local Recursive Declarations
---------
-->
<h2 id="局域递归声明-1"><a class="header" href="#局域递归声明-1">局域递归声明</a></h2>
<!--
You can define local recursive declarations using the `let rec` keyword.
-->
<p>可以通过 <code>let rec</code> 关键字定义局域递归声明。</p>
<pre><code class="language-lean">def replicate (n : Nat) (a : α) : List α :=
  let rec loop : Nat → List α → List α
    | 0,   as =&gt; as
    | n+1, as =&gt; loop n (a::as)
  loop n []

#check @replicate.loop
-- {α : Type} → α → Nat → List α → List α
</code></pre>
<!--
Lean creates an auxiliary declaration for each `let rec`. In the example above,
it created the declaration `replicate.loop` for the `let rec loop` occurring at `replicate`.
Note that, Lean "closes" the declaration by adding any local variable occurring in the
`let rec` declaration as additional parameters. For example, the local variable `a` occurs
at `let rec loop`.

You can also use `let rec` in tactic mode and for creating proofs by induction.
-->
<p>Lean 对每个 <code>let rec</code>创建一个辅助声明。上例中，它为出现在 <code>replicate</code> 中的 <code>let rec loop</code> 创建了一个声明 <code>replicate.loop</code>。注意到，Lean 通过添加任意的出现在 <code>let rec</code> 声明中的局域变量作为附加参数来「关闭」声明。例如，局域变量 <code>a</code> 出现在 <code>let rec loop</code> 当中。</p>
<p>也在策略模式中可使用 <code>let rec</code> 来建立归纳证明。</p>
<pre><code class="language-lean"><span class="boring">def replicate (n : Nat) (a : α) : List α :=
</span><span class="boring"> let rec loop : Nat → List α → List α
</span><span class="boring">   | 0,   as =&gt; as
</span><span class="boring">   | n+1, as =&gt; loop n (a::as)
</span><span class="boring"> loop n []
</span>theorem length_replicate (n : Nat) (a : α) : (replicate n a).length = n := by
  let rec aux (n : Nat) (as : List α)
              : (replicate.loop a n as).length = n + as.length := by
    match n with
    | 0   =&gt; simp [replicate.loop]
    | n+1 =&gt; simp [replicate.loop, aux n, Nat.add_succ, Nat.succ_add]
  exact aux n []
</code></pre>
<!--
You can also introduce auxiliary recursive declarations using a `where` clause after your definition.
Lean converts them into a `let rec`.
-->
<p>也可以用 <code>where</code> 语句在定义后面引入辅助递归声明，Lean 自动把它们转译成 <code>let rec</code>。</p>
<pre><code class="language-lean">def replicate (n : Nat) (a : α) : List α :=
  loop n []
where
  loop : Nat → List α → List α
    | 0,   as =&gt; as
    | n+1, as =&gt; loop n (a::as)

theorem length_replicate (n : Nat) (a : α) : (replicate n a).length = n := by
  exact aux n []
where
  aux (n : Nat) (as : List α)
      : (replicate.loop a n as).length = n + as.length := by
    match n with
    | 0   =&gt; simp [replicate.loop]
    | n+1 =&gt; simp [replicate.loop, aux n, Nat.add_succ, Nat.succ_add]
</code></pre>
<!--
Exercises
---------
-->
<h2 id="练习-4"><a class="header" href="#练习-4">练习</a></h2>
<!--
1. Open a namespace ``Hidden`` to avoid naming conflicts, and use the
   equation compiler to define addition, multiplication, and
   exponentiation on the natural numbers. Then use the equation
   compiler to derive some of their basic properties.

2. Similarly, use the equation compiler to define some basic
   operations on lists (like the ``reverse`` function) and prove
   theorems about lists by induction (such as the fact that
   ``reverse (reverse xs) = xs`` for any list ``xs``).

3. Define your own function to carry out course-of-value recursion on
   the natural numbers. Similarly, see if you can figure out how to
   define ``WellFounded.fix`` on your own.

4. Following the examples in [Section Dependent Pattern Matching](#dependent-pattern-matching),
   define a function that will append two vectors.
   This is tricky; you will have to define an auxiliary function.

5. Consider the following type of arithmetic expressions. The idea is
   that ``var n`` is a variable, ``vₙ``, and ``const n`` is the
   constant whose value is ``n``.
-->
<ol>
<li>
<p>打开命名空间 <code>Hidden</code> 以避免命名冲突，并使用方程编译器定义自然数的加法、乘法和幂运算。然后用方程编译器派生出它们的一些基本属性。</p>
</li>
<li>
<p>类似地，使用方程编译器定义列表上的一些基本操作(如 <code>reverse</code> 函数)，并通过归纳法证明关于列表的定理（例如对于任何列表 <code>xs</code>，<code>reverse (reverse xs) = xs</code> ）。</p>
</li>
<li>
<p>定义您自己的函数来对自然数执行值的过程递归。同样，看看你是否能弄清楚如何定义 <code>WellFounded.fix</code>。</p>
</li>
<li>
<p>按照<a href="induction_and_recursion.html#%E4%BE%9D%E5%80%BC%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D">依值模式匹配</a>中的例子，定义一个追加（append）两个向量的函数。提示：你必须定义一个辅助函数。</p>
</li>
<li>
<p>考虑以下类型的算术表达式。这个想法是，<code>var n</code> 是一个变量 <code>vₙ</code>，<code>const n</code> 是一个常量，它的值是 <code>n</code>。</p>
</li>
</ol>
<pre><code class="language-lean">inductive Expr where
  | const : Nat → Expr
  | var : Nat → Expr
  | plus : Expr → Expr → Expr
  | times : Expr → Expr → Expr
  deriving Repr

open Expr

def sampleExpr : Expr :=
  plus (times (var 0) (const 7)) (times (const 2) (var 1))
</code></pre>
<!--
Here ``sampleExpr`` represents ``(v₀ * 7) + (2 * v₁)``.

Write a function that evaluates such an expression, evaluating each ``var n`` to ``v n``.
-->
<p>此处 <code>sampleExpr</code> 表示 <code>(v₀ * 7) + (2 * v₁)</code>。</p>
<p>写一个函数来计算这些表达式，对每个 <code>var n</code> 赋值 <code>v n</code>.</p>
<!--
```lean
# inductive Expr where
#   | const : Nat → Expr
#   | var : Nat → Expr
#   | plus : Expr → Expr → Expr
#   | times : Expr → Expr → Expr
#   deriving Repr
# open Expr
# def sampleExpr : Expr :=
#   plus (times (var 0) (const 7)) (times (const 2) (var 1))
def eval (v : Nat → Nat) : Expr → Nat
  | const n     => sorry
  | var n       => v n
  | plus e₁ e₂  => sorry
  | times e₁ e₂ => sorry

def sampleVal : Nat → Nat
  | 0 => 5
  | 1 => 6
  | _ => 0

-- Try it out. You should get 47 here.
-- #eval eval sampleVal sampleExpr
```
-->
<pre><code class="language-lean"><span class="boring">inductive Expr where
</span><span class="boring">  | const : Nat → Expr
</span><span class="boring">  | var : Nat → Expr
</span><span class="boring">  | plus : Expr → Expr → Expr
</span><span class="boring">  | times : Expr → Expr → Expr
</span><span class="boring">  deriving Repr
</span><span class="boring">open Expr
</span><span class="boring">def sampleExpr : Expr :=
</span><span class="boring">  plus (times (var 0) (const 7)) (times (const 2) (var 1))
</span>def eval (v : Nat → Nat) : Expr → Nat
  | const n     =&gt; sorry
  | var n       =&gt; v n
  | plus e₁ e₂  =&gt; sorry
  | times e₁ e₂ =&gt; sorry

def sampleVal : Nat → Nat
  | 0 =&gt; 5
  | 1 =&gt; 6
  | _ =&gt; 0

-- 如果答案是47说明你写的对。
-- #eval eval sampleVal sampleExpr
</code></pre>
<!--
Implement "constant fusion," a procedure that simplifies subterms like
``5 + 7`` to ``12``. Using the auxiliary function ``simpConst``,
define a function "fuse": to simplify a plus or a times, first
simplify the arguments recursively, and then apply ``simpConst`` to
try to simplify the result.
-->
<p>实现「常数融合」，这是一个将 <code>5 + 7</code> 等子术语化简为 <code>12</code> 的过程。使用辅助函数 <code>simpConst</code>，定义一个函数「fuse」:为了化简加号或乘号，首先递归地化简参数，然后应用 <code>simpConst</code> 尝试化简结果。</p>
<pre><code class="language-lean"><span class="boring">inductive Expr where
</span><span class="boring">  | const : Nat → Expr
</span><span class="boring">  | var : Nat → Expr
</span><span class="boring">  | plus : Expr → Expr → Expr
</span><span class="boring">  | times : Expr → Expr → Expr
</span><span class="boring">  deriving Repr
</span><span class="boring">open Expr
</span><span class="boring">def eval (v : Nat → Nat) : Expr → Nat
</span><span class="boring">  | const n     =&gt; sorry
</span><span class="boring">  | var n       =&gt; v n
</span><span class="boring">  | plus e₁ e₂  =&gt; sorry
</span><span class="boring">  | times e₁ e₂ =&gt; sorry
</span>def simpConst : Expr → Expr
  | plus (const n₁) (const n₂)  =&gt; const (n₁ + n₂)
  | times (const n₁) (const n₂) =&gt; const (n₁ * n₂)
  | e                           =&gt; e

def fuse : Expr → Expr := sorry

theorem simpConst_eq (v : Nat → Nat)
        : ∀ e : Expr, eval v (simpConst e) = eval v e :=
  sorry

theorem fuse_eq (v : Nat → Nat)
        : ∀ e : Expr, eval v (fuse e) = eval v e :=
  sorry
</code></pre>
<!--
The last two theorems show that the definitions preserve the value.
-->
<p>最后两个定理表明，定义保持值不变。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
Structures and Records
======================
-->
<h1 id="结构体和记录"><a class="header" href="#结构体和记录">结构体和记录</a></h1>
<!--
We have seen that Lean's foundational system includes inductive
types. We have, moreover, noted that it is a remarkable fact that it
is possible to construct a substantial edifice of mathematics based on
nothing more than the type universes, dependent arrow types, and inductive types;
everything else follows from those. The Lean standard library contains
many instances of inductive types (e.g., ``Nat``, ``Prod``, ``List``),
and even the logical connectives are defined using inductive types.

Recall that a non-recursive inductive type that contains only one
constructor is called a *structure* or *record*. The product type is a
structure, as is the dependent product (Sigma) type.
In general, whenever we define a structure ``S``, we usually
define *projection* functions that allow us to "destruct" each
instance of ``S`` and retrieve the values that are stored in its
fields. The functions ``prod.fst`` and ``prod.snd``, which return the
first and second elements of a pair, are examples of such projections.

When writing programs or formalizing mathematics, it is not uncommon
to define structures containing many fields. The ``structure``
command, available in Lean, provides infrastructure to support this
process. When we define a structure using this command, Lean
automatically generates all the projection functions. The
``structure`` command also allows us to define new structures based on
previously defined ones. Moreover, Lean provides convenient notation
for defining instances of a given structure.
-->
<p>我们已经看到Lean 的基本系统包括归纳类型。此外，显然仅基于类型宇宙、依赖箭头类型和归纳类型，就有可能构建一个坚实的数学大厦；其他的一切都是由此而来。Lean 标准库包含许多归纳类型的实例(例如，<code>Nat</code>，<code>Prod</code>，<code>List</code>)，甚至逻辑连接词也是使用归纳类型定义的。</p>
<p>回忆一下，只包含一个构造子的非递归归纳类型被称为 <strong>结构体（structure）</strong> 或 <strong>记录（record）</strong> 。乘积类型是一种结构体，依值乘积(Sigma)类型也是如此。一般来说，每当我们定义一个结构体 <code>S</code> 时，我们通常定义<em>投影</em>（projection）函数来「析构」（destruct）<code>S</code> 的每个实例并检索存储在其字段中的值。<code>prod.pr1</code> 和 <code>prod.pr2</code>，分别返回乘积对中的第一个和第二个元素的函数，就是这种投影的例子。</p>
<p>在编写程序或形式化数学时，定义包含许多字段的结构体是很常见的。Lean 中可用 <code>structure</code> 命令实现此过程。当我们使用这个命令定义一个结构体时，Lean 会自动生成所有的投影函数。<code>structure</code> 命令还允许我们根据以前定义的结构体定义新的结构体。此外，Lean 为定义给定结构体的实例提供了方便的符号。</p>
<!--
Declaring Structures
--------------------
-->
<h2 id="声明结构体"><a class="header" href="#声明结构体">声明结构体</a></h2>
<!--
The structure command is essentially a "front end" for defining
inductive data types. Every ``structure`` declaration introduces a
namespace with the same name. The general form is as follows:
-->
<p>结构体命令本质上是定义归纳数据类型的「前端」。每个 <code>structure</code> 声明都会引入一个同名的命名空间。一般形式如下:</p>
<pre><code>    structure &lt;name&gt; &lt;parameters&gt; &lt;parent-structures&gt; where
      &lt;constructor&gt; :: &lt;fields&gt;
</code></pre>
<!--
Most parts are optional. Here is an example:
-->
<p>大多数部分不是必要的。例子：</p>
<pre><code class="language-lean">structure Point (α : Type u) where
  mk :: (x : α) (y : α)
</code></pre>
<!--
Values of type ``Point`` are created using ``Point.mk a b``, and the
fields of a point ``p`` are accessed using ``Point.x p`` and
``Point.y p`` (but `p.x` and `p.y` also work, see below).
The structure command also generates useful recursors and
theorems. Here are some of the constructions generated for the
declaration above.
-->
<p>类型 <code>Point</code> 的值是使用 <code>Point.mk a b</code> 创建的，并且点 <code>p</code> 的字段可以使用 <code>Point.x p</code> 和 <code>Point.y p</code>。结构体命令还生成有用的递归器和定理。下面是为上述声明生成的一些结构体方法。</p>
<!--
```lean
# structure Point (α : Type u) where
#  mk :: (x : α) (y : α)
#check Point       -- a Type
#check @Point.rec  -- the eliminator
#check @Point.mk   -- the constructor
#check @Point.x    -- a projection
#check @Point.y    -- a projection
```
-->
<pre><code class="language-lean"><span class="boring">structure Point (α : Type u) where
</span><span class="boring"> mk :: (x : α) (y : α)
</span>#check Point       -- 类型
#check @Point.rec  -- 消去器（eliminator）
#check @Point.mk   -- 构造子
#check @Point.x    -- 投影
#check @Point.y    -- 投影
</code></pre>
<!--
If the constructor name is not provided, then a constructor is named
``mk`` by default.  You can also avoid the parentheses around field
names if you add a line break between each field.
-->
<!--
If the constructor name is not provided, then a constructor is named
``mk`` by default.  You can also avoid the parentheses around field
names if you add a line break between each field.
-->
<p>如果没有提供构造子名称，则默认的构造函数名为 <code>mk</code>。如果在每个字段之间添加换行符，也可以避免字段名周围的括号。</p>
<pre><code class="language-lean">structure Point (α : Type u) where
  x : α
  y : α
</code></pre>
<!--
Here are some simple theorems and expressions that use the generated
constructions. As usual, you can avoid the prefix ``Point`` by using
the command ``open Point``.
-->
<p>下面是一些使用生成的结构的简单定理和表达式。像往常一样，您可以通过使用命令 <code>open Point</code> 来避免前缀 <code>Point</code>。</p>
<pre><code class="language-lean"><span class="boring">structure Point (α : Type u) where
</span><span class="boring"> x : α
</span><span class="boring"> y : α
</span>#eval Point.x (Point.mk 10 20)
#eval Point.y (Point.mk 10 20)

open Point

example (a b : α) : x (mk a b) = a :=
  rfl

example (a b : α) : y (mk a b) = b :=
  rfl
</code></pre>
<!--
Given ``p : Point Nat``, the dot notation ``p.x`` is shorthand for
``Point.x p``. This provides a convenient way of accessing the fields
of a structure.
-->
<p>给定 <code>p : Point Nat</code>，符号 <code>p.x</code> 是 <code>Point.x p</code> 的缩写。这提供了一种方便的方式来访问结构体的字段。</p>
<pre><code class="language-lean"><span class="boring">structure Point (α : Type u) where
</span><span class="boring"> x : α
</span><span class="boring"> y : α
</span>def p := Point.mk 10 20

#check p.x  -- Nat
#eval p.x   -- 10
#eval p.y   -- 20
</code></pre>
<!--
The dot notation is convenient not just for accessing the projections
of a record, but also for applying functions defined in a namespace
with the same name. Recall from the [Conjunction section](./propositions_and_proofs.md#conjunction) if ``p``
has type ``Point``, the expression ``p.foo`` is interpreted as
``Point.foo p``, assuming that the first non-implicit argument to
``foo`` has type ``Point``. The expression ``p.add q`` is therefore
shorthand for ``Point.add p q`` in the example below.
-->
<p>点记号不仅方便于访问记录的投影，而且也方便于应用同名命名空间中定义的函数。回想一下<a href="./propositions_and_proofs.html#_conjunction">合取</a>一节，如果 <code>p</code> 具有 <code>Point</code> 类型，那么表达式 <code>p.foo</code> 被解释为 <code>Point.foo p</code>，假设 <code>foo</code> 的第一个非隐式参数具有类型 <code>Point</code>，表达式 <code>p.add q</code> 因此是 <code>Point.add p q</code> 的缩写。可见下面的例子。</p>
<pre><code class="language-lean">structure Point (α : Type u) where
  x : α
  y : α
  deriving Repr

def Point.add (p q : Point Nat) :=
  mk (p.x + q.x) (p.y + q.y)

def p : Point Nat := Point.mk 1 2
def q : Point Nat := Point.mk 3 4

#eval p.add q  -- {x := 4, y := 6}
</code></pre>
<!--
In the next chapter, you will learn how to define a function like
``add`` so that it works generically for elements of ``Point α``
rather than just ``Point Nat``, assuming ``α`` has an associated
addition operation.

More generally, given an expression ``p.foo x y z`` where `p : Point`,
Lean will insert ``p`` at the first argument to ``Point.foo`` of type
``Point``. For example, with the definition of scalar multiplication
below, ``p.smul 3`` is interpreted as ``Point.smul 3 p``.
-->
<p>在下一章中，您将学习如何定义一个像 <code>add</code> 这样的函数，这样它就可以通用地为 <code>Point α</code> 的元素工作，而不仅仅是 <code>Point Nat</code>，只要假设 <code>α</code> 有一个关联的加法操作。</p>
<p>更一般地，给定一个表达式 <code>p.foo x y z</code> 其中<code>p : Point</code>，Lean 会把 <code>p</code> 以 <code>Point</code> 为类型插入到 <code>Point.foo</code> 的第一个参数。例如，下面是标量乘法的定义，<code>p.smul 3</code> 被解释为 <code>Point.smul 3 p</code>。</p>
<pre><code class="language-lean"><span class="boring">structure Point (α : Type u) where
</span><span class="boring"> x : α
</span><span class="boring"> y : α
</span><span class="boring"> deriving Repr
</span>def Point.smul (n : Nat) (p : Point Nat) :=
  Point.mk (n * p.x) (n * p.y)

def p : Point Nat := Point.mk 1 2

#eval p.smul 3  -- {x := 3, y := 6}
</code></pre>
<!--
It is common to use a similar trick with the ``List.map`` function,
which takes a list as its second non-implicit argument:
-->
<p>对 <code>List.map</code> 函数使用类似的技巧很常用。它接受一个列表作为它的第二个非隐式参数:</p>
<pre><code class="language-lean">#check @List.map

def xs : List Nat := [1, 2, 3]
def f : Nat → Nat := fun x =&gt; x * x

#eval xs.map f  -- [1, 4, 9]
</code></pre>
<!--
Here ``xs.map f`` is interpreted as ``List.map f xs``.
-->
<p>此处 <code>xs.map f</code> 被解释为 <code>List.map f xs</code>。</p>
<!--
Objects
-------
-->
<h2 id="对象"><a class="header" href="#对象">对象</a></h2>
<!--
We have been using constructors to create elements of a structure
type. For structures containing many fields, this is often
inconvenient, because we have to remember the order in which the
fields were defined. Lean therefore provides the following alternative
notations for defining elements of a structure type.
-->
<p>我们一直在使用构造子创建结构体类型的元素。对于包含许多字段的结构，这通常是不方便的，因为我们必须记住字段定义的顺序。因此，Lean 为定义结构体类型的元素提供了以下替代符号。</p>
<pre><code>    { (&lt;field-name&gt; := &lt;expr&gt;)* : structure-type }
    or
    { (&lt;field-name&gt; := &lt;expr&gt;)* }
</code></pre>
<!--
The suffix ``: structure-type`` can be omitted whenever the name of
the structure can be inferred from the expected type. For example, we
use this notation to define "points." The order that the fields are
specified does not matter, so all the expressions below define the
same point.
-->
<p>只要可以从期望的类型推断出结构体的名称，后缀 <code>: structure-type</code> 就可以省略。例如，我们使用这种表示法来定义「Point」。字段的指定顺序无关紧要，因此下面的所有表达式定义相同的Point。</p>
<pre><code class="language-lean">structure Point (α : Type u) where
  x : α
  y : α

#check { x := 10, y := 20 : Point Nat }  -- Point ℕ
#check { y := 20, x := 10 : Point _ }
#check ({ x := 10, y := 20 } : Point Nat)

example : Point Nat :=
  { y := 20, x := 10 }
</code></pre>
<!--
If the value of a field is not specified, Lean tries to infer it. If
the unspecified fields cannot be inferred, Lean flags an error
indicating the corresponding placeholder could not be synthesized.
-->
<p>如果一个字段的值没有指定，Lean 会尝试推断它。如果不能推断出未指定的字段，Lean 会标记一个错误，表明相应的占位符无法合成。</p>
<pre><code class="language-lean">structure MyStruct where
    {α : Type u}
    {β : Type v}
    a : α
    b : β

#check { a := 10, b := true : MyStruct }
</code></pre>
<!--
*Record update* is another common operation which amounts to creating
a new record object by modifying the value of one or more fields in an
old one. Lean allows you to specify that unassigned fields in the
specification of a record should be taken from a previously defined
structure object ``s`` by adding the annotation ``s with`` before the field
assignments. If more than one record object is provided, then they are
visited in order until Lean finds one that contains the unspecified
field. Lean raises an error if any of the field names remain
unspecified after all the objects are visited.
-->
<p><strong>记录更新（Record update）</strong> 是另一个常见的操作，相当于通过修改旧记录中的一个或多个字段的值来创建一个新的记录对象。通过在字段赋值之前添加注释 <code>s with</code>，Lean 允许您指定记录规范中未赋值的字段，该字段应从之前定义的结构对象 <code>s</code> 中获取。如果提供了多个记录对象，那么将按顺序访问它们，直到Lean 找到一个包含未指定字段的记录对象。如果在访问了所有对象之后仍未指定任何字段名，Lean 将引发错误。</p>
<pre><code class="language-lean">structure Point (α : Type u) where
  x : α
  y : α
  deriving Repr

def p : Point Nat :=
  { x := 1, y := 2 }

#eval { p with y := 3 }  -- { x := 1, y := 3 }
#eval { p with x := 4 }  -- { x := 4, y := 2 }

structure Point3 (α : Type u) where
  x : α
  y : α
  z : α

def q : Point3 Nat :=
  { x := 5, y := 5, z := 5 }

def r : Point3 Nat :=
  { p, q with x := 6 }

example : r.x = 6 := rfl
example : r.y = 2 := rfl
example : r.z = 5 := rfl
</code></pre>
<!--
Inheritance
-----------
-->
<h2 id="继承"><a class="header" href="#继承">继承</a></h2>
<!--
We can *extend* existing structures by adding new fields. This feature
allows us to simulate a form of *inheritance*.
-->
<p>我们可以通过添加新的字段来 <strong>扩展</strong> 现有的结构体。这个特性允许我们模拟一种形式的 <strong>继承</strong> 。</p>
<pre><code class="language-lean">structure Point (α : Type u) where
  x : α
  y : α

inductive Color where
  | red | green | blue

structure ColorPoint (α : Type u) extends Point α where
  c : Color
</code></pre>
<!--
In the next example, we define a structure using multiple inheritance,
and then define an object using objects of the parent structures.
-->
<p>在下一个例子中，我们使用多重继承定义一个结构体，然后使用父结构的对象定义一个对象。</p>
<pre><code class="language-lean">structure Point (α : Type u) where
  x : α
  y : α
  z : α

structure RGBValue where
  red : Nat
  green : Nat
  blue : Nat

structure RedGreenPoint (α : Type u) extends Point α, RGBValue where
  no_blue : blue = 0

def p : Point Nat :=
  { x := 10, y := 10, z := 20 }

def rgp : RedGreenPoint Nat :=
  { p with red := 200, green := 40, blue := 0, no_blue := rfl }

example : rgp.x   = 10 := rfl
example : rgp.red = 200 := rfl
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# Type Classes
-->
<h1 id="类型类"><a class="header" href="#类型类">类型类</a></h1>
<!--
Type classes were introduced as a principled way of enabling
ad-hoc polymorphism in functional programming languages. We first observe that it
would be easy to implement an ad-hoc polymorphic function (such as addition) if the
function simply took the type-specific implementation of addition as an argument
and then called that implementation on the remaining arguments. For example,
suppose we declare a structure in Lean to hold implementations of addition.
-->
<p>将  <strong>类型类（Type Class）</strong>  作为一种原则性方法引入，
是为了在函数式编程语言中支持  <strong>特设多态（Ad-hoc Polymorphism）</strong> 。
我们首先观察到，如果函数简单地接受特定类型的实现作为参数，
然后在其余参数上调用该实现，则很容易实现特设多态函数（如加法）。
例如，假设我们在 Lean 中声明一个结构体来保存加法的实现：</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span>structure Add (a : Type) where
  add : a → a → a

#check @Add.add
-- Add.add : {a : Type} → Add a → a → a → a
<span class="boring">end Ex
</span></code></pre>
<!--
In the above Lean code, the field `add` has type
`Add.add : {a : Type} → Add a → a → a → a`
where the curly braces around the type `a` mean that it is an implicit argument.
We could implement `double` by:
-->
<p>在上面 Lean 代码中，字段 <code>add</code> 的类型为 <code>Add.add : {a : Type} → Add a → a → a → a</code>
其中类型 <code>a</code> 周围的大括号表示它是一个隐式参数。我们可以通过以下方式实现 <code>double</code>：</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span><span class="boring">structure Add (a : Type) where
</span><span class="boring"> add : a → a → a
</span>def double (s : Add a) (x : a) : a :=
  s.add x x

#eval double { add := Nat.add } 10
-- 20

#eval double { add := Nat.mul } 10
-- 100

#eval double { add := Int.add } 10
-- 20
<span class="boring">end Ex
</span></code></pre>
<!--
Note that you can double a natural number `n` by `double { add := Nat.add } n`.
Of course, it would be highly cumbersome for users to manually pass the
implementations around in this way.
Indeed, it would defeat most of the potential benefits of ad-hoc
polymorphism.
-->
<p>注意，你可以用 <code>double { add := Nat.add } n</code> 使一个自然数 <code>n</code> 翻倍。
当然，以这种方式让用户手动四处传递实现会非常繁琐。
实际上，这会消除掉特设多态的大部分潜在好处。</p>
<!--
The main idea behind type classes is to make arguments such as `Add a` implicit,
and to use a database of user-defined instances to synthesize the desired instances
automatically through a process known as typeclass resolution. In Lean, by changing
`structure` to `class` in the example above, the type of `Add.add` becomes:
-->
<p>类型类的主要思想是使诸如 <code>Add a</code> 之类的参数变为隐含的，
并使用用户定义实例的数据库通过称为类型类解析的过程自动合成所需的实例。
在 Lean 中，通过在以上示例中将 <code>structure</code> 更改为 <code>class</code>，<code>Add.add</code> 的类型会变为：</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span>class Add (a : Type) where
  add : a → a → a

#check @Add.add
-- Add.add : {a : Type} → [self : Add a] → a → a → a
<span class="boring">end Ex
</span></code></pre>
<!--
where the square brackets indicate that the argument of type `Add a` is *instance implicit*,
i.e. that it should be synthesized using typeclass resolution. This version of
`add` is the Lean analogue of the Haskell term `add :: Add a => a -> a -> a`.
Similarly, we can register instances by:
-->
<p>其中方括号表示类型为 <code>Add a</code> 的参数是  <strong>实例隐式的</strong> ，
即，它应该使用类型类解析合成。这个版本的 <code>add</code> 是 Haskell 项
<code>add :: Add a =&gt; a -&gt; a -&gt; a</code> 的 Lean 类比。
同样，我们可以通过以下方式注册实例：</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span><span class="boring">class Add (a : Type) where
</span><span class="boring"> add : a → a → a
</span>instance : Add Nat where
  add := Nat.add

instance : Add Int where
  add := Int.add

instance : Add Float where
  add := Float.add
<span class="boring">end Ex
</span></code></pre>
<!--
Then for `n : Nat` and `m : Nat`, the term `Add.add n m` triggers typeclass resolution with
the goal of `Add Nat`, and typeclass resolution will synthesize the instance for `Nat` above.
We can now reimplement `double` using an instance implicit by:
-->
<p>接着对于 <code>n : Nat</code> 和 <code>m : Nat</code>，项 <code>Add.add n m</code> 触发了类型类解析，
目标为 <code>Add Nat</code>，且类型类解析将综合上面 <code>Nat</code> 的实例。
现在，我们可以通过隐式的实例重新实现 <code>double</code> 了：</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span><span class="boring">class Add (a : Type) where
</span><span class="boring">  add : a → a → a
</span><span class="boring">instance : Add Nat where
</span><span class="boring"> add := Nat.add
</span><span class="boring">instance : Add Int where
</span><span class="boring"> add := Int.add
</span><span class="boring">instance : Add Float where
</span><span class="boring"> add := Float.add
</span>def double [Add a] (x : a) : a :=
  Add.add x x

#check @double
-- @double : {a : Type} → [inst : Add a] → a → a

#eval double 10
-- 20

#eval double (10 : Int)
-- 100

#eval double (7 : Float)
-- 14.000000

#eval double (239.0 + 2)
-- 482.000000

<span class="boring">end Ex
</span></code></pre>
<!--
In general, instances may depend on other instances in complicated ways. For example,
you can declare an (anonymous) instance stating that if `a` has addition, then `Array a`
has addition:
-->
<p>一般情况下，实例可能以复杂的方式依赖于其他实例。例如，你可以声明一个（匿名）实例，
说明如果 <code>a</code> 存在加法，那么 <code>Array a</code> 也存在加法：</p>
<pre><code class="language-lean">instance [Add a] : Add (Array a) where
  add x y := Array.zipWith x y (· + ·)

#eval Add.add #[1, 2] #[3, 4]
-- #[4, 6]

#eval #[1, 2] + #[3, 4]
-- #[4, 6]
</code></pre>
<!--
Note that `(· + ·)` is notation for `fun x y => x + y` in Lean.
-->
<p>请注意，<code>(· + ·)</code> 是 Lean 中 <code>fun x y =&gt; x + y</code> 的记法。</p>
<!--
The example above demonstrates how type classes are used to overload notation.
Now, we explore another application. We often need an arbitrary element of a given type.
Recall that types may not have any elements in Lean.
It often happens that we would like a definition to return an arbitrary element in a "corner case."
For example, we may like the expression ``head xs`` to be of type ``a`` when ``xs`` is of type ``List a``.
Similarly, many theorems hold under the additional assumption that a type is not empty.
For example, if ``a`` is a type, ``exists x : a, x = x`` is true only if ``a`` is not empty.
The standard library defines a type class ``Inhabited`` to enable type class inference to infer a
"default" element of an inhabited type.
Let us start with the first step of the program above, declaring an appropriate class:
-->
<p>上述示例演示了类型类如何用于重载符号。现在，我们探索另一个应用程序。
我们经常需要给定类型的任意元素。回想一下类型在 Lean 中可能没有任何元素。
我们经常希望在一个「边界情况」下定义返回一个任意元素。
例如，我们可能希望当 <code>xs</code> 为 <code>List a</code> 类型时 <code>head xs</code> 表达式的类型为 <code>a</code>。
类似地，许多定理在类型不为空的附加假设下成立。例如，如果 <code>a</code> 是一个类型，
则 <code>exists x : a, x = x</code> 仅在 <code>a</code> 不为空时为真。标准库定义了一个类型类
<code>Inhabited</code>，它能够让类型类推理来推断 <strong>可居（Inhabited）</strong> 类型类的「默认」元素。
让我们从上述程序的第一步开始，声明一个适当的类：</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span>class Inhabited (a : Type u) where
  default : a

#check @Inhabited.default
-- Inhabited.default : {a : Type u} → [self : Inhabited a] → a
<span class="boring">end Ex
</span></code></pre>
<!--
Note `Inhabited.default` doesn't have any explicit arguments.
-->
<p>注意 <code>Inhabited.default</code> 没有任何显式参数。</p>
<!--
An element of the class ``Inhabited a`` is simply an expression of the form ``Inhabited.mk x``, for some element ``x : a``.
The projection ``Inhabited.default`` will allow us to "extract" such an element of ``a`` from an element of ``Inhabited a``.
Now we populate the class with some instances:
-->
<p>类 <code>Inhabited a</code> 的某个元素只是形式为 <code>Inhabited.mk x</code> 的表达式，
其中 <code>x : a</code> 为某个元素。投影 <code>Inhabited.default</code> 可让我们从 <code>Inhabited a</code>
的某个元素中「提取」出 <code>a</code> 的某个元素。现在我们用一些实例填充该类：</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span><span class="boring">class Inhabited (a : Type _) where
</span><span class="boring"> default : a
</span>instance : Inhabited Bool where
  default := true

instance : Inhabited Nat where
  default := 0

instance : Inhabited Unit where
  default := ()

instance : Inhabited Prop where
  default := True

#eval (Inhabited.default : Nat)
-- 0

#eval (Inhabited.default : Bool)
-- true
<span class="boring">end Ex
</span></code></pre>
<!--
You can use the command `export` to create the alias `default` for `Inhabited.default`
-->
<p>你可以用 <code>export</code> 命令来为 <code>Inhabited.default</code> 创建别名 <code>default</code></p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span><span class="boring">class Inhabited (a : Type _) where
</span><span class="boring"> default : a
</span><span class="boring">instance : Inhabited Bool where
</span><span class="boring"> default := true
</span><span class="boring">instance : Inhabited Nat where
</span><span class="boring"> default := 0
</span><span class="boring">instance : Inhabited Unit where
</span><span class="boring"> default := ()
</span><span class="boring">instance : Inhabited Prop where
</span><span class="boring"> default := True
</span>export Inhabited (default)

#eval (default : Nat)
-- 0

#eval (default : Bool)
-- true
<span class="boring">end Ex
</span></code></pre>
<!--
## Chaining Instances
-->
<h2 id="链接实例"><a class="header" href="#链接实例">链接实例</a></h2>
<!--
If that were the extent of type class inference, it would not be all that impressive;
it would be simply a mechanism of storing a list of instances for the elaborator to find in a lookup table.
What makes type class inference powerful is that one can *chain* instances. That is,
an instance declaration can in turn depend on an implicit instance of a type class.
This causes class inference to chain through instances recursively, backtracking when necessary, in a Prolog-like search.
-->
<p>以类型类推断的层面来看，它并不那么令人印象深刻；
它不过是一种为精细器存储实例列表的机制，用于在查询表中查找。
类型类推断变得强大的原因在于，它能够「链接（Chain）」实例。也就是说，
实例声明本身可以依赖类型类的隐式实例。
这导致类推断递归地通过实例进行链接，并在必要时回溯，就像 Prolog 中的搜索一样。</p>
<!--
For example, the following definition shows that if two types ``a`` and ``b`` are inhabited, then so is their product:
-->
<p>--&gt;</p>
<p>例如，以下定义展示了若两个类型 <code>a</code> 和 <code>b</code> 包含元素，则二者的积也包含元素：</p>
<pre><code class="language-lean">instance [Inhabited a] [Inhabited b] : Inhabited (a × b) where
  default := (default, default)
</code></pre>
<!--
With this added to the earlier instance declarations, type class instance can infer, for example, a default element of ``Nat × Bool``:
-->
<p>将它添加到先前的实例声明后，类型类实例就能推导了，例如 <code>Nat × Bool</code> 的默认元素为：</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span><span class="boring">class Inhabited (a : Type u) where
</span><span class="boring"> default : a
</span><span class="boring">instance : Inhabited Bool where
</span><span class="boring"> default := true
</span><span class="boring">instance : Inhabited Nat where
</span><span class="boring"> default := 0
</span><span class="boring">opaque default [Inhabited a] : a :=
</span><span class="boring"> Inhabited.default
</span>instance [Inhabited a] [Inhabited b] : Inhabited (a × b) where
  default := (default, default)

#eval (default : Nat × Bool)
-- (0, true)
<span class="boring">end Ex
</span></code></pre>
<!--
Similarly, we can inhabit type function with suitable constant functions:
-->
<p>与此类似，我们可以使用合适的常量函数使其居留到类型函数中：</p>
<pre><code class="language-lean">instance [Inhabited b] : Inhabited (a → b) where
  default := fun _ =&gt; default
</code></pre>
<!--
As an exercise, try defining default instances for other types, such as `List` and `Sum` types.
-->
<p>作为练习，请尝试为其他类型定义默认实例，例如 <code>List</code> 和 <code>Sum</code> 类型。</p>
<!--
The Lean standard library contains the definition `inferInstance`. It has type `{α : Sort u} → [i : α] → α`,
and is useful for triggering the type class resolution procedure when the expected type is an instance.
-->
<p>Lean 标准库包含了定义 <code>inferInstance</code>，它的类型为 <code>{α : Sort u} → [i : α] → α</code>，
它在期望的类型是一个实例时触发类型类解析过程十分有用。</p>
<pre><code class="language-lean">#check (inferInstance : Inhabited Nat) -- Inhabited Nat

def foo : Inhabited (Nat × Nat) :=
  inferInstance

theorem ex : foo.default = (default, default) :=
  rfl
</code></pre>
<!--
You can use the command `#print` to inspect how simple `inferInstance` is.
-->
<!--
You can use the command `#print` to inspect how simple `inferInstance` is.
-->
<p>你可以使用命令 <code>#print</code> 来检查 <code>inferInstance</code> 有多简单。</p>
<pre><code class="language-lean">#print inferInstance
</code></pre>
<!--
## ToString
-->
<h2 id="tostring-方法"><a class="header" href="#tostring-方法">ToString 方法</a></h2>
<!--
The polymorphic method `toString` has type `{α : Type u} → [ToString α] → α → String`. You implement the instance
for your own types and use chaining to convert complex values into strings. Lean comes with `ToString` instances
for most builtin types.
-->
<p>多态方法 <code>toString</code> 类型为 <code>{α : Type u} → [ToString α] → α → String</code>。
你可以为自己的类型实现实例并使用链接将复杂的值转换为字符串。
Lean 为大多数内置类型都提供了 <code>ToString</code> 实例。</p>
<pre><code class="language-lean">structure Person where
  name : String
  age  : Nat

instance : ToString Person where
  toString p := p.name ++ &quot;@&quot; ++ toString p.age

#eval toString { name := &quot;Leo&quot;, age := 542 : Person }
#eval toString ({ name := &quot;Daniel&quot;, age := 18 : Person }, &quot;hello&quot;)
</code></pre>
<!--
## Numerals
-->
<h2 id="数值"><a class="header" href="#数值">数值</a></h2>
<!--
Numerals are polymorphic in Lean. You can use a numeral (e.g., `2`) to denote an element of any type that implements
the type class `OfNat`.
-->
<p>数值在 Lean 中是多态的。你可以用一个数值（例如 <code>2</code>）来表示任何实现了类型类
<code>OfNat</code> 的类型中的一个元素。</p>
<pre><code class="language-lean">structure Rational where
  num : Int
  den : Nat
  inv : den ≠ 0

instance : OfNat Rational n where
  ofNat := { num := n, den := 1, inv := by decide }

instance : ToString Rational where
  toString r := s!&quot;{r.num}/{r.den}&quot;

#eval (2 : Rational) -- 2/1

#check (2 : Rational) -- Rational
#check (2 : Nat)      -- Nat
</code></pre>
<!--
Lean elaborates the terms `(2 : Nat)` and `(2 : Rational)` as
`OfNat.ofNat Nat 2 (instOfNatNat 2)` and
`OfNat.ofNat Rational 2 (instOfNatRational 2)` respectively.
We say the numerals `2` occurring in the elaborated terms are *raw* natural numbers.
You can input the raw natural number `2` using the macro `nat_lit 2`.
-->
<!--
Lean elaborates the terms `(2 : Nat)` and `(2 : Rational)` as
`OfNat.ofNat Nat 2 (instOfNatNat 2)` and
`OfNat.ofNat Rational 2 (instOfNatRational 2)` respectively.
We say the numerals `2` occurring in the elaborated terms are *raw* natural numbers.
You can input the raw natural number `2` using the macro `nat_lit 2`.
-->
<p>Lean 会将项 <code>(2 : Nat)</code> 和 <code>(2 : Rational)</code> 分别繁饰（Elaborate）为：
<code>OfNat.ofNat Nat 2 (instOfNatNat 2)</code> 和
<code>OfNat.ofNat Rational 2 (instOfNatRational 2)</code>。
我们将繁饰的项中出现的数字 <code>2</code> 称为  <strong>原始</strong>  自然数。
你可以使用宏 <code>nat_lit 2</code> 来输入原始自然数 <code>2</code>。</p>
<pre><code class="language-lean">#check nat_lit 2  -- Nat
</code></pre>
<!--
Raw natural numbers are *not* polymorphic.
-->
<p>原始自然数  <strong>不是</strong>  多态的。</p>
<!--
The `OfNat` instance is parametric on the numeral. So, you can define instances for particular numerals.
The second argument is often a variable as in the example above, or a *raw* natural number.
-->
<p><code>OfNat</code> 实例对数值进行了参数化，因此你可以定义特定数字的实例。
第二个参数通常是变量，如上例所示，或者是一个  <strong>原始</strong>  自然数。</p>
<pre><code class="language-lean">class Monoid (α : Type u) where
  unit : α
  op   : α → α → α

instance [s : Monoid α] : OfNat α (nat_lit 1) where
  ofNat := s.unit

def getUnit [Monoid α] : α :=
  1
</code></pre>
<!--
## Output Parameters
-->
<h2 id="输出参数"><a class="header" href="#输出参数">输出参数</a></h2>
<!--
By default, Lean only tries to synthesize an instance `Inhabited T` when the term `T` is known and does not
contain missing parts. The following command produces the error
"typeclass instance problem is stuck, it is often due to metavariables `?m.7`" because the type has a missing part (i.e., the `_`).
-->
<p>默认情况下，Lean 仅当项 <code>T</code> 已知时且不包含缺失部分时，会尝试合成实例 <code>Inhabited T</code>。
以下命令会产生错「typeclass instance problem is stuck, it is often due to metavariables <code>?m.7</code>
（类型类实例问题卡住了，通常是由于元变量 <code>?m.7</code> 引起的）」因为该类型有缺失的部分（即 <code>_</code>）。</p>
<pre><code class="language-lean">#check_failure (inferInstance : Inhabited (Nat × _))
</code></pre>
<!--
You can view the parameter of the type class `Inhabited` as an *input* value for the type class synthesizer.
When a type class has multiple parameters, you can mark some of them as output parameters.
Lean will start type class synthesizer even when these parameters have missing parts.
In the following example, we use output parameters to define a *heterogeneous* polymorphic
multiplication.
-->
<p>你可以将类型类 <code>Inhabited</code> 的参数视为类型类合成器的  <strong>输入</strong>  值。
当类型类有多个参数时，可以将其中一些标记为输出参数。
即使这些参数有缺失部分，Lean 也会开始类型类合成。
在下面的示例中，我们使用输出参数定义一个  <strong>异质（Heterogeneous）</strong>  的多态乘法。</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span>class HMul (α : Type u) (β : Type v) (γ : outParam (Type w)) where
  hMul : α → β → γ

export HMul (hMul)

instance : HMul Nat Nat Nat where
  hMul := Nat.mul

instance : HMul Nat (Array Nat) (Array Nat) where
  hMul a bs := bs.map (fun b =&gt; hMul a b)

#eval hMul 4 3           -- 12
#eval hMul 4 #[2, 3, 4]  -- #[8, 12, 16]
<span class="boring">end Ex
</span></code></pre>
<!--
The parameters `α` and `β` are considered input parameters and `γ` an output one.
Given an application `hMul a b`, after the types of `a` and `b` are known, the type class
synthesizer is invoked, and the resulting type is obtained from the output parameter `γ`.
In the example above, we defined two instances. The first one is the homogeneous
multiplication for natural numbers. The second is the scalar multiplication for arrays.
Note that you chain instances and generalize the second instance.
-->
<p>参数 <code>α</code> 和 <code>β</code> 会被视为输入参数，<code>γ</code> 被视为输出参数。
如果给定一个应用 <code>hMul a b</code>，那么在知道 <code>a</code> 和 <code>b</code> 的类型后，
将调用类型类合成器，并且可以从输出参数 <code>γ</code> 中获得最终的类型。
在上文中的示例中，我们定义了两个实例。第一个实例是针对自然数的同质乘法。
第二个实例是针对数组的标量乘法。请注意，你可以链接实例，并推广第二个实例。</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span>class HMul (α : Type u) (β : Type v) (γ : outParam (Type w)) where
  hMul : α → β → γ

export HMul (hMul)

instance : HMul Nat Nat Nat where
  hMul := Nat.mul

instance : HMul Int Int Int where
  hMul := Int.mul

instance [HMul α β γ] : HMul α (Array β) (Array γ) where
  hMul a bs := bs.map (fun b =&gt; hMul a b)

#eval hMul 4 3                    -- 12
#eval hMul 4 #[2, 3, 4]           -- #[8, 12, 16]
#eval hMul (-2) #[3, -1, 4]       -- #[-6, 2, -8]
#eval hMul 2 #[#[2, 3], #[0, 4]]  -- #[#[4, 6], #[0, 8]]
<span class="boring">end Ex
</span></code></pre>
<!--
You can use our new scalar array multiplication instance on arrays of type `Array β`
with a scalar of type `α` whenever you have an instance `HMul α β γ`.
In the last `#eval`, note that the instance was used twice on an array of arrays.
-->
<p>当你拥有 <code>HMul α β γ</code> 的实例时，可以在类型为 <code>Array β</code> 的数组上将其使用标量类型
<code>α</code> 的新标量数组乘法实例。在最后的 <code>#eval</code> 中，请注意该实例曾在数组数组中使用了两次。</p>
<!--
## Default Instances
-->
<h2 id="default-instances"><a class="header" href="#default-instances">Default Instances</a></h2>
<!--
In the class `HMul`, the parameters `α` and `β` are treated as input values.
Thus, type class synthesis only starts after these two types are known. This may often
be too restrictive.
-->
<p>在类 <code>HMul</code> 中，参数 <code>α</code> 和 <code>β</code> 被当做输入值。
因此，类型类合成仅在已知这两种类型时才开始。这通常可能过于严格。</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span>class HMul (α : Type u) (β : Type v) (γ : outParam (Type w)) where
  hMul : α → β → γ

export HMul (hMul)

instance : HMul Int Int Int where
  hMul := Int.mul

def xs : List Int := [1, 2, 3]

-- Error &quot;typeclass instance problem is stuck, it is often due to metavariables HMul ?m.89 ?m.90 ?m.91&quot;
#check_failure fun y =&gt; xs.map (fun x =&gt; hMul x y)
<span class="boring">end Ex
</span></code></pre>
<!--
The instance `HMul` is not synthesized by Lean because the type of `y` has not been provided.
However, it is natural to assume that the type of `y` and `x` should be the same in
this kind of situation. We can achieve exactly that using *default instances*.
-->
<p>实例 <code>HMul</code> 没有被 Lean 合成，因为没有提供 <code>y</code> 的类型。
然而，在这种情况下，自然应该认为 <code>y</code> 和 <code>x</code> 的类型应该相同。
我们可以使用  <strong>默认实例</strong>  来实现这一点。</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span>class HMul (α : Type u) (β : Type v) (γ : outParam (Type w)) where
  hMul : α → β → γ

export HMul (hMul)

@[default_instance]
instance : HMul Int Int Int where
  hMul := Int.mul

def xs : List Int := [1, 2, 3]

#check fun y =&gt; xs.map (fun x =&gt; hMul x y)  -- Int → List Int
<span class="boring">end Ex
</span></code></pre>
<!--
By tagging the instance above with the attribute `default_instance`, we are instructing Lean
to use this instance on pending type class synthesis problems.
The actual Lean implementation defines homogeneous and heterogeneous classes for arithmetical operators.
Moreover, `a+b`, `a*b`, `a-b`, `a/b`, and `a%b` are notations for the heterogeneous versions.
The instance `OfNat Nat n` is the default instance (with priority 100) for the `OfNat` class. This is why the numeral
`2` has type `Nat` when the expected type is not known. You can define default instances with higher
priority to override the builtin ones.
-->
<p>通过给上述实例添加 <code>default_instance</code> 属性，我们指示 Lean 在挂起的类型类合成问题中使用此实例。
实际的 Lean 实现为算术运算符定义了同质和异质类。此外，<code>a+b</code>、<code>a*b</code>、<code>a-b</code>、<code>a/b</code> 和 <code>a%b</code>
是异质版本的记法。实例 <code>OfNat Nat n</code> 是 <code>OfNat</code> 类的默认实例（优先级 100）。
这就是当预期类型未知时，数字 <code>2</code> 具有类型 <code>Nat</code> 的原因。
你可以定义具有更高优先级的默认实例来覆盖内置实例。</p>
<pre><code class="language-lean">structure Rational where
  num : Int
  den : Nat
  inv : den ≠ 0

@[default_instance 200]
instance : OfNat Rational n where
  ofNat := { num := n, den := 1, inv := by decide }

instance : ToString Rational where
  toString r := s!&quot;{r.num}/{r.den}&quot;

#check 2 -- Rational
</code></pre>
<!--
Priorities are also useful to control the interaction between different default instances.
For example, suppose `xs` has type `List α`. When elaborating `xs.map (fun x => 2 * x)`, we want the homogeneous instance for multiplication
to have higher priority than the default instance for `OfNat`. This is particularly important when we have implemented only the instance
`HMul α α α`, and did not implement `HMul Nat α α`.
Now, we reveal how the notation `a*b` is defined in Lean.
-->
<p>优先级也适用于控制不同默认实例之间的交互。例如，假设 <code>xs</code> 有类型 <code>List α</code>。
在繁饰 <code>xs.map (fun x =&gt; 2 * x)</code> 时，我们希望乘法的同质实例比 <code>OfNat</code>
的默认实例具有更高的优先级。当我们仅实现了实例 <code>HMul α α α</code>，而未实现 <code>HMul Nat α α</code> 时，
这一点尤为重要。现在，我们展示了 <code>a*b</code> 记法在 Lean 中是如何定义的。</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span>class OfNat (α : Type u) (n : Nat) where
  ofNat : α

@[default_instance]
instance (n : Nat) : OfNat Nat n where
  ofNat := n

class HMul (α : Type u) (β : Type v) (γ : outParam (Type w)) where
  hMul : α → β → γ

class Mul (α : Type u) where
  mul : α → α → α

@[default_instance 10]
instance [Mul α] : HMul α α α where
  hMul a b := Mul.mul a b

infixl:70 &quot; * &quot; =&gt; HMul.hMul
<span class="boring">end Ex
</span></code></pre>
<!--
The `Mul` class is convenient for types that only implement the homogeneous multiplication.
-->
<p><code>Mul</code> 类是仅实现了同质乘法的类型的简便记法。</p>
<!--
## Local Instances
-->
<h2 id="局部实例"><a class="header" href="#局部实例">局部实例</a></h2>
<!--
Type classes are implemented using attributes in Lean. Thus, you can
use the `local` modifier to indicate that they only have effect until
the current ``section`` or ``namespace`` is closed, or until the end
of the current file.
-->
<p>类型类是使用 Lean 中的属性（Attribute）来实现的。因此，你可以使用 <code>local</code>
修饰符表明它们只对当前 <code>section</code> 或 <code>namespace</code> 关闭之前或当前文件结束之前有效。</p>
<pre><code class="language-lean">structure Point where
  x : Nat
  y : Nat

section

local instance : Add Point where
  add a b := { x := a.x + b.x, y := a.y + b.y }

def double (p : Point) :=
  p + p

end -- instance `Add Point` is not active anymore

-- def triple (p : Point) :=
--  p + p + p  -- Error: failed to synthesize instance
</code></pre>
<!--
You can also temporarily disable an instance using the `attribute` command
until the current ``section`` or ``namespace`` is closed, or until the end
of the current file.
-->
<p>你也可使用 <code>attribute</code> 命令暂时禁用一个实例，直至当前的 <code>section</code> 或
<code>namespace</code> 关闭，或直到当前文件的结尾。</p>
<pre><code class="language-lean">structure Point where
  x : Nat
  y : Nat

instance addPoint : Add Point where
  add a b := { x := a.x + b.x, y := a.y + b.y }

def double (p : Point) :=
  p + p

attribute [-instance] addPoint

-- def triple (p : Point) :=
--  p + p + p  -- Error: failed to synthesize instance
</code></pre>
<!--
We recommend you only use this command to diagnose problems.
-->
<p>我们建议你只使用此命令来诊断问题。</p>
<!--
## Scoped Instances
-->
<h2 id="作用于实例"><a class="header" href="#作用于实例">作用于实例</a></h2>
<!--
You can also declare scoped instances in namespaces. This kind of instance is
only active when you are inside of the namespace or open the namespace.
-->
<!--
You can also declare scoped instances in namespaces. This kind of instance is
only active when you are inside of the namespace or open the namespace.
-->
<p>你可以在命名空间中声明作用域实例。这种类型的实例只在你进入命名空间或打开命名空间时激活。</p>
<pre><code class="language-lean">structure Point where
  x : Nat
  y : Nat

namespace Point

scoped instance : Add Point where
  add a b := { x := a.x + b.x, y := a.y + b.y }

def double (p : Point) :=
  p + p

end Point
-- instance `Add Point` is not active anymore

-- #check fun (p : Point) =&gt; p + p + p  -- Error

namespace Point
-- instance `Add Point` is active again
#check fun (p : Point) =&gt; p + p + p

end Point

open Point -- activates instance `Add Point`
#check fun (p : Point) =&gt; p + p + p
</code></pre>
<!--
You can use the command `open scoped <namespace>` to activate scoped attributes but will
not "open" the names from the namespace.
-->
<!--
You can use the command `open scoped <namespace>` to activate scoped attributes but will
not "open" the names from the namespace.
-->
<p>你可以使用 <code>open scoped &lt;namespace&gt;</code> 命令来激活作用于内的属性，但不会「打开」名称空间中的名称。</p>
<pre><code class="language-lean">structure Point where
  x : Nat
  y : Nat

namespace Point

scoped instance : Add Point where
  add a b := { x := a.x + b.x, y := a.y + b.y }

def double (p : Point) :=
  p + p

end Point

open scoped Point -- activates instance `Add Point`
#check fun (p : Point) =&gt; p + p + p

-- #check fun (p : Point) =&gt; double p -- Error: unknown identifier 'double'
</code></pre>
<!--
## Decidable Propositions
-->
<h2 id="可判定的命题"><a class="header" href="#可判定的命题">可判定的命题</a></h2>
<!--
Let us consider another example of a type class defined in the
standard library, namely the type class of ``Decidable``
propositions. Roughly speaking, an element of ``Prop`` is said to be
decidable if we can decide whether it is true or false. The
distinction is only useful in constructive mathematics; classically,
every proposition is decidable. But if we use the classical principle,
say, to define a function by cases, that function will not be
computable. Algorithmically speaking, the ``Decidable`` type class can
be used to infer a procedure that effectively determines whether or
not the proposition is true. As a result, the type class supports such
computational definitions when they are possible while at the same
time allowing a smooth transition to the use of classical definitions
and classical reasoning.
-->
<p>让我们考虑标准库中定义的另一个类型类，名为 <code>Decidable</code> 类型类。
粗略地讲，对于 <code>Prop</code> 的一个元素，如果我们可以判定它是真或假，它就被称为可判定的。
这种区别只有在构造性数学中才有用；在经典数学中，每个命题都是可判定的。
但如果我们使用经典原则，比如通过情况来定义一个函数，那么这个函数将不可计算。
从算法上来讲，<code>Decidable</code> 类型类可以用来推导出一个过程，它能有效判定命题是否为真。
因此，该类型类支持这样的计算性定义（如果它们是可能的），
同时还允许平滑地过渡到经典定义和经典推理的使用。</p>
<!--
In the standard library, ``Decidable`` is defined formally as follows:
-->
<p>在标准库中，<code>Decidable</code> 的形式化定义如下：</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>class inductive Decidable (p : Prop) where
  | isFalse (h : ¬p) : Decidable p
  | isTrue  (h : p)  : Decidable p
<span class="boring">end Hidden
</span></code></pre>
<!--
Logically speaking, having an element ``t : Decidable p`` is stronger
than having an element ``t : p ∨ ¬p``; it enables us to define values
of an arbitrary type depending on the truth value of ``p``. For
example, for the expression ``if p then a else b`` to make sense, we
need to know that ``p`` is decidable. That expression is syntactic
sugar for ``ite p a b``, where ``ite`` is defined as follows:
-->
<p>从逻辑上讲，拥有一个元素 <code>t : Decidable p</code> 比拥有一个元素 <code>t : p ∨ ¬p</code> 更强；
它允许我们定义一个任意类型的的值，这些值取决于 <code>p</code> 的真值。
例如，为了使表达式 <code>if p then a else b</code> 有意义，我们需要知道 <code>p</code>
是可判定的。该表达式是 <code>ite p a b</code> 的语法糖，其中 <code>ite</code> 的定义如下：</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>def ite {α : Sort u} (c : Prop) [h : Decidable c] (t e : α) : α :=
  Decidable.casesOn (motive := fun _ =&gt; α) h (fun _ =&gt; e) (fun _ =&gt; t)
<span class="boring">end Hidden
</span></code></pre>
<!--
The standard library also contains a variant of ``ite`` called
``dite``, the dependent if-then-else expression. It is defined as
follows:
-->
<!--
The standard library also contains a variant of ``ite`` called
``dite``, the dependent if-then-else expression. It is defined as
follows:
-->
<p>标准库中还包含 <code>ite</code> 的一种变体，称为 <code>dite</code>，
即依赖 if-then-else 表达式。它的定义如下：</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>def dite {α : Sort u} (c : Prop) [h : Decidable c] (t : c → α) (e : Not c → α) : α :=
  Decidable.casesOn (motive := fun _ =&gt; α) h e t
<span class="boring">end Hidden
</span></code></pre>
<!--
That is, in ``dite c t e``, we can assume ``hc : c`` in the "then"
branch, and ``hnc : ¬ c`` in the "else" branch. To make ``dite`` more
convenient to use, Lean allows us to write ``if h : c then t else e``
instead of ``dite c (λ h : c => t) (λ h : ¬ c => e)``.
-->
<p>即在 <code>dite c t e</code> 表达式中，我们可以在 <code>then</code> 分支假定
<code>hc : c</code>，在 <code>else</code> 分支假定 <code>hnc : ¬ c</code>。为了方便 <code>dite</code> 的使用，
Lean 允许我们将 <code>if h : c then t else e</code> 写作 <code>dite c (λ h : c =&gt; t) (λ h : ¬ c =&gt; e)</code>。</p>
<!--
Without classical logic, we cannot prove that every proposition is
decidable. But we can prove that *certain* propositions are
decidable. For example, we can prove the decidability of basic
operations like equality and comparisons on the natural numbers and
the integers. Moreover, decidability is preserved under propositional
connectives:
-->
<p>如果没有经典逻辑，我们就不能证明每个命题都是可判定的。
但我们可以证明 <strong>某些</strong> 命题是可判定的。
例如，我们可以证明基本运算（比如自然数和整数上的等式和比较）的可判定性。
此外，命题连词下的可判定性被保留了下来：</p>
<pre><code class="language-lean">#check @instDecidableAnd
  -- {p q : Prop} → [Decidable p] → [Decidable q] → Decidable (And p q)

#check @instDecidableOr
#check @instDecidableNot
</code></pre>
<!--
Thus we can carry out definitions by cases on decidable predicates on
the natural numbers:
-->
<p>因此我们可以按照自然数上的可判定谓词的情况给出定义：</p>
<pre><code class="language-lean">def step (a b x : Nat) : Nat :=
  if x &lt; a ∨ x &gt; b then 0 else 1

set_option pp.explicit true
#print step
</code></pre>
<!--
Turning on implicit arguments shows that the elaborator has inferred
the decidability of the proposition ``x < a ∨ x > b``, simply by
applying appropriate instances.
-->
<p>打开隐式参数显示，繁饰器已经推断出了命题 <code>x &lt; a ∨ x &gt; b</code> 的可判定性，
只需应用适当的实例即可。</p>
<!--
With the classical axioms, we can prove that every proposition is
decidable. You can import the classical axioms and make the generic
instance of decidability available by opening the `Classical` namespace.
-->
<p>使用经典公理，我们可以证明每个命题都是可判定的。
你可以导入经典公理，并通过打开 <code>Classical</code> 命名空间来提供可判定的通用实例。</p>
<pre><code class="language-lean">open Classical
</code></pre>
<!--
Thereafter ``Decidable p`` has an instance for every ``p``.
Thus all theorems in the library
that rely on decidability assumptions are freely available when you
want to reason classically. In [Chapter Axioms and Computation](./axioms_and_computation.md),
we will see that using the law of the
excluded middle to define functions can prevent them from being used
computationally. Thus, the standard library assigns a low priority to
the `propDecidable` instance.
-->
<p>之后 <code>Decidable p</code> 就会拥有任何 <code>p</code> 的实例。
因此，当你想进行经典推理时，库中的所有依赖于可判定假设的定理都会免费提供。
在<a href="./axioms_and_computation.html">公理和计算</a>一章中，
我们将看到，使用排中律来定义函数会阻止它们被计算性地使用。
因此，标准库将 <code>propDecidable</code> 实例的优先级设为低。</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>open Classical
noncomputable scoped
instance (priority := low) propDecidable (a : Prop) : Decidable a :=
  choice &lt;| match em a with
    | Or.inl h =&gt; ⟨isTrue h⟩
    | Or.inr h =&gt; ⟨isFalse h⟩
<span class="boring">end Hidden
</span></code></pre>
<!--
This guarantees that Lean will favor other instances and fall back on
``propDecidable`` only after other attempts to infer decidability have
failed.
-->
<p>这能保证 Lean 会优先采用其他实例，只有在推断可判定性失败后才退回到 <code>propDecidable</code>。</p>
<!--
The ``Decidable`` type class also provides a bit of small-scale
automation for proving theorems. The standard library introduces the
tactic `decide` that uses the `Decidable` instance to solve simple goals.
-->
<p><code>Decidable</code> 类型类还为定理证明提供了一点小规模的自动化。
标准库引入了使用 <code>Decidable</code> 实例解决简单目标的策略 <code>decide</code>。</p>
<pre><code class="language-lean">example : 10 &lt; 5 ∨ 1 &gt; 0 := by
  decide

example : ¬ (True ∧ False) := by
  decide

example : 10 * 20 = 200 := by
  decide

theorem ex : True ∧ 2 = 1+1 := by
  decide

#print ex
-- theorem ex : True ∧ 2 = 1 + 1 :=
-- of_decide_eq_true (Eq.refl true)

#check @of_decide_eq_true
-- ∀ {p : Prop} [Decidable p], decide p = true → p

#check @decide
-- (p : Prop) → [Decidable p] → Bool
</code></pre>
<!--
They work as follows. The expression ``decide p`` tries to infer a
decision procedure for ``p``, and, if it is successful, evaluates to
either ``true`` or ``false``. In particular, if ``p`` is a true closed
expression, ``decide p`` will reduce definitionally to the Boolean ``true``.
On the assumption that ``decide p = true`` holds, ``of_decide_eq_true``
produces a proof of ``p``. The tactic ``decide`` puts it all together to
prove a target ``p``. By the previous observations,
``decide`` will succeed any time the inferred decision procedure
 for ``c`` has enough information to evaluate, definitionally, to the ``isTrue`` case.
-->
<p>它们的工作方式如下：表达式 <code>decide p</code> 尝试推断 <code>p</code> 的决策过程，如果成功，
则会求值为 <code>true</code> 或 <code>false</code>。特别是，如果 <code>p</code> 是一个为真的封闭表达式，
<code>decide p</code> 将根据定义化简未为布尔值 <code>true</code>。在假设 <code>decide p = true</code>
成立的情况下，<code>of_decide_eq_true</code> 会生成 <code>p</code> 的证明。
策略 <code>decide</code> 将所有这些组合在一起以证明目标 <code>p</code>。根据前面的观察，
只要推断出的决策过程拥有足够的信息，可以根据定义将 <code>c</code> 求值为 <code>isTrue</code> 的情况，
那么 <code>decide</code> 就会成功。</p>
<!--
## Managing Type Class Inference
-->
<h2 id="类型类推断的管理"><a class="header" href="#类型类推断的管理">类型类推断的管理</a></h2>
<!--
If you are ever in a situation where you need to supply an expression
that Lean can infer by type class inference, you can ask Lean to carry
out the inference using `inferInstance`:
-->
<p>如果你需要使用类型类推断来提供一个 Lean 可以推断的表达式，
那么你可以使用 <code>inferInstance</code> 让 Lean 执行推断：</p>
<pre><code class="language-lean">def foo : Add Nat := inferInstance
def bar : Inhabited (Nat → Nat) := inferInstance

#check @inferInstance
-- {α : Sort u} → [α] → α
</code></pre>
<!--
In fact, you can use Lean's ``(t : T)`` notation to specify the class whose instance you are looking for,
in a concise manner:
-->
<p>你可以使用 Lean 中的 <code>(t : T)</code> 语法指定你正在寻找的类的实例，
这是一种很简洁的方式：</p>
<pre><code class="language-lean">#check (inferInstance : Add Nat)
</code></pre>
<!--
You can also use the auxiliary definition `inferInstanceAs`:
-->
<p>你也可以使用辅助定义 <code>inferInstanceAs</code>：</p>
<pre><code class="language-lean">#check inferInstanceAs (Add Nat)

#check @inferInstanceAs
-- (α : Sort u) → [α] → α
</code></pre>
<!--
Sometimes Lean can't find an instance because the class is buried
under a definition. For example, Lean cannot
find an instance of ``Inhabited (Set α)``. We can declare one
explicitly:
-->
<p>有时 Lean 会找不到一个实例，因为该类被定义所掩盖。例如，Lean 无法
找到 <code>Inhabited (Set α)</code> 的一个实例。我们可以显式地声明一个：</p>
<pre><code class="language-lean">def Set (α : Type u) := α → Prop

-- fails
-- example : Inhabited (Set α) :=
--  inferInstance

instance : Inhabited (Set α) :=
  inferInstanceAs (Inhabited (α → Prop))
</code></pre>
<!--
At times, you may find that the type class inference fails to find an
expected instance, or, worse, falls into an infinite loop and times
out. To help debug in these situations, Lean enables you to request a
trace of the search:
-->
<p>有时，你可能会发现类型类推断未找到预期的实例，或者更糟的是，陷入无限循环并超时。
为了在这些情况下帮助调试，Lean 可以让你请求搜索的跟踪：</p>
<pre><code class="language-lean">set_option trace.Meta.synthInstance true
</code></pre>
<!--
If you are using VS Code, you can read the results by hovering over
the relevant theorem or definition, or opening the messages window
with ``Ctrl-Shift-Enter``. In Emacs, you can use ``C-c C-x`` to run an
independent Lean process on your file, and the output buffer will show
a trace every time the type class resolution procedure is subsequently
triggered.
-->
<p>如果你使用的是 VS Code，可以通过将鼠标悬停在相关的定理或定义上，
或按 <code>Ctrl-Shift-Enter</code> 打开消息窗口来阅读结果。在 Emacs 中，
你可以使用 <code>C-c C-x</code> 在你的文件中运行一个独立的 Lean 进程，
并且在每次触发类型类解析过程时，输出缓冲区都会显示一个跟踪。</p>
<!--
You can also limit the search using the following options:
-->
<p>使用以下选项，你还可以限制搜索：</p>
<pre><code class="language-lean">set_option synthInstance.maxHeartbeats 10000
set_option synthInstance.maxSize 400
</code></pre>
<!--
Option `synthInstance.maxHeartbeats` specifies the maximum amount of
heartbeats per typeclass resolution problem. A heartbeat is the number of
(small) memory allocations (in thousands), 0 means there is no limit.
Option `synthInstance.maxSize` is the maximum number of instances used
to construct a solution in the type class instance synthesis procedure.
-->
<p>选项 <code>synthInstance.maxHeartbeats</code> 指定每个类型类解析问题可能出现的心跳（Heartbeat）次数上限。
心跳是（小）内存分配的次数（以千为单位），0 表示没有上限。
选项 <code>synthInstance.maxSize</code> 是用于构建类型类实例合成过程中解的实例个数。</p>
<!--
Remember also that in both the VS Code and Emacs editor modes, tab
completion works in ``set_option``, to help you find suitable options.
-->
<p>另外请记住，在 VS Code 和 Emacs 编辑器模式中，制表符补全也可用于
<code>set_option</code>，它可以帮助你查找合适的选项。</p>
<!--
As noted above, the type class instances in a given context represent
a Prolog-like program, which gives rise to a backtracking search. Both
the efficiency of the program and the solutions that are found can
depend on the order in which the system tries the instance. Instances
which are declared last are tried first. Moreover, if instances are
declared in other modules, the order in which they are tried depends
on the order in which namespaces are opened. Instances declared in
namespaces which are opened later are tried earlier.
-->
<p>如上所述，给定语境中的类型类实例代表一个类似 Prolog 的程序，它会进行回溯搜索。
同时程序的效率和找到的解都取决于系统尝试实例的顺序。最后声明的实例首先尝试。
此外，如果在其它模块中声明了实例，它们尝试的顺序取决于打开名称空间的顺序。
在后面打开的名称空间中声明的实例，会更早尝试。</p>
<!--
You can change the order that type class instances are tried by
assigning them a *priority*. When an instance is declared, it is
assigned a default priority value. You can assign other priorities
when defining an instance. The following example illustrates how this
is done:
-->
<p>你可以按对类型类实例进行尝试的顺序来更改这些实例，
方法是为它们分配一个 <strong>优先级</strong> 。在声明实例时，
它将被分配一个默认优先级值。在定义实例时，你可以分配其他的优先级。
以下示例说明了如何执行此操作：</p>
<pre><code class="language-lean">class Foo where
  a : Nat
  b : Nat

instance (priority := default+1) i1 : Foo where
  a := 1
  b := 1

instance i2 : Foo where
  a := 2
  b := 2

example : Foo.a = 1 :=
  rfl

instance (priority := default+2) i3 : Foo where
  a := 3
  b := 3

example : Foo.a = 3 :=
  rfl
</code></pre>
<!--
## Coercions using Type Classes
-->
<h2 id="使用类型泛型进行强制转换"><a class="header" href="#使用类型泛型进行强制转换">使用类型泛型进行强制转换</a></h2>
<!--
The most basic type of coercion maps elements of one type to another. For example, a coercion from ``Nat`` to ``Int`` allows us to view any element ``n : Nat`` as an element of ``Int``. But some coercions depend on parameters; for example, for any type ``α``, we can view any element ``as : List α`` as an element of ``Set α``, namely, the set of elements occurring in the list. The corresponding coercion is defined on the "family" of types ``List α``, parameterized by ``α``.
-->
<p>最基本的强制转换将一种类型的元素映射到另一种类型。
例如，从 <code>Nat</code> 到 <code>Int</code> 的强制转换允许我们将任何元素 <code>n : Nat</code> 视作元素 <code>Int</code>。
但一些强制转换依赖于参数；例如，对于任何类型 <code>α</code>，我们可以将任何元素
<code>as : List α</code> 视为 <code>Set α</code> 的元素，即，列表中出现的元素组成的集合。
相应的强制转换被定义在 <code>List α</code> 的「类型族（Type Family）」上，由 <code>α</code> 参数化。</p>
<!--
Lean allows us to declare three kinds of coercions:

- from a family of types to another family of types
- from a family of types to the class of sorts
- from a family of types to the class of function types
-->
<p>Lean 允许我们声明三类强制转换：</p>
<ul>
<li>从一个类型族到另一个类型族</li>
<li>从一个类型族到种类（Sort）的类</li>
<li>从一个类型族到函数类型的类</li>
</ul>
<!--
The first kind of coercion allows us to view any element of a member of the source family as an element of a corresponding member of the target family. The second kind of coercion allows us to view any element of a member of the source family as a type. The third kind of coercion allows us to view any element of the source family as a function. Let us consider each of these in turn.
-->
<p>第一种强制转换允许我们将源类型族任何成员的元素视为目标类型族中对应成员的元素。
第二种强制转换允许我们将源类型族任何成员的元素视为类型。
第三种强制转换允许我们将源类型族任何成员的元素视为函数。
让我们逐一考虑这些。</p>
<!--
In Lean, coercions are implemented on top of the type class resolution framework. We define a coercion from ``α`` to ``β`` by declaring an instance of ``Coe α β``. For example, we can define a coercion from ``Bool`` to ``Prop`` as follows:
-->
<p>在 Lean 中，强制转换在类型类解析框架的基础上实现。我们通过声明 <code>Coe α β</code> 的实例，
定义从 <code>α</code> 到 <code>β</code> 的强制转换。例如，以下内容可以定义从 <code>Bool</code> 到 <code>Prop</code> 的强制转换：</p>
<pre><code class="language-lean">instance : Coe Bool Prop where
  coe b := b = true
</code></pre>
<!--
This enables us to use boolean terms in if-then-else expressions:
-->
<p>这使得我们可以在 if-then-else 表达式中使用布尔项：</p>
<pre><code class="language-lean">#eval if true then 5 else 3
#eval if false then 5 else 3
</code></pre>
<!--
We can define a coercion from ``List α`` to ``Set α`` as follows:
-->
<p>我们可以定义一个从 <code>List α</code> 到 <code>Set α</code> 的强制转换，如下所示：</p>
<pre><code class="language-lean"><span class="boring">def Set (α : Type u) := α → Prop
</span><span class="boring">def Set.empty {α : Type u} : Set α := fun _ =&gt; False
</span><span class="boring">def Set.mem (a : α) (s : Set α) : Prop := s a
</span><span class="boring">def Set.singleton (a : α) : Set α := fun x =&gt; x = a
</span><span class="boring">def Set.union (a b : Set α) : Set α := fun x =&gt; a x ∨ b x
</span><span class="boring">notation &quot;{ &quot; a &quot; }&quot; =&gt; Set.singleton a
</span><span class="boring">infix:55 &quot; ∪ &quot; =&gt; Set.union
</span>def List.toSet : List α → Set α
  | []    =&gt; Set.empty
  | a::as =&gt; {a} ∪ as.toSet

instance : Coe (List α) (Set α) where
  coe a := a.toSet

def s : Set Nat := {1}
#check s ∪ [2, 3]
-- s ∪ List.toSet [2, 3] : Set Nat
</code></pre>
<!--
We can use the notation ``↑`` to force a coercion to be introduced in a particular place. It is also helpful to make our intent clear, and work around limitations of the coercion resolution system.
-->
<p>我们可以使用符号 <code>↑</code> 在特定位置强制引入强制转换。
这也有助于明确我们的意图，并解决强制转换解析系统中的限制。</p>
<pre><code class="language-lean"><span class="boring">def Set (α : Type u) := α → Prop
</span><span class="boring">def Set.empty {α : Type u} : Set α := fun _ =&gt; False
</span><span class="boring">def Set.mem (a : α) (s : Set α) : Prop := s a
</span><span class="boring">def Set.singleton (a : α) : Set α := fun x =&gt; x = a
</span><span class="boring">def Set.union (a b : Set α) : Set α := fun x =&gt; a x ∨ b x
</span><span class="boring">notation &quot;{ &quot; a &quot; }&quot; =&gt; Set.singleton a
</span><span class="boring">infix:55 &quot; ∪ &quot; =&gt; Set.union
</span><span class="boring">def List.toSet : List α → Set α
</span><span class="boring">  | []    =&gt; Set.empty
</span><span class="boring">  | a::as =&gt; {a} ∪ as.toSet
</span><span class="boring">instance : Coe (List α) (Set α) where
</span><span class="boring">  coe a := a.toSet
</span>def s : Set Nat := {1}

#check let x := ↑[2, 3]; s ∪ x
-- let x := List.toSet [2, 3]; s ∪ x : Set Nat
#check let x := [2, 3]; s ∪ x
-- let x := [2, 3]; s ∪ List.toSet x : Set Nat
</code></pre>
<!--
Lean also supports dependent coercions using the type class `CoeDep`. For example, we cannot coerce arbitrary propositions to `Bool`, only the ones that implement the `Decidable` typeclass.
-->
<p>Lean 还使用类型类 <code>CoeDep</code> 支持依值类型强制转换。
例如，我们无法将任意命题强制转换到 <code>Bool</code>，只能转换实现了 <code>Decidable</code> 类型类的命题。</p>
<pre><code class="language-lean">instance (p : Prop) [Decidable p] : CoeDep Prop p Bool where
  coe := decide p
</code></pre>
<!--
Lean will also chain (non-dependent) coercions as necessary. Actually, the type class ``CoeT`` is the transitive closure of ``Coe``.
-->
<p>Lean 也会在有需要的时候构造链式（非依赖的）强制转换。事实上，类型类 <code>CoeT</code> 是 <code>Coe</code> 的传递闭包。</p>
<!--
Let us now consider the second kind of coercion. By the *class of sorts*, we mean the collection of universes ``Type u``. A coercion of the second kind is of the form:
-->
<p>现在我们来考查第二种强制转换。 <strong>种类类（Class of Sort）</strong> 是指宇宙 <code>Type u</code> 的集合。
第二种强制转换的形式如下：</p>
<pre><code>    c : (x1 : A1) → ... → (xn : An) → F x1 ... xn → Type u
</code></pre>
<!--
where ``F`` is a family of types as above. This allows us to write ``s : t`` whenever ``t`` is of type ``F a1 ... an``. In other words, the coercion allows us to view the elements of ``F a1 ... an`` as types. This is very useful when defining algebraic structures in which one component, the carrier of the structure, is a ``Type``. For example, we can define a semigroup as follows:
-->
<p>其中 <code>F</code> 是如上所示的一族类型。这允许我们当 <code>t</code> 的类型为 <code>F a1 ... an</code> 时编写 <code>s : t</code> 。
换言之，类型转换允许我们将 <code>F a1 ... an</code> 的元素视为类型。
这在定义代数结构时非常有用，其中一个组成部分（即结构的载体）为 <code>Type</code>。
例如，我们可以按以下方式定义一个半群：</p>
<pre><code class="language-lean">structure Semigroup where
  carrier : Type u
  mul : carrier → carrier → carrier
  mul_assoc (a b c : carrier) : mul (mul a b) c = mul a (mul b c)

instance (S : Semigroup) : Mul S.carrier where
  mul a b := S.mul a b
</code></pre>
<!--
In other words, a semigroup consists of a type, ``carrier``, and a multiplication, ``mul``, with the property that the multiplication is associative. The ``instance`` command allows us to write ``a * b`` instead of ``Semigroup.mul S a b`` whenever we have ``a b : S.carrier``; notice that Lean can infer the argument ``S`` from the types of ``a`` and ``b``. The function ``Semigroup.carrier`` maps the class ``Semigroup`` to the sort ``Type u``:
-->
<p>换句话说，一个半群包括一个类型「载体（<code>carrier</code>）」和一个乘法 <code>mul</code>，乘法满足结合性。
<code>instance</code> 命令允许我们用 <code>a * b</code> 代替 <code>Semigroup.mul S a b</code> 只要我们有 <code>a b : S.carrier</code>；
注意，Lean 可以根据 <code>a</code> 和 <code>b</code> 的类型推断出参数 <code>S</code>。函数 <code>Semigroup.carrier</code>
将类 <code>Semigroup</code> 映射到种类 <code>Type u</code>：</p>
<pre><code class="language-lean"><span class="boring">structure Semigroup where
</span><span class="boring">  carrier : Type u
</span><span class="boring">  mul : carrier → carrier → carrier
</span><span class="boring">  mul_assoc (a b c : carrier) : mul (mul a b) c = mul a (mul b c)
</span><span class="boring">instance (S : Semigroup) : Mul S.carrier where
</span><span class="boring">  mul a b := S.mul a b
</span>#check Semigroup.carrier
</code></pre>
<!--
If we declare this function to be a coercion, then whenever we have a semigroup ``S : Semigroup``, we can write ``a : S`` instead of ``a : S.carrier``:
-->
<p>如果我们声明该函数是一个强制转换函数，那么无论何时我们都有半群 <code>S : Semigroup</code>,
我们可以写 <code>a : S</code> 而非 <code>a : S.carrier</code>：</p>
<pre><code class="language-lean"><span class="boring">structure Semigroup where
</span><span class="boring">  carrier : Type u
</span><span class="boring">  mul : carrier → carrier → carrier
</span><span class="boring">  mul_assoc (a b c : carrier) : mul (mul a b) c = mul a (mul b c)
</span><span class="boring">instance (S : Semigroup) : Mul S.carrier where
</span><span class="boring">  mul a b := S.mul a b
</span>instance : CoeSort Semigroup (Type u) where
  coe s := s.carrier

example (S : Semigroup) (a b c : S) : (a * b) * c = a * (b * c) :=
  Semigroup.mul_assoc _ a b c
</code></pre>
<!--
It is the coercion that makes it possible to write ``(a b c : S)``. Note that, we define an instance of ``CoeSort Semigroup (Type u)`` instead of ``Coe Semigroup (Type u)``.
-->
<p>由于强制转换，我们可以写 <code>(a b c : S)</code>。
注意，我们定义了一个 <code>CoeSort Semigroup (Type u)</code> 的实例，
而非 <code>Coe Semigroup (Type u)</code>。</p>
<!--
By the *class of function types*, we mean the collection of Pi types ``(z : B) → C``. The third kind of coercion has the form:
-->
<p><strong>函数类型的类</strong> ，是指 Π 类型集合 <code>(z : B) → C</code>。第三种强制转换形式为：</p>
<pre><code>    c : (x1 : A1) → ... → (xn : An) → (y : F x1 ... xn) → (z : B) → C
</code></pre>
<!--
where ``F`` is again a family of types and ``B`` and ``C`` can depend on ``x1, ..., xn, y``. This makes it possible to write ``t s`` whenever ``t`` is an element of ``F a1 ... an``. In other words, the coercion enables us to view elements of ``F a1 ... an`` as functions. Continuing the example above, we can define the notion of a morphism between semigroups ``S1`` and ``S2``. That is, a function from the carrier of ``S1`` to the carrier of ``S2`` (note the implicit coercion) that respects the multiplication. The projection ``morphism.mor`` takes a morphism to the underlying function:
-->
<p>其中 <code>F</code> 仍然是一个类型族，而 <code>B</code> 和 <code>C</code> 可以取决于 <code>x1, ..., xn, y</code>。
这使得可以写 <code>t s</code>，只要 <code>t</code> 是 <code>F a1 ... an</code> 的元素。
换句话说，转换使我们可以将 <code>F a1 ... an</code> 的元素视为函数。
继续上面的示例，我们可以定义半群 <code>S1</code> 和 <code>S2</code> 之间的态射的概念。
即，从 <code>S1</code> 的载体到 <code>S2</code> 的载体（注意隐式转换）关于乘法的一个函数。
投影 <code>morphism.mor</code> 将一个态射转化为底层函数。</p>
<pre><code class="language-lean"><span class="boring">structure Semigroup where
</span><span class="boring">  carrier : Type u
</span><span class="boring">  mul : carrier → carrier → carrier
</span><span class="boring">  mul_assoc (a b c : carrier) : mul (mul a b) c = mul a (mul b c)
</span><span class="boring">instance (S : Semigroup) : Mul S.carrier where
</span><span class="boring">  mul a b := S.mul a b
</span><span class="boring">instance : CoeSort Semigroup (Type u) where
</span><span class="boring">  coe s := s.carrier
</span>structure Morphism (S1 S2 : Semigroup) where
  mor : S1 → S2
  resp_mul : ∀ a b : S1, mor (a * b) = (mor a) * (mor b)

#check @Morphism.mor
</code></pre>
<!--
As a result, it is a prime candidate for the third type of coercion.
-->
<p>因此，它成为第三种强制转换的主要候选。</p>
<pre><code class="language-lean"><span class="boring">structure Semigroup where
</span><span class="boring">  carrier : Type u
</span><span class="boring">  mul : carrier → carrier → carrier
</span><span class="boring">  mul_assoc (a b c : carrier) : mul (mul a b) c = mul a (mul b c)
</span><span class="boring">instance (S : Semigroup) : Mul S.carrier where
</span><span class="boring">  mul a b := S.mul a b
</span><span class="boring">instance : CoeSort Semigroup (Type u) where
</span><span class="boring">  coe s := s.carrier
</span><span class="boring">structure Morphism (S1 S2 : Semigroup) where
</span><span class="boring">  mor : S1 → S2
</span><span class="boring">  resp_mul : ∀ a b : S1, mor (a * b) = (mor a) * (mor b)
</span>instance (S1 S2 : Semigroup) : CoeFun (Morphism S1 S2) (fun _ =&gt; S1 → S2) where
  coe m := m.mor

theorem resp_mul {S1 S2 : Semigroup} (f : Morphism S1 S2) (a b : S1)
        : f (a * b) = f a * f b :=
  f.resp_mul a b

example (S1 S2 : Semigroup) (f : Morphism S1 S2) (a : S1) :
      f (a * a * a) = f a * f a * f a :=
  calc f (a * a * a)
    _ = f (a * a) * f a := by rw [resp_mul f]
    _ = f a * f a * f a := by rw [resp_mul f]
</code></pre>
<!--
With the coercion in place, we can write ``f (a * a * a)`` instead of ``f.mor (a * a * a)``. When the ``Morphism``, ``f``, is used where a function is expected, Lean inserts the coercion. Similar to ``CoeSort``, we have yet another class ``CoeFun`` for this class of coercions. The field ``F`` is used to specify the function type we are coercing to. This type may depend on the type we are coercing from.
-->
<p>有了强制类型转换，我们可以直接写 <code>f (a * a * a)</code> 而不必写 <code>f.mor (a * a * a)</code>。
当 <code>Morphism</code>（态射）<code>f</code> 被用于原本期望函数的位置时，
Lean 会自动插入强制转换。类似于 <code>CoeSort</code>，我们还有另一个类 <code>CoeFun</code>
用于这一类的强制转换。域 <code>F</code> 用于指定我们强制类型转换的目标函数类型。
此类型可能依赖于我们强制转换的原类型。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
The Conversion Tactic Mode
=========================
-->
<h1 id="转换策略模式"><a class="header" href="#转换策略模式">转换策略模式</a></h1>
<!--
Inside a tactic block, one can use the keyword `conv` to enter
conversion mode. This mode allows to travel inside assumptions and
goals, even inside function abstractions and dependent arrows, to apply rewriting or
simplifying steps.
-->
<p>在策略块中，可以使用关键字<code>conv</code>进入转换模式(conversion mode)。这种模式允许在假设和目标内部，甚至在函数抽象和依赖箭头内部移动，以应用重写或简化步骤。</p>
<!--
Basic navigation and rewriting
-------
-->
<h2 id="基本导航和重写"><a class="header" href="#基本导航和重写">基本导航和重写</a></h2>
<!--
As a first example, let us prove example
`(a b c : Nat) : a * (b * c) = a * (c * b)`
(examples in this file are somewhat artificial since
other tactics could finish them immediately). The naive
first attempt is to enter tactic mode and try `rw [Nat.mul_comm]`. But this
transforms the goal into `b * c * a = a * (c * b)`, after commuting the
very first multiplication appearing in the term. There are several
ways to fix this issue, and one way is to use a more precise tool:
the conversion mode. The following code block shows the current target
after each line.
-->
<p>作为第一个例子，让我们证明<code>(a b c : Nat) : a * (b * c) = a * (c * b)</code>（本段中的例子有些刻意设计，因为其他策略可以立即完成它们）。首次简单的尝试是尝试<code>rw [Nat.mul_comm]</code>，但这将目标转化为<code>b * c * a = a * (c * b)</code>，因为它作用于项中出现的第一个乘法。有几种方法可以解决这个问题，其中一个方法是</p>
<pre><code class="language-lean">example (a b c : Nat) : a * (b * c) = a * (c * b) := by
    rw [Nat.mul_comm b c]
</code></pre>
<p>不过本节介绍一个更精确的工具：转换模式。下面的代码块显示了每行之后的当前目标。</p>
<pre><code class="language-lean">example (a b c : Nat) : a * (b * c) = a * (c * b) := by
  conv =&gt;
    -- ⊢ a * (b * c) = a * (c * b)
    lhs
    -- ⊢ a * (b * c)
    congr
    -- 2 goals: ⊢ a, ⊢ b * c
    rfl
    -- ⊢ b * c
    rw [Nat.mul_comm]
</code></pre>
<!--
The above snippet shows three navigation commands:

- `lhs` navigates to the left hand side of a relation (here equality), there is also a `rhs` navigating to the right hand side.
- `congr` creates as many targets as there are (nondependent and explicit) arguments to the current head function
  (here the head function is multiplication).
- `rfl` closes target using reflexivity.

Once arrived at the relevant target, we can use `rw` as in normal
tactic mode.

The second main reason to use conversion mode is to rewrite under
binders. Suppose we want to prove example
`(fun x : Nat => 0 + x) = (fun x => x)`.
The naive first attempt is to enter tactic mode and try
`rw [Nat.zero_add]`. But this fails with a frustrating
-->
<p>上面这段涉及三个导航指令：</p>
<ul>
<li><code>lhs</code>（left hand side）导航到关系（此处是等式）左边。同理<code>rhs</code>导航到右边。</li>
<li><code>congr</code>创建与当前头函数的(非依赖的和显式的)参数数量一样多的目标（此处的头函数是乘法）。</li>
<li><code>skip</code>走到下一个目标。</li>
</ul>
<p>一旦到达相关目标，我们就可以像在普通策略模式中一样使用<code>rw</code>。</p>
<p>使用转换模式的第二个主要原因是在约束器下重写。假设我们想证明<code>(fun x : Nat =&gt; 0 + x) = (fun x =&gt; x)</code>。首次简单的尝试<code>rw [zero_add]</code>是失败的。报错：</p>
<pre><code>error: tactic 'rewrite' failed, did not find instance of the pattern
       in the target expression
  0 + ?n
⊢ (fun x =&gt; 0 + x) = fun x =&gt; x
</code></pre>
<p>（错误：'rewrite'策略失败了，没有找到目标表达式中的模式0 + ?n）</p>
<!--
The solution is:
-->
<p>解决方案为：</p>
<pre><code class="language-lean">example : (fun x : Nat =&gt; 0 + x) = (fun x =&gt; x) := by
  conv =&gt;
    lhs
    intro x
    rw [Nat.zero_add]
</code></pre>
<!--
where `intro x` is the navigation command entering inside the `fun` binder.
Note that this example is somewhat artificial, one could also do:
-->
<p>其中<code>intro x</code>是导航命令，它进入了<code>fun</code>约束器。这个例子有点刻意，你也可以这样做：</p>
<pre><code class="language-lean">example : (fun x : Nat =&gt; 0 + x) = (fun x =&gt; x) := by
  funext x; rw [Nat.zero_add]
</code></pre>
<!--
or just
-->
<p>或者这样：</p>
<pre><code class="language-lean">example : (fun x : Nat =&gt; 0 + x) = (fun x =&gt; x) := by
  simp
</code></pre>
<!--
`conv` can also rewrite a hypothesis `h` from the local context, using `conv at h`.
-->
<p>所有这些也可以用<code>conv at h</code>从局部上下文重写一个假设<code>h</code>。</p>
<!--
Pattern matching
-------
-->
<h2 id="模式匹配-1"><a class="header" href="#模式匹配-1">模式匹配</a></h2>
<!--
Navigation using the above commands can be tedious. One can shortcut it using pattern matching as follows:
-->
<p>使用上面的命令进行导航可能很无聊。使用下面的模式匹配来简化它：</p>
<pre><code class="language-lean">example (a b c : Nat) : a * (b * c) = a * (c * b) := by
  conv in b * c =&gt; rw [Nat.mul_comm]
</code></pre>
<!--
which is just syntax sugar for
-->
<p>这是下面代码的语法糖：</p>
<pre><code class="language-lean">example (a b c : Nat) : a * (b * c) = a * (c * b) := by
  conv =&gt;
    pattern b * c
    rw [Nat.mul_comm]
</code></pre>
<!--
Of course, wildcards are allowed:
-->
<p>当然也可以用通配符：</p>
<pre><code class="language-lean">example (a b c : Nat) : a * (b * c) = a * (c * b) := by
  conv in _ * c =&gt; rw [Nat.mul_comm]
</code></pre>
<!--
Structuring conversion tactics
-------
-->
<h2 id="结构化转换策略"><a class="header" href="#结构化转换策略">结构化转换策略</a></h2>
<!--
Curly brackets and `.` can also be used in `conv` mode to structure tactics.
-->
<p>大括号和<code>.</code>也可以在<code>conv</code>模式下用于结构化策略。</p>
<pre><code class="language-lean">example (a b c : Nat) : (0 + a) * (b * c) = a * (c * b) := by
  conv =&gt;
    lhs
    congr
    . rw [Nat.zero_add]
    . rw [Nat.mul_comm]
</code></pre>
<!--
Other tactics inside conversion mode
----------
-->
<h2 id="转换模式中的其他策略"><a class="header" href="#转换模式中的其他策略">转换模式中的其他策略</a></h2>
<!--
- `arg i` enter the `i`-th nondependent explicit argument of an application.
-->
<ul>
<li><code>arg i</code>进入一个应用的第<code>i</code>个非独立显式参数。</li>
</ul>
<pre><code class="language-lean">example (a b c : Nat) : a * (b * c) = a * (c * b) := by
  conv =&gt;
    -- ⊢ a * (b * c) = a * (c * b)
    lhs
    -- ⊢ a * (b * c)
    arg 2
    -- ⊢ b * c
    rw [Nat.mul_comm]
</code></pre>
<!--
- `args` alternative name for `congr`.

- `simp` applies the simplifier to the current goal. It supports the same options available in regular tactic mode.
-->
<ul>
<li>
<p><code>args</code>是<code>congr</code>的替代品。</p>
</li>
<li>
<p><code>simp</code>将简化器应用于当前目标。它支持常规策略模式中的相同选项。</p>
</li>
</ul>
<pre><code class="language-lean">def f (x : Nat) :=
  if x &gt; 0 then x + 1 else x + 2

example (g : Nat → Nat) (h₁ : g x = x + 1) (h₂ : x &gt; 0) : g x = f x := by
  conv =&gt;
    rhs
    simp [f, h₂]
  exact h₁
</code></pre>
<!--
- `enter [1, x, 2, y]` iterate `arg` and `intro` with the given arguments. It is just the macro:
-->
<ul>
<li><code>enter [1, x, 2, y]</code>是<code>arg</code>和<code>intro</code>使用给定参数的宏。</li>
</ul>
<pre><code>syntax enterArg := ident &lt;|&gt; group(&quot;@&quot;? num)
syntax &quot;enter &quot; &quot;[&quot; (colGt enterArg),+ &quot;]&quot;: conv
macro_rules
  | `(conv| enter [$i:num]) =&gt; `(conv| arg $i)
  | `(conv| enter [@$i:num]) =&gt; `(conv| arg @$i)
  | `(conv| enter [$id:ident]) =&gt; `(conv| ext $id)
  | `(conv| enter [$arg:enterArg, $args,*]) =&gt; `(conv| (enter [$arg]; enter [$args,*]))
</code></pre>
<!--
- `done` fail if there are unsolved goals.

- `trace_state` display the current tactic state.

- `whnf` put term in weak head normal form.

- `tactic => <tactic sequence>` go back to regular tactic mode. This
  is useful for discharging goals not supported by `conv` mode, and
  applying custom congruence and extensionality lemmas.
-->
<ul>
<li>
<p><code>done</code>会失败如果有未解决的目标。</p>
</li>
<li>
<p><code>traceState</code>显示当前策略状态。</p>
</li>
<li>
<p><code>whnf</code> put term in weak head normal form.</p>
</li>
<li>
<p><code>tactic =&gt; &lt;tactic sequence&gt;</code>回到常规策略模式。这对于退出<code>conv</code>模式不支持的目标，以及应用自定义的一致性和扩展性引理很有用。</p>
</li>
</ul>
<pre><code class="language-lean">example (g : Nat → Nat → Nat)
        (h₁ : ∀ x, x ≠ 0 → g x x = 1)
        (h₂ : x ≠ 0)
        : g x x + x = 1 + x := by
  conv =&gt;
    lhs
    -- ⊢ g x x + x
    arg 1
    -- ⊢ g x x
    rw [h₁]
    -- 2 goals: ⊢ 1, ⊢ x ≠ 0
    . skip
    . tactic =&gt; exact h₂
</code></pre>
<!--
- `apply <term>` is syntax sugar for `tactic => apply <term>`
-->
<ul>
<li><code>apply &lt;term&gt;</code>是<code>tactic =&gt; apply &lt;term&gt;</code>的语法糖。</li>
</ul>
<pre><code class="language-lean">example (g : Nat → Nat → Nat)
        (h₁ : ∀ x, x ≠ 0 → g x x = 1)
        (h₂ : x ≠ 0)
        : g x x + x = 1 + x := by
  conv =&gt;
    lhs
    arg 1
    rw [h₁]
    . skip
    . apply h₂
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
Axioms and Computation
======================
-->
<h1 id="公理与计算"><a class="header" href="#公理与计算">公理与计算</a></h1>
<!--
We have seen that the version of the Calculus of Constructions that
has been implemented in Lean includes dependent function types,
inductive types, and a hierarchy of universes that starts with an
impredicative, proof-irrelevant ``Prop`` at the bottom. In this
chapter, we consider ways of extending the CIC with additional axioms
and rules. Extending a foundational system in such a way is often
convenient; it can make it possible to prove more theorems, as well as
make it easier to prove theorems that could have been proved
otherwise. But there can be negative consequences of adding additional
axioms, consequences which may go beyond concerns about their
correctness. In particular, the use of axioms bears on the
computational content of definitions and theorems, in ways we will
explore here.
-->
<p>我们已经看到 Lean 中实现的构造演算的版本包括有：依值函数类型、
归纳类型以及一个以非直谓的与证明无关（Proof-Irrelevant）的 <code>Prop</code> 为底层的宇宙层级。
在本章中，我们要探讨使用附加公理和规则扩展 CIC 的方法。
用这种方式扩展一个基础系统通常很方便；它可以使得证明更多的定理成为可能，
并使得证明原本可以被证明的定理变得更容易。但是，添加附加公理可能会产生负面后果，
这些后果可能超出了人们对它们的正确性的担忧。
特别是，公理的使用会以我们将在本文中探究的方式，对定义和定理的计算内容产生影响。</p>
<!--
Lean is designed to support both computational and classical
reasoning. Users that are so inclined can stick to a "computationally
pure" fragment, which guarantees that closed expressions in the system
evaluate to canonical normal forms. In particular, any closed
computationally pure expression of type ``Nat``, for example, will
reduce to a numeral.
-->
<p>Lean 被设计为支持计算推理和经典推理。有此需求的用户可坚持使用「计算上纯粹」的片段，
它可以确保系统中的封闭表达式会求值为标准范式。具体说来，任何类型为 <code>Nat</code>
的封闭计算上纯粹表达式最终都将归约为一个数值。</p>
<!--
Lean's standard library defines an additional axiom, propositional
extensionality, and a quotient construction which in turn implies the
principle of function extensionality. These extensions are used, for
example, to develop theories of sets and finite sets. We will see
below that using these theorems can block evaluation in Lean's kernel,
so that closed terms of type ``Nat`` no longer evaluate to numerals. But
Lean erases types and propositional information when compiling
definitions to bytecode for its virtual machine evaluator, and since
these axioms only add new propositions, they are compatible with that
computational interpretation. Even computationally inclined users may
wish to use the classical law of the excluded middle to reason about
computation. This also blocks evaluation in the kernel, but it is
compatible with compilation to bytecode.
-->
<p>Lean 的标准库定义了一个公理： <strong>命题外延性（Propositional Extensionality）</strong> 。
以及一个 <strong>商（Qoutient）</strong> 结构，它蕴含了函数外延性的公理。
这些扩展被用来发展如集合与有限集这些理论。我们在后面会看到，
这些定理的使用会阻碍 Lean 内核中的求值，因此 <code>Nat</code> 类型的封闭项不再求值为数值。
但是 Lean 在对其虚拟机器求值器进行字节码编译时会擦除类型和命题信息，
并且由于这些公理只增加了新的命题，它们与这种计算解释是相容的。
即使是倾向于可计算性的用户也可能希望使用排中律来推理计算。
这也会阻碍内核中的求值，但它与字节码编译是兼容的。</p>
<!--
The standard library also defines a choice principle that is entirely
antithetical to a computational interpretation, since it magically
produces "data" from a proposition asserting its existence. Its use is
essential to some classical constructions, and users can import it
when needed. But expressions that use this construction to produce
data do not have computational content, and in Lean we are required to
mark such definitions as ``noncomputable`` to flag that fact.
-->
<p>标准函数库还定义了一个选择公理（Choice Principle），该公理与计算诠释完全相反，
因为它神奇地根据断言自身存在的命题产生「数据」。
它对于一些经典结构来说是必不可少的，用户可以在需要时导入它。
但使用此构造来产生数据的表达式将不存在计算内容，
在 Lean 中我们需要将此类定义标记为 <code>noncomputable</code>（不可计算的）以表明该事实。</p>
<!--
Using a clever trick (known as Diaconescu's theorem), one can use
propositional extensionality, function extensionality, and choice to
derive the law of the excluded middle. As noted above, however, use of
the law of the excluded middle is still compatible with bytecode
compilation and code extraction, as are other classical principles, as
long as they are not used to manufacture data.
-->
<p>使用一个巧妙的技巧（称为狄阿科涅斯库定理），人们可以使用命题外延性、
函数外延性和选择公理来导出排中律。然而，如上所述，使用排中律仍然兼容字节码编译和代码提取，
就像其他经典公理一样，只要它们不被用来制造数据。</p>
<!--
To summarize, then, on top of the underlying framework of universes,
dependent function types, and inductive types, the standard library
adds three additional components:

- the axiom of propositional extensionality
- a quotient construction, which implies function extensionality
- a choice principle, which produces data from an existential proposition.
-->
<p>总而言之，在我们的宇宙类型，依值函数类型和归纳类型的底层框架之上，
标准库增加了三个附加元素：</p>
<ul>
<li>命题外延性公理</li>
<li>蕴含了函数外延性的的商构造</li>
<li>选择公理，它从存在命题中产生数据。</li>
</ul>
<!--
The first two of these block normalization within Lean, but are
compatible with bytecode evaluation, whereas the third is not amenable
to computational interpretation. We will spell out the details more
precisely below.
-->
<p>前两项在 Lean 中对这些块标准化，但与字节码求值兼容，
而第三项不适合可计算性解释。我们将在下面更精确地说明这些细节。</p>
<!--
Historical and Philosophical Context
------------------------------------
-->
<h2 id="历史与哲学背景"><a class="header" href="#历史与哲学背景">历史与哲学背景</a></h2>
<!--
For most of its history, mathematics was essentially computational:
geometry dealt with constructions of geometric objects, algebra was
concerned with algorithmic solutions to systems of equations, and
analysis provided means to compute the future behavior of systems
evolving over time. From the proof of a theorem to the effect that
"for every ``x``, there is a ``y`` such that ...", it was generally
straightforward to extract an algorithm to compute such a ``y`` given
``x``.
-->
<p>历史上大部分时候，数学主要是计算性的：几何处理涉及几何对象的构造，
代数涉及方程组的算法解，分析提供了计算系统随时间演变的未来行为的方法。
从定理的证明到「对于每个 <code>x</code>，都有一个 <code>y</code> 使得 ...」这一效果，
通常可以提取一种算法来根据给定的 <code>x</code> 计算这样的的 <code>y</code>。</p>
<!--
In the nineteenth century, however, increases in the complexity of
mathematical arguments pushed mathematicians to develop new styles of
reasoning that suppress algorithmic information and invoke
descriptions of mathematical objects that abstract away the details of
how those objects are represented. The goal was to obtain a powerful
"conceptual" understanding without getting bogged down in
computational details, but this had the effect of admitting
mathematical theorems that are simply *false* on a direct
computational reading.
-->
<p>然而在 19 世纪，数学论证复杂性的提升推动了数学家发展新的推理风格，
抑制算法信息并调用数学对象，从而抽象掉了对象被表征的细节。
目标是在不陷入繁重的计算细节的情况下获得强大的「概念」理解，
但这可能导致数学定理在直接计算的解读上干脆就是  <strong>错误</strong>  的。</p>
<!--
There is still fairly uniform agreement today that computation is
important to mathematics. But there are different views as to how best
to address computational concerns. From a *constructive* point of
view, it is a mistake to separate mathematics from its computational
roots; every meaningful mathematical theorem should have a direct
computational interpretation. From a *classical* point of view, it is
more fruitful to maintain a separation of concerns: we can use one
language and body of methods to write computer programs, while
maintaining the freedom to use nonconstructive theories and methods
to reason about them. Lean is designed to support both of these
approaches. Core parts of the library are developed constructively,
but the system also provides support for carrying out classical
mathematical reasoning.
-->
<p>今天数学界仍在相当普遍地同意计算对于数学很重要。
但对于如何以最佳方式解决计算问题有不同的看法。
从 <strong>构造性</strong> 的角度来看，将数学与其计算根源分开是一个错误；
每条有意义的数学定理都应具有直接的计算解释。
从 <strong>经典的</strong> 角度来看，保持关注点的分离更有成效：
我们可以使用一种语言和方法体系编写计算机程序，
同时保持使用非构造性理论和方法对其进行推理的自由。
Lean 旨在支持这两种方法。库的核心部分以构造性方式开发，
但该系统还提供了支持进行经典数学推理的支持。</p>
<!--
Computationally, the purest part of dependent type theory avoids the
use of ``Prop`` entirely. Inductive types and dependent function types
can be viewed as data types, and terms of these types can be
"evaluated" by applying reduction rules until no more rules can be
applied. In principle, any closed term (that is, term with no free
variables) of type ``Nat`` should evaluate to a numeral, ``succ
(... (succ zero)...)``.
-->
<p>从计算的角度来看，依值类型论中最纯粹的部分完全避免使用 <code>Prop</code>。
归纳类型和依值函数类型可以看作是数据类型，这些类型的项可以通过应用归约规则进行「求值」，
直到不能再应用任何规则为止。原则上，类型为 <code>Nat</code> 的任何封闭项（即没有自由变量的项）
都应求值为一个数值：<code>succ(... (succ zero)...)</code>。</p>
<!--
Introducing a proof-irrelevant ``Prop`` and marking theorems
irreducible represents a first step towards separation of
concerns. The intention is that elements of a type ``p : Prop`` should
play no role in computation, and so the particular construction of a
term ``t : p`` is "irrelevant" in that sense. One can still define
computational objects that incorporate elements of type ``Prop``; the
point is that these elements can help us reason about the effects of
the computation, but can be ignored when we extract "code" from the
term. Elements of type ``Prop`` are not entirely innocuous,
however. They include equations ``s = t : α`` for any type ``α``, and
such equations can be used as casts, to type check terms. Below, we
will see examples of how such casts can block computation in the
system. However, computation is still possible under an evaluation
scheme that erases propositional content, ignores intermediate typing
constraints, and reduces terms until they reach a normal form. This is
precisely what Lean's virtual machine does.
-->
<p>引入一个与证明无关的 <code>Prop</code> 并标记定理不可约表示了分离关注点的第一步。
目的是类型为 <code>p : Prop</code> 的元素在计算中不应发挥任何作用，因此从这个意义上说，
项 <code>t : p</code> 的特定构造是「无关的」。人们仍然可以定义包含类型为 <code>Prop</code>
的元素的计算对象；关键是这些元素可以帮助我们推理计算的影响，
但在我们从项中提取「代码」时可以忽略。但是，<code>Prop</code> 类型的元素并非完全无害。
它们包括任何类型 <code>α</code> 的方程 <code>s = t : α</code>，并且此类方程可以作为强制转换使用，
以对项进行类型检查。在后面，我们将看到此类强制转换是如何阻碍系统中的计算的示例。
但是，在擦除命题内容、忽略中间定型约束并归约项，直到它们达到正规形式的求值方案下，
它们仍然可以进行计算。这正是 Lean 的虚拟机所做的。</p>
<!--
Having adopted a proof-irrelevant ``Prop``, one might consider it
legitimate to use, for example, the law of the excluded middle,
``p ∨ ¬p``, where ``p`` is any proposition. Of course, this, too, can block
computation according to the rules of CIC, but it does not block
bytecode evaluation, as described above. It is only the choice
principles discussed in :numref:`choice` that completely erase the
distinction between the proof-irrelevant and data-relevant parts of
the theory.
-->
<p>在通过了证明无关的 <code>Prop</code> 之后，可以认为使用排中律 <code>p ∨ ¬p</code> 是合法的，
其中 <code>p</code> 是任何命题。当然，这也可能根据 CIC 的规则阻止计算，
但它不会阻止字节码求值，如上所述。仅在 :numref:<code>choice</code>
中讨论过的选择原则才能完全消除理论中与证明无关的部分和与数据相关部分之间的区别。</p>
<!--
Propositional Extensionality
----------------------------
-->
<h2 id="命题外延性"><a class="header" href="#命题外延性">命题外延性</a></h2>
<!--
Propositional extensionality is the following axiom:
-->
<p>命题外延性公理如下：</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>axiom propext {a b : Prop} : (a ↔ b) → a = b
<span class="boring">end Hidden
</span></code></pre>
<!--
It asserts that when two propositions imply one another, they are
actually equal. This is consistent with set-theoretic interpretations
in which any element ``a : Prop`` is either empty or the singleton set
``{*}``, for some distinguished element ``*``. The axiom has the
effect that equivalent propositions can be substituted for one another
in any context:
-->
<p>它断言当两个命题互相蕴含时，二者实质相等。这与集合论的解释一致，
即对于某个特定的元素 <code>*</code>，其中任何元素 <code>a : Prop</code> 要么为空集，
要么是单元素集 <code>{*}</code>。此公理具有这样的效果，即等价的命题可以在任何语境中彼此替换：</p>
<pre><code class="language-lean">theorem thm₁ (a b c d e : Prop) (h : a ↔ b) : (c ∧ a ∧ d → e) ↔ (c ∧ b ∧ d → e) :=
  propext h ▸ Iff.refl _

theorem thm₂ (a b : Prop) (p : Prop → Prop) (h : a ↔ b) (h₁ : p a) : p b :=
  propext h ▸ h₁
</code></pre>
<!--
The first example could be proved more laboriously without ``propext``
using the fact that the propositional connectives respect
propositional equivalence. The second example represents a more
essential use of ``propext``. In fact, it is equivalent to ``propext``
itself, a fact which we encourage you to prove.

Given any definition or theorem in Lean, you can use the ``#print
axioms`` command to display the axioms it depends on.

.. code-block:: lean

    variables a b c d e : Prop
    variable p : Prop → Prop

    theorem thm₁ (h : a ↔ b) : (c ∧ a ∧ d → e) ↔ (c ∧ b ∧ d → e) :=
    propext h ▸ iff.refl _

    theorem thm₂ (h : a ↔ b) (h₁ : p a) : p b :=
    propext h ▸ h₁

    -- BEGIN
    #print axioms thm₁  -- propext
    #print axioms thm₂  -- propext
    -- END
-->
<!--
Function Extensionality
-----------------------
-->
<h2 id="函数外延性"><a class="header" href="#函数外延性">函数外延性</a></h2>
<p>Similar to propositional extensionality, function extensionality
asserts that any two functions of type <code>(x : α) → β x</code> that agree on
all their inputs are equal.</p>
<pre><code class="language-lean">universe u v
#check (@funext :
           {α : Type u}
         → {β : α → Type u}
         → {f g : (x : α) → β x}
         → (∀ (x : α), f x = g x)
         → f = g)

#print funext
</code></pre>
<!--
From a classical, set-theoretic perspective, this is exactly what it
means for two functions to be equal. This is known as an "extensional"
view of functions. From a constructive perspective, however, it is
sometimes more natural to think of functions as algorithms, or
computer programs, that are presented in some explicit way. It is
certainly the case that two computer programs can compute the same
answer for every input despite the fact that they are syntactically
quite different. In much the same way, you might want to maintain a
view of functions that does not force you to identify two functions
that have the same input / output behavior. This is known as an
"intensional" view of functions.
-->
<p>从经典的集合论角度来看，这正是两个函数相等的确切含义。
它被称作函数的「外延性（Extensional）」视角。然而，从构造主义的角度来看，
有时把函数看作算法，或者以某种明确的方式给出的计算机程序要更加自然。
肯定存在这样的情况：两个计算机程序对每个输入都计算出相同的答案，
尽管它们在语法上非常不同。与此类似，你可能想要维护一种函数的视角，
它不会强迫你将具有相同输入/输出行为的两个函数认定为同样的。
这被称为函数的「内涵（Intensional）」视角。</p>
<!--
In fact, function extensionality follows from the existence of
quotients, which we describe in the next section. In the Lean standard
library, therefore, ``funext`` is thus
[proved from the quotient construction](https://github.com/leanprover/lean4/blob/master/src/Init/Core.lean).
-->
<p>实际上，函数外延性来自于商的存在，我们将在下一节中进行描述。
因此，在 Lean 标准库中，<code>funext</code> 通过<a href="https://github.com/leanprover/lean4/blob/master/src/Init/Core.lean">商的构造来证明</a>。</p>
<!--
Suppose that for ``α : Type`` we define the ``Set α := α → Prop`` to
denote the type of subsets of ``α``, essentially identifying subsets
with predicates. By combining ``funext`` and ``propext``, we obtain an
extensional theory of such sets:
-->
<p>假设对于 <code>α : Type</code>，我们定义 <code>Set α := α → Prop</code> 来表达 <code>α</code> 子集的类型，
本质上是用谓词来表示子集。通过组合 <code>funext</code> 和 <code>propext</code>，
我们得到了一个这样的集合的外延性理论：</p>
<pre><code class="language-lean">def Set (α : Type u) := α → Prop

namespace Set

def mem (x : α) (a : Set α) := a x

infix:50 (priority := high) &quot;∈&quot; =&gt; mem

theorem setext {a b : Set α} (h : ∀ x, x ∈ a ↔ x ∈ b) : a = b :=
  funext (fun x =&gt; propext (h x))

end Set
</code></pre>
<!--
We can then proceed to define the empty set and set intersection, for
example, and prove set identities:
-->
<p>我们可以继续定义例如空集和交集，并证明的集合恒等性：</p>
<pre><code class="language-lean"><span class="boring">def Set (α : Type u) := α → Prop
</span><span class="boring">namespace Set
</span><span class="boring">def mem (x : α) (a : Set α) := a x
</span><span class="boring">infix:50 (priority := high) &quot;∈&quot; =&gt; mem
</span><span class="boring">theorem setext {a b : Set α} (h : ∀ x, x ∈ a ↔ x ∈ b) : a = b :=
</span><span class="boring">  funext (fun x =&gt; propext (h x))
</span>def empty : Set α := fun x =&gt; False

notation (priority := high) &quot;∅&quot; =&gt; empty

def inter (a b : Set α) : Set α :=
  fun x =&gt; x ∈ a ∧ x ∈ b

infix:70 &quot; ∩ &quot; =&gt; inter

theorem inter_self (a : Set α) : a ∩ a = a :=
  setext fun x =&gt; Iff.intro
    (fun ⟨h, _⟩ =&gt; h)
    (fun h =&gt; ⟨h, h⟩)

theorem inter_empty (a : Set α) : a ∩ ∅ = ∅ :=
  setext fun x =&gt; Iff.intro
    (fun ⟨_, h⟩ =&gt; h)
    (fun h =&gt; False.elim h)

theorem empty_inter (a : Set α) : ∅ ∩ a = ∅ :=
  setext fun x =&gt; Iff.intro
    (fun ⟨h, _⟩ =&gt; h)
    (fun h =&gt; False.elim h)

theorem inter.comm (a b : Set α) : a ∩ b = b ∩ a :=
  setext fun x =&gt; Iff.intro
    (fun ⟨h₁, h₂⟩ =&gt; ⟨h₂, h₁⟩)
    (fun ⟨h₁, h₂⟩ =&gt; ⟨h₂, h₁⟩)
<span class="boring">end Set
</span></code></pre>
<!--
The following is an example of how function extensionality blocks
computation inside the Lean kernel.
-->
<p>以下是一个函数外延性阻碍了 Lean 核心中计算的示例：</p>
<pre><code class="language-lean">def f (x : Nat) := x
def g (x : Nat) := 0 + x

theorem f_eq_g : f = g :=
  funext fun x =&gt; (Nat.zero_add x).symm

def val : Nat :=
  Eq.recOn (motive := fun _ _ =&gt; Nat) f_eq_g 0

-- 无法归约为 0
#reduce val

-- 求值为 0
#eval val
</code></pre>
<!--
First, we show that the two functions ``f`` and ``g`` are equal using
function extensionality, and then we cast ``0`` of type ``Nat`` by
replacing ``f`` by ``g`` in the type. Of course, the cast is
vacuous, because ``Nat`` does not depend on ``f``. But that is enough
to do the damage: under the computational rules of the system, we now
have a closed term of ``Nat`` that does not reduce to a numeral. In this
case, we may be tempted to reduce the expression to ``0``. But in
nontrivial examples, eliminating cast changes the type of the term,
which might make an ambient expression type incorrect. The virtual
machine, however, has no trouble evaluating the expression to
``0``. Here is a similarly contrived example that shows how
``propext`` can get in the way.
-->
<p>首先，我们使用函数外延性来证明两个函数 <code>f</code> 和 <code>g</code> 相等，
然后用 <code>g</code> 替换类型为 <code>Nat</code> 的 <code>f</code>，从而转换该类型。
当然，转换是无意义的，因为 <code>Nat</code> 不依赖于 <code>f</code>。
但这已经足够了：在系统的计算规则之下，我们现在有了 <code>Nat</code> 的一个封闭项，
它不会归约为一个数值。在这种情况下，我们可能倾向于将该表达式归约为 <code>0</code>。
但是，在非平凡的例子里，消除转换会改变该项的类型，这可能会导致周围的表达式类型不正确。
然而，虚拟机将表达式求值为 <code>0</code> 则不会遇到问题。下面是一个类似的例子，
展示了 <code>propext</code> 如何造成阻碍。</p>
<pre><code class="language-lean">theorem tteq : (True ∧ True) = True :=
  propext (Iff.intro (fun ⟨h, _⟩ =&gt; h) (fun h =&gt; ⟨h, h⟩))

def val : Nat :=
  Eq.recOn (motive := fun _ _ =&gt; Nat) tteq 0

-- does not reduce to 0
#reduce val

-- evaluates to 0
#eval val
</code></pre>
<!--
Current research programs, including work on *observational type
theory* and *cubical type theory*, aim to extend type theory in ways
that permit reductions for casts involving function extensionality,
quotients, and more. But the solutions are not so clear cut, and the
rules of Lean's underlying calculus do not sanction such reductions.
-->
<p>当前的研究计划包括关于 <strong>观测类型论（Observational Type Theory）</strong>
和 <strong>立方类型论（Cubical Type Theory）</strong> 的研究，旨在扩展类型理论，
以便允许对涉及函数外延、商，等等的强制转换进行归约。
但解决方案并不明朗，而 Lean 的底层演算法则对此类归约也不支持。</p>
<!--
In a sense, however, a cast does not change the meaning of an
expression. Rather, it is a mechanism to reason about the expression's
type. Given an appropriate semantics, it then makes sense to reduce
terms in ways that preserve their meaning, ignoring the intermediate
bookkeeping needed to make the reductions type correct. In that case,
adding new axioms in ``Prop`` does not matter; by proof irrelevance,
an expression in ``Prop`` carries no information, and can be safely
ignored by the reduction procedures.
-->
<p>从某种意义上来说，一个强制转换不会改变一个表达式的含义。
相反，它是一种关于表达式类型的推理机制。给定一个适当的语义，
那么忽略掉归约为正确类型所需的中间记录操作，以不改变其含义的方式归约项是有意义的。
在这种情况下，在 <code>Prop</code> 中添加新公理并不重要；通过证明无关性，
<code>Prop</code> 中的表达式不会承载任何信息，可以被归约过程安全地忽略。</p>
<!--
Quotients
---------
-->
<h2 id="商"><a class="header" href="#商">商</a></h2>
<!--
Let ``α`` be any type, and let ``r`` be an equivalence relation on
``α``. It is mathematically common to form the "quotient" ``α / r``,
that is, the type of elements of ``α`` "modulo" ``r``. Set
theoretically, one can view ``α / r`` as the set of equivalence
classes of ``α`` modulo ``r``. If ``f : α → β`` is any function that
respects the equivalence relation in the sense that for every
``x y : α``, ``r x y`` implies ``f x = f y``, then ``f`` "lifts" to a function
``f' : α / r → β`` defined on each equivalence class ``⟦x⟧`` by
``f' ⟦x⟧ = f x``. Lean's standard library extends the Calculus of
Constructions with additional constants that perform exactly these
constructions, and installs this last equation as a definitional
reduction rule.
-->
<p>设 <code>α</code> 为任意类型，且 <code>r</code> 为 <code>α</code> 上的等价关系。在数学中，
常见的做法是形成「商（Quotient）」<code>α / r</code>，即 <code>α</code> 中元素的类型「模（modulo）」<code>r</code>。
从集合论的角度，可以将 <code>α / r</code> 视为 <code>α</code> 模 <code>r</code> 的等价类的集合。
若 <code>f : α → β</code> 是任意满足等价关系的函数，即对于任意 <code>x y : α</code>, <code>r x y</code>
蕴含 <code>f x = f y</code>, 则 <code>f</code>「提升（lift）」到函数 <code>f' : α / r → β</code>，
其在每个等价类 <code>⟦x⟧</code> 上由 <code>f' ⟦x⟧ = f x</code> 定义。
Lean 的标准库通过执行这些构造的附加常量来扩展构造演算，并将该最后的方程作为定义归约规则。</p>
<!--
In its most basic form, the quotient construction does not even
require ``r`` to be an equivalence relation. The following constants
are built into Lean:
-->
<p>在最基本的表述形式中，商构造甚至不需要 <code>r</code> 成为一个等价关系。
下列常量被内置在 Lean 中：</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>universe u v

axiom Quot : {α : Sort u} → (α → α → Prop) → Sort u

axiom Quot.mk : {α : Sort u} → (r : α → α → Prop) → α → Quot r

axiom Quot.ind :
    ∀ {α : Sort u} {r : α → α → Prop} {β : Quot r → Prop},
      (∀ a, β (Quot.mk r a)) → (q : Quot r) → β q

axiom Quot.lift :
    {α : Sort u} → {r : α → α → Prop} → {β : Sort u} → (f : α → β)
    → (∀ a b, r a b → f a = f b) → Quot r → β
<span class="boring">end Hidden
</span></code></pre>
<!--
The first one forms a type ``Quot r`` given a type ``α`` by any binary
relation ``r`` on ``α``. The second maps ``α`` to ``Quot α``, so that
if ``r : α → α → Prop`` and ``a : α``, then ``Quot.mk r a`` is an
element of ``Quot r``. The third principle, ``Quot.ind``, says that
every element of ``Quot.mk r a`` is of this form.  As for
``Quot.lift``, given a function ``f : α → β``, if ``h`` is a proof
that ``f`` respects the relation ``r``, then ``Quot.lift f h`` is the
corresponding function on ``Quot r``. The idea is that for each
element ``a`` in ``α``, the function ``Quot.lift f h`` maps
``Quot.mk r a`` (the ``r``-class containing ``a``) to ``f a``, wherein ``h``
shows that this function is well defined. In fact, the computation
principle is declared as a reduction rule, as the proof below makes
clear.
-->
<p>第一条公理根据任何二元关系 <code>r</code> 的类型 <code>α</code> 形成类型 <code>Quot r</code>。
第二条公理将 <code>α</code> 映射到 <code>Quot α</code>，因此若 <code>r : α → α → Prop</code> 且 <code>a : α</code>，
则 <code>Quot.mk r a</code> 是 <code>Quot r</code> 的一个元素。
第三条公理 <code>Quot.ind</code> 是说 <code>Quot.mk r a</code> 的每个元素都属于此形式。
至于 <code>Quot.lift</code>，给定函数 <code>f : α → β</code>，若 <code>h</code> 是一个「<code>f</code>
遵循关系 <code>r</code>」的证明，则 <code>Quot.lift f h</code> 是 <code>Quot r</code> 上的对应函数。
其思想是对于 <code>α</code> 中的每个元素 <code>a</code>，函数 <code>Quot.lift f h</code>
将 <code>Quot.mk r a</code>（包含 <code>a</code> 的 <code>r</code>-类）映射到 <code>f a</code>，
其中 <code>h</code> 表明此函数是良定义的。事实上，计算公理被声明为一个归约规则，
如下方的证明所示。</p>
<pre><code class="language-lean">def mod7Rel (x y : Nat) : Prop :=
  x % 7 = y % 7

-- the quotient type
#check (Quot mod7Rel : Type)

-- the class of a
#check (Quot.mk mod7Rel 4 : Quot mod7Rel)

def f (x : Nat) : Bool :=
  x % 7 = 0

theorem f_respects (a b : Nat) (h : mod7Rel a b) : f a = f b := by
  simp [mod7Rel, f] at *
  rw [h]

#check (Quot.lift f f_respects : Quot mod7Rel → Bool)

-- the computation principle
example (a : Nat) : Quot.lift f f_respects (Quot.mk mod7Rel a) = f a :=
  rfl
</code></pre>
<!--
The four constants, ``Quot``, ``Quot.mk``, ``Quot.ind``, and
``Quot.lift`` in and of themselves are not very strong. You can check
that the ``Quot.ind`` is satisfied if we take ``Quot r`` to be simply
``α``, and take ``Quot.lift`` to be the identity function (ignoring
``h``). For that reason, these four constants are not viewed as
additional axioms.
-->
<p>四个常量 <code>Quot</code>、<code>Quot.mk</code>、<code>Quot.ind</code> 和 <code>Quot.lift</code> 在它们本身上并不强。
你可以检查如果我们把 <code>Quot r</code> 简单地取为 <code>α</code>，并取 <code>Quot.lift</code> 为恒等函数
（忽略 <code>h</code>），那么 <code>Quot.ind</code> 将得到满足。
由于这个原因，这四个常量并没有被看作附加公理。</p>
<!--
    variables α β : Type
    variable  r : α → α → Prop
    variable  a : α
    variable  f : α → β
    variable   h : ∀ a₁ a₂, r a₁ a₂ → f a₁ = f a₂
    theorem thm : quot.lift f h (quot.mk r a) = f a := rfl
    -- BEGIN
    #print axioms thm   -- no axioms
    -- END
-->
<!--
They are, like inductively defined types and the associated
constructors and recursors, viewed as part of the logical framework.
-->
<p>和归纳定义的类型以及相关的构造子和递归器一样，它们也被视为逻辑框架的一部分。</p>
<!--
What makes the ``Quot`` construction into a bona fide quotient is the
following additional axiom:
-->
<p>使 <code>Quot</code> 构造成为真正商的是以下一个附加公理：</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span><span class="boring">universe u v
</span>axiom Quot.sound :
      ∀ {α : Type u} {r : α → α → Prop} {a b : α},
        r a b → Quot.mk r a = Quot.mk r b
<span class="boring">end Hidden
</span></code></pre>
<!--
This is the axiom that asserts that any two elements of ``α`` that are
related by ``r`` become identified in the quotient. If a theorem or
definition makes use of ``Quot.sound``, it will show up in the
``#print axioms`` command.
-->
<p>这条公理断言 <code>α</code> 的任何两个元素，只要满足关系 <code>r</code>，就能在商中被识别的。
如果定理或定义使用了 <code>Quot.sound</code>，它将会在 <code>#print axioms</code> 命令中显示。</p>
<!--
Of course, the quotient construction is most commonly used in
situations when ``r`` is an equivalence relation. Given ``r`` as
above, if we define ``r'`` according to the rule ``r' a b`` iff
``Quot.mk r a = Quot.mk r b``, then it's clear that ``r'`` is an
equivalence relation. Indeed, ``r'`` is the *kernel* of the function
``a ↦ quot.mk r a``.  The axiom ``Quot.sound`` says that ``r a b``
implies ``r' a b``. Using ``Quot.lift`` and ``Quot.ind``, we can show
that ``r'`` is the smallest equivalence relation containing ``r``, in
the sense that if ``r''`` is any equivalence relation containing
``r``, then ``r' a b`` implies ``r'' a b``. In particular, if ``r``
was an equivalence relation to start with, then for all ``a`` and
``b`` we have ``r a b`` iff ``r' a b``.
-->
<p>当然，当 <code>r</code> 是等价关系时，商集的结构是最常用的。给定上面的 <code>r</code>，
如果我们根据法则 <code>r' a b</code> 当且仅当 <code>Quot.mk r a = Quot.mk r b</code> 定义 <code>r'</code>，
那么显然 <code>r'</code> 就是一个等价关系。事实上，<code>r'</code> 是函数 <code>a ↦ quot.mk r a</code>
的 <strong>核（Kernel）</strong> 。公理 <code>Quot.sound</code> 表明 <code>r a b</code> 蕴含 <code>r' a b</code>。
使用 <code>Quot.lift</code> 和 <code>Quot.ind</code>，我们可以证明 <code>r'</code> 是包含 <code>r</code> 的最小的等价关系，
意思就是，如果 <code>r''</code> 是包含 <code>r</code> 的任意等价关系，则 <code>r' a b</code> 蕴含 <code>r'' a b</code>。
特别地，如果 <code>r</code> 开始就是一个等价关系，那么对任意 <code>a</code> 和 <code>b</code>，我们都有
<code>r a b</code> 等价于 <code>r' a b</code>。</p>
<!--
To support this common use case, the standard library defines the
notion of a *setoid*, which is simply a type with an associated
equivalence relation:
-->
<p>为支持这种通用使用案例，标准库定义了  <strong>广集（Setoid）</strong>  的概念，
它只是一个带有与之关联的等价关系的类型：</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>class Setoid (α : Sort u) where
  r : α → α → Prop
  iseqv : Equivalence r

instance {α : Sort u} [Setoid α] : HasEquiv α :=
  ⟨Setoid.r⟩

namespace Setoid

variable {α : Sort u} [Setoid α]

theorem refl (a : α) : a ≈ a :=
  iseqv.refl a

theorem symm {a b : α} (hab : a ≈ b) : b ≈ a :=
  iseqv.symm hab

theorem trans {a b c : α} (hab : a ≈ b) (hbc : b ≈ c) : a ≈ c :=
  iseqv.trans hab hbc

end Setoid
<span class="boring">end Hidden
</span></code></pre>
<!--
Given a type ``α``, a relation ``r`` on ``α``, and a proof ``p``
that ``r`` is an equivalence relation, we can define ``Setoid.mk r p``
as an instance of the setoid class.
-->
<p>给定一个类型 <code>α</code> 和其上的关系 <code>r</code>，以及一个证明 <code>p</code> 证明 <code>r</code> 是一个等价关系，
我们可以定义 <code>Setoid.mk r p</code> 为广集类的一个实例。</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>def Quotient {α : Sort u} (s : Setoid α) :=
  @Quot α Setoid.r
<span class="boring">end Hidden
</span></code></pre>
<!--
The constants ``Quotient.mk``, ``Quotient.ind``, ``Quotient.lift``,
and ``Quotient.sound`` are nothing more than the specializations of
the corresponding elements of ``Quot``. The fact that type class
inference can find the setoid associated to a type ``α`` brings a
number of benefits. First, we can use the notation ``a ≈ b`` (entered
with ``\approx``) for ``Setoid.r a b``, where the instance of
``Setoid`` is implicit in the notation ``Setoid.r``. We can use the
generic theorems ``Setoid.refl``, ``Setoid.symm``, ``Setoid.trans`` to
reason about the relation. Specifically with quotients we can use the
generic notation ``⟦a⟧`` for ``Quot.mk Setoid.r`` where the instance
of ``Setoid`` is implicit in the notation ``Setoid.r``, as well as the
theorem ``Quotient.exact``:
-->
<p>常量 <code>Quotient.mk</code>、<code>Quotient.ind</code>、<code>Quotient.lift</code>
以及 <code>Quotient.sound</code> 仅为 <code>Quot</code> 对应元素的特化形式。
类型类推断能找到与类型 <code>α</code> 关联的广集，这带来了大量好处。
首先，我们可以对 <code>Setoid.r a b</code> 使用符号 <code>a ≈ b</code>（用 <code>\approx</code> 输入），
其中 <code>Setoid</code> 的实例在符号 <code>Setoid.r</code> 中是内隐的。
我们可以使用通用定理 <code>Setoid.refl</code>、<code>Setoid.symm</code>、<code>Setoid.trans</code>
来推断关系。具体来说，在商中，我们可以对 <code>Quot.mk Setoid.r</code> 使用通用符号 <code>⟦a⟧</code>，
其中 <code>Setoid</code> 的实例在符号 <code>Setoid.r</code> 中是内隐的，以及定理 <code>Quotient.exact</code>：</p>
<pre><code class="language-lean"><span class="boring">universe u
</span>#check (@Quotient.exact :
         ∀ {α : Sort u} {s : Setoid α} {a b : α},
           Quotient.mk s a = Quotient.mk s b → a ≈ b)
</code></pre>
<!--
Together with ``Quotient.sound``, this implies that the elements of
the quotient correspond exactly to the equivalence classes of elements
in ``α``.
-->
<p>结合 <code>Quotient.sound</code>，这意味着商的各个元素精确对应于 <code>α</code> 中各元素的等价类。</p>
<!--
Recall that in the standard library, ``α × β`` represents the
Cartesian product of the types ``α`` and ``β``. To illustrate the use
of quotients, let us define the type of *unordered* pairs of elements
of a type ``α`` as a quotient of the type ``α × α``. First, we define
the relevant equivalence relation:
-->
<p>回顾一下标准库中的 <code>α × β</code> 代表类型 <code>α</code> 和 <code>β</code> 的笛卡尔积。
为了说明商的用法，让我们将类型为 <code>α</code> 的元素构成的 <strong>无序对（Unordered Pair）</strong> 的类型定义为
<code>α × α</code> 类型的商。首先，我们定义相关的等价关系：</p>
<pre><code class="language-lean">private def eqv (p₁ p₂ : α × α) : Prop :=
  (p₁.1 = p₂.1 ∧ p₁.2 = p₂.2) ∨ (p₁.1 = p₂.2 ∧ p₁.2 = p₂.1)

infix:50 &quot; ~ &quot; =&gt; eqv
</code></pre>
<!--
The next step is to prove that ``eqv`` is in fact an equivalence
relation, which is to say, it is reflexive, symmetric and
transitive. We can prove these three facts in a convenient and
readable way by using dependent pattern matching to perform
case-analysis and break the hypotheses into pieces that are then
reassembled to produce the conclusion.
-->
<p>下一步是证明 <code>eqv</code> 实际上是一个等价关系，即满足自反性、对称性和传递性。
我们可以使用依值模式匹配进行情况分析，将假设分解然后重新组合以得出结论，
从而以一种简便易读的方式证明这三个事实。</p>
<pre><code class="language-lean"><span class="boring">private def eqv (p₁ p₂ : α × α) : Prop :=
</span><span class="boring">  (p₁.1 = p₂.1 ∧ p₁.2 = p₂.2) ∨ (p₁.1 = p₂.2 ∧ p₁.2 = p₂.1)
</span><span class="boring">infix:50 &quot; ~ &quot; =&gt; eqv
</span>private theorem eqv.refl (p : α × α) : p ~ p :=
  Or.inl ⟨rfl, rfl⟩

private theorem eqv.symm : ∀ {p₁ p₂ : α × α}, p₁ ~ p₂ → p₂ ~ p₁
  | (a₁, a₂), (b₁, b₂), (Or.inl ⟨a₁b₁, a₂b₂⟩) =&gt;
    Or.inl (by simp_all)
  | (a₁, a₂), (b₁, b₂), (Or.inr ⟨a₁b₂, a₂b₁⟩) =&gt;
    Or.inr (by simp_all)

private theorem eqv.trans : ∀ {p₁ p₂ p₃ : α × α}, p₁ ~ p₂ → p₂ ~ p₃ → p₁ ~ p₃
  | (a₁, a₂), (b₁, b₂), (c₁, c₂), Or.inl ⟨a₁b₁, a₂b₂⟩, Or.inl ⟨b₁c₁, b₂c₂⟩ =&gt;
    Or.inl (by simp_all)
  | (a₁, a₂), (b₁, b₂), (c₁, c₂), Or.inl ⟨a₁b₁, a₂b₂⟩, Or.inr ⟨b₁c₂, b₂c₁⟩ =&gt;
    Or.inr (by simp_all)
  | (a₁, a₂), (b₁, b₂), (c₁, c₂), Or.inr ⟨a₁b₂, a₂b₁⟩, Or.inl ⟨b₁c₁, b₂c₂⟩ =&gt;
    Or.inr (by simp_all)
  | (a₁, a₂), (b₁, b₂), (c₁, c₂), Or.inr ⟨a₁b₂, a₂b₁⟩, Or.inr ⟨b₁c₂, b₂c₁⟩ =&gt;
    Or.inl (by simp_all)

private theorem is_equivalence : Equivalence (@eqv α) :=
  { refl := eqv.refl, symm := eqv.symm, trans := eqv.trans }
</code></pre>
<!--
Now that we have proved that ``eqv`` is an equivalence relation, we
can construct a ``Setoid (α × α)``, and use it to define the type
``UProd α`` of unordered pairs.
-->
<p>现在我们已经证明了 <code>eqv</code> 是一个等价关系，我们可以构造一个 <code>Setoid (α × α)</code>，
并使用它来定义无序对的类型 <code>UProd α</code>。</p>
<pre><code class="language-lean"><span class="boring">private def eqv (p₁ p₂ : α × α) : Prop :=
</span><span class="boring">  (p₁.1 = p₂.1 ∧ p₁.2 = p₂.2) ∨ (p₁.1 = p₂.2 ∧ p₁.2 = p₂.1)
</span><span class="boring">infix:50 &quot; ~ &quot; =&gt; eqv
</span><span class="boring">private theorem eqv.refl (p : α × α) : p ~ p :=
</span><span class="boring">  Or.inl ⟨rfl, rfl⟩
</span><span class="boring">private theorem eqv.symm : ∀ {p₁ p₂ : α × α}, p₁ ~ p₂ → p₂ ~ p₁
</span><span class="boring">  | (a₁, a₂), (b₁, b₂), (Or.inl ⟨a₁b₁, a₂b₂⟩) =&gt;
</span><span class="boring">    Or.inl (by simp_all)
</span><span class="boring">  | (a₁, a₂), (b₁, b₂), (Or.inr ⟨a₁b₂, a₂b₁⟩) =&gt;
</span><span class="boring">    Or.inr (by simp_all)
</span><span class="boring">private theorem eqv.trans : ∀ {p₁ p₂ p₃ : α × α}, p₁ ~ p₂ → p₂ ~ p₃ → p₁ ~ p₃
</span><span class="boring">  | (a₁, a₂), (b₁, b₂), (c₁, c₂), Or.inl ⟨a₁b₁, a₂b₂⟩, Or.inl ⟨b₁c₁, b₂c₂⟩ =&gt;
</span><span class="boring">    Or.inl (by simp_all)
</span><span class="boring">  | (a₁, a₂), (b₁, b₂), (c₁, c₂), Or.inl ⟨a₁b₁, a₂b₂⟩, Or.inr ⟨b₁c₂, b₂c₁⟩ =&gt;
</span><span class="boring">    Or.inr (by simp_all)
</span><span class="boring">  | (a₁, a₂), (b₁, b₂), (c₁, c₂), Or.inr ⟨a₁b₂, a₂b₁⟩, Or.inl ⟨b₁c₁, b₂c₂⟩ =&gt;
</span><span class="boring">    Or.inr (by simp_all)
</span><span class="boring">  | (a₁, a₂), (b₁, b₂), (c₁, c₂), Or.inr ⟨a₁b₂, a₂b₁⟩, Or.inr ⟨b₁c₂, b₂c₁⟩ =&gt;
</span><span class="boring">    Or.inl (by simp_all)
</span><span class="boring">private theorem is_equivalence : Equivalence (@eqv α) :=
</span><span class="boring">  { refl := eqv.refl, symm := eqv.symm, trans := eqv.trans }
</span>instance uprodSetoid (α : Type u) : Setoid (α × α) where
  r     := eqv
  iseqv := is_equivalence

def UProd (α : Type u) : Type u :=
  Quotient (uprodSetoid α)

namespace UProd

def mk {α : Type} (a₁ a₂ : α) : UProd α :=
  Quotient.mk' (a₁, a₂)

notation &quot;{ &quot; a₁ &quot;, &quot; a₂ &quot; }&quot; =&gt; mk a₁ a₂

end UProd
</code></pre>
<!--
Notice that we locally define the notation ``{a₁, a₂}`` for unordered
pairs as ``Quotient.mk (a₁, a₂)``. This is useful for illustrative
purposes, but it is not a good idea in general, since the notation
will shadow other uses of curly brackets, such as for records and
sets.
-->
<p>请注意，我们将 <code>{a₁, a₂}</code> 无序对的记法局部定义为 <code>Quotient.mk (a₁, a₂)</code>。
这对展示来说很有用，但一般来说这不是一个好主意，因为该记法将会与花括号的其它用法冲突，
例如记录和集合。</p>
<!--
We can easily prove that ``{a₁, a₂} = {a₂, a₁}`` using ``Quot.sound``,
since we have ``(a₁, a₂) ~ (a₂, a₁)``.
-->
<p>我们可以很容易地使用 <code>Quot.sound</code> 证明 <code>{a₁, a₂} = {a₂, a₁}</code>，
因为我们有 <code>(a₁, a₂) ~ (a₂, a₁)</code>。</p>
<pre><code class="language-lean"><span class="boring">private def eqv (p₁ p₂ : α × α) : Prop :=
</span><span class="boring">  (p₁.1 = p₂.1 ∧ p₁.2 = p₂.2) ∨ (p₁.1 = p₂.2 ∧ p₁.2 = p₂.1)
</span><span class="boring">infix:50 &quot; ~ &quot; =&gt; eqv
</span><span class="boring">private theorem eqv.refl (p : α × α) : p ~ p :=
</span><span class="boring">  Or.inl ⟨rfl, rfl⟩
</span><span class="boring">private theorem eqv.symm : ∀ {p₁ p₂ : α × α}, p₁ ~ p₂ → p₂ ~ p₁
</span><span class="boring">  | (a₁, a₂), (b₁, b₂), (Or.inl ⟨a₁b₁, a₂b₂⟩) =&gt;
</span><span class="boring">    Or.inl (by simp_all)
</span><span class="boring">  | (a₁, a₂), (b₁, b₂), (Or.inr ⟨a₁b₂, a₂b₁⟩) =&gt;
</span><span class="boring">    Or.inr (by simp_all)
</span><span class="boring">private theorem eqv.trans : ∀ {p₁ p₂ p₃ : α × α}, p₁ ~ p₂ → p₂ ~ p₃ → p₁ ~ p₃
</span><span class="boring">  | (a₁, a₂), (b₁, b₂), (c₁, c₂), Or.inl ⟨a₁b₁, a₂b₂⟩, Or.inl ⟨b₁c₁, b₂c₂⟩ =&gt;
</span><span class="boring">    Or.inl (by simp_all)
</span><span class="boring">  | (a₁, a₂), (b₁, b₂), (c₁, c₂), Or.inl ⟨a₁b₁, a₂b₂⟩, Or.inr ⟨b₁c₂, b₂c₁⟩ =&gt;
</span><span class="boring">    Or.inr (by simp_all)
</span><span class="boring">  | (a₁, a₂), (b₁, b₂), (c₁, c₂), Or.inr ⟨a₁b₂, a₂b₁⟩, Or.inl ⟨b₁c₁, b₂c₂⟩ =&gt;
</span><span class="boring">    Or.inr (by simp_all)
</span><span class="boring">  | (a₁, a₂), (b₁, b₂), (c₁, c₂), Or.inr ⟨a₁b₂, a₂b₁⟩, Or.inr ⟨b₁c₂, b₂c₁⟩ =&gt;
</span><span class="boring">    Or.inl (by simp_all)
</span><span class="boring">private theorem is_equivalence : Equivalence (@eqv α) :=
</span><span class="boring">  { refl := eqv.refl, symm := eqv.symm, trans := eqv.trans }
</span><span class="boring">instance uprodSetoid (α : Type u) : Setoid (α × α) where
</span><span class="boring">  r     := eqv
</span><span class="boring">  iseqv := is_equivalence
</span><span class="boring">def UProd (α : Type u) : Type u :=
</span><span class="boring">  Quotient (uprodSetoid α)
</span><span class="boring">namespace UProd
</span><span class="boring">def mk {α : Type} (a₁ a₂ : α) : UProd α :=
</span><span class="boring">  Quotient.mk' (a₁, a₂)
</span><span class="boring">notation &quot;{ &quot; a₁ &quot;, &quot; a₂ &quot; }&quot; =&gt; mk a₁ a₂
</span>theorem mk_eq_mk (a₁ a₂ : α) : {a₁, a₂} = {a₂, a₁} :=
  Quot.sound (Or.inr ⟨rfl, rfl⟩)
<span class="boring">end UProd
</span></code></pre>
<!--
To complete the example, given ``a : α`` and ``u : uprod α``, we
define the proposition ``a ∈ u`` which should hold if ``a`` is one of
the elements of the unordered pair ``u``. First, we define a similar
proposition ``mem_fn a u`` on (ordered) pairs; then we show that
``mem_fn`` respects the equivalence relation ``eqv`` with the lemma
``mem_respects``. This is an idiom that is used extensively in the
Lean standard library.
-->
<p>为了完成此示例，给定 <code>a : α</code> 和 <code>u : uprod α</code>，我们定义命题 <code>a ∈ u</code>，
若 <code>a</code> 是无序对 <code>u</code> 的元素之一，则该命题应成立。
首先，我们在（有序）对上定义一个类似的命题 <code>mem_fn a u</code>；
然后用引理 <code>mem_respects</code> 证明 <code>mem_fn</code> 关于等价关系 <code>eqv</code> 成立。
这是一个在 Lean 标准库中广泛使用的惯用法。</p>
<pre><code class="language-lean"><span class="boring">private def eqv (p₁ p₂ : α × α) : Prop :=
</span><span class="boring">  (p₁.1 = p₂.1 ∧ p₁.2 = p₂.2) ∨ (p₁.1 = p₂.2 ∧ p₁.2 = p₂.1)
</span><span class="boring">infix:50 &quot; ~ &quot; =&gt; eqv
</span><span class="boring">private theorem eqv.refl (p : α × α) : p ~ p :=
</span><span class="boring">  Or.inl ⟨rfl, rfl⟩
</span><span class="boring">private theorem eqv.symm : ∀ {p₁ p₂ : α × α}, p₁ ~ p₂ → p₂ ~ p₁
</span><span class="boring">  | (a₁, a₂), (b₁, b₂), (Or.inl ⟨a₁b₁, a₂b₂⟩) =&gt;
</span><span class="boring">    Or.inl (by simp_all)
</span><span class="boring">  | (a₁, a₂), (b₁, b₂), (Or.inr ⟨a₁b₂, a₂b₁⟩) =&gt;
</span><span class="boring">    Or.inr (by simp_all)
</span><span class="boring">private theorem eqv.trans : ∀ {p₁ p₂ p₃ : α × α}, p₁ ~ p₂ → p₂ ~ p₃ → p₁ ~ p₃
</span><span class="boring">  | (a₁, a₂), (b₁, b₂), (c₁, c₂), Or.inl ⟨a₁b₁, a₂b₂⟩, Or.inl ⟨b₁c₁, b₂c₂⟩ =&gt;
</span><span class="boring">    Or.inl (by simp_all)
</span><span class="boring">  | (a₁, a₂), (b₁, b₂), (c₁, c₂), Or.inl ⟨a₁b₁, a₂b₂⟩, Or.inr ⟨b₁c₂, b₂c₁⟩ =&gt;
</span><span class="boring">    Or.inr (by simp_all)
</span><span class="boring">  | (a₁, a₂), (b₁, b₂), (c₁, c₂), Or.inr ⟨a₁b₂, a₂b₁⟩, Or.inl ⟨b₁c₁, b₂c₂⟩ =&gt;
</span><span class="boring">    Or.inr (by simp_all)
</span><span class="boring">  | (a₁, a₂), (b₁, b₂), (c₁, c₂), Or.inr ⟨a₁b₂, a₂b₁⟩, Or.inr ⟨b₁c₂, b₂c₁⟩ =&gt;
</span><span class="boring">    Or.inl (by simp_all)
</span><span class="boring">private theorem is_equivalence : Equivalence (@eqv α) :=
</span><span class="boring">  { refl := eqv.refl, symm := eqv.symm, trans := eqv.trans }
</span><span class="boring">instance uprodSetoid (α : Type u) : Setoid (α × α) where
</span><span class="boring">  r     := eqv
</span><span class="boring">  iseqv := is_equivalence
</span><span class="boring">def UProd (α : Type u) : Type u :=
</span><span class="boring">  Quotient (uprodSetoid α)
</span><span class="boring">namespace UProd
</span><span class="boring">def mk {α : Type} (a₁ a₂ : α) : UProd α :=
</span><span class="boring">  Quotient.mk' (a₁, a₂)
</span><span class="boring">notation &quot;{ &quot; a₁ &quot;, &quot; a₂ &quot; }&quot; =&gt; mk a₁ a₂
</span><span class="boring">theorem mk_eq_mk (a₁ a₂ : α) : {a₁, a₂} = {a₂, a₁} :=
</span><span class="boring">  Quot.sound (Or.inr ⟨rfl, rfl⟩)
</span>private def mem_fn (a : α) : α × α → Prop
  | (a₁, a₂) =&gt; a = a₁ ∨ a = a₂

-- auxiliary lemma for proving mem_respects
-- 用于证明 mem_respects 的辅助引理
private theorem mem_swap {a : α} :
      ∀ {p : α × α}, mem_fn a p = mem_fn a (⟨p.2, p.1⟩)
  | (a₁, a₂) =&gt; by
    apply propext
    apply Iff.intro
    . intro
      | Or.inl h =&gt; exact Or.inr h
      | Or.inr h =&gt; exact Or.inl h
    . intro
      | Or.inl h =&gt; exact Or.inr h
      | Or.inr h =&gt; exact Or.inl h


private theorem mem_respects
      : {p₁ p₂ : α × α} → (a : α) → p₁ ~ p₂ → mem_fn a p₁ = mem_fn a p₂
  | (a₁, a₂), (b₁, b₂), a, Or.inl ⟨a₁b₁, a₂b₂⟩ =&gt; by simp_all
  | (a₁, a₂), (b₁, b₂), a, Or.inr ⟨a₁b₂, a₂b₁⟩ =&gt; by simp_all; apply mem_swap

def mem (a : α) (u : UProd α) : Prop :=
  Quot.liftOn u (fun p =&gt; mem_fn a p) (fun p₁ p₂ e =&gt; mem_respects a e)

infix:50 (priority := high) &quot; ∈ &quot; =&gt; mem

theorem mem_mk_left (a b : α) : a ∈ {a, b} :=
  Or.inl rfl

theorem mem_mk_right (a b : α) : b ∈ {a, b} :=
  Or.inr rfl

theorem mem_or_mem_of_mem_mk {a b c : α} : c ∈ {a, b} → c = a ∨ c = b :=
  fun h =&gt; h
<span class="boring">end UProd
</span></code></pre>
<!--
For convenience, the standard library also defines ``Quotient.lift₂``
for lifting binary functions, and ``Quotient.ind₂`` for induction on
two variables.
-->
<p>为方便起见，标准库还定义了二元函数的 <code>Quotient.lift₂</code>，
以及对于两个变量的归纳的 <code>Quotient.ind₂</code>。</p>
<!--
We close this section with some hints as to why the quotient
construction implies function extensionality. It is not hard to show
that extensional equality on the ``(x : α) → β x`` is an equivalence
relation, and so we can consider the type ``extfun α β`` of functions
"up to equivalence." Of course, application respects that equivalence
in the sense that if ``f₁`` is equivalent to ``f₂``, then ``f₁ a`` is
equal to ``f₂ a``. Thus application gives rise to a function
``extfun_app : extfun α β → (x : α) → β x``. But for every ``f``,
``extfun_app ⟦f⟧`` is definitionally equal to ``fun x => f x``, which is
in turn definitionally equal to ``f``. So, when ``f₁`` and ``f₂`` are
extensionally equal, we have the following chain of equalities:
-->
<p>我们在本节的末尾解释为什么商构造蕴含了函数的外延性。不难证明在 <code>(x : α) → β x</code>
上的外延相等性是一种等价关系，因此我们可以将类型 <code>extfun α β</code> 视为「保持等价」的函数。
当然，函数应用遵循这种等价，即若 <code>f₁</code> 等价于 <code>f₂</code>，则 <code>f₁ a</code> 等于 <code>f₂ a</code>。
因此，应用产生了一个函数 <code>extfun_app : extfun α β → (x : α) → β x</code>。
但是对于每个 <code>f</code> 而言，<code>extfun_app ⟦f⟧</code> 在定义上等于 <code>fun x =&gt; f x</code>，
这在定义上又等于 <code>f</code>。所以，当 <code>f₁</code> 和 <code>f₂</code> 外延相等时，我们有以下等式链：</p>
<pre><code>    f₁ = extfun_app ⟦f₁⟧ = extfun_app ⟦f₂⟧ = f₂
</code></pre>
<!--
As a result, ``f₁`` is equal to ``f₂``.
-->
<p>因此，<code>f₁</code> 等于 <code>f₂</code>。</p>
<!--
Choice
------
-->
<h2 id="选择公理"><a class="header" href="#选择公理">选择公理</a></h2>
<!--
To state the final axiom defined in the standard library, we need the
``Nonempty`` type, which is defined as follows:
-->
<p>为了陈述标准库中定义的最后一个公理，我们需要 <code>Nonempty</code> 类型，它的定义如下：</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>class inductive Nonempty (α : Sort u) : Prop where
  | intro (val : α) : Nonempty α
<span class="boring">end Hidden
</span></code></pre>
<!--
Because ``Nonempty α`` has type ``Prop`` and its constructor contains data, it can only eliminate to ``Prop``.
In fact, ``Nonempty α`` is equivalent to ``∃ x : α, True``:
-->
<p>由于 <code>Nonempty α</code> 的类型为 <code>Prop</code>，其构造子包含数据，所以只能消去到 <code>Prop</code>。
事实上，<code>Nonempty α</code> 等价于 <code>∃ x : α, True</code>：</p>
<pre><code class="language-lean">example (α : Type u) : Nonempty α ↔ ∃ x : α, True :=
  Iff.intro (fun ⟨a⟩ =&gt; ⟨a, trivial⟩) (fun ⟨a, h⟩ =&gt; ⟨a⟩)
</code></pre>
<!--
Our axiom of choice is now expressed simply as follows:
-->
<p>我们的选择公理现在可以简单地表示如下：</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span><span class="boring">universe u
</span>axiom choice {α : Sort u} : Nonempty α → α
<span class="boring">end Hidden
</span></code></pre>
<!--
Given only the assertion ``h`` that ``α`` is nonempty, ``choice h``
magically produces an element of ``α``. Of course, this blocks any
meaningful computation: by the interpretation of ``Prop``, ``h``
contains no information at all as to how to find such an element.
-->
<p>给定唯一断言 <code>h</code>，即 <code>α</code> 非空，<code>choice h</code> 神奇地产生了一个 <code>α</code> 的元素。
当然，这阻碍了任何有意义的计算：根据 <code>Prop</code> 的解释，<code>h</code> 根本不包含任何信息，
因而无法找到这样的元素。</p>
<!--
This is found in the ``Classical`` namespace, so the full name of the
theorem is ``Classical.choice``. The choice principle is equivalent to
the principle of *indefinite description*, which can be expressed with
subtypes as follows:
-->
<p>这可以在 <code>Classical</code> 命名空间中找到，所以定理的全名是 <code>Classical.choice</code>。
选择公理等价于 <strong>非限定摹状词（Indefinite Description）</strong> 原理，可通过子类型表示如下：</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span><span class="boring">universe u
</span><span class="boring">axiom choice {α : Sort u} : Nonempty α → α
</span>noncomputable def indefiniteDescription {α : Sort u} (p : α → Prop)
                                        (h : ∃ x, p x) : {x // p x} :=
  choice &lt;| let ⟨x, px⟩ := h; ⟨⟨x, px⟩⟩
<span class="boring">end Hidden
</span></code></pre>
<!--
Because it depends on ``choice``, Lean cannot generate bytecode for
``indefiniteDescription``, and so requires us to mark the definition
as ``noncomputable``. Also in the ``Classical`` namespace, the
function ``choose`` and the property ``choose_spec`` decompose the two
parts of the output of ``indefiniteDescription``:
-->
<p>因为依赖于 <code>choice</code>，Lean 不能为 <code>indefiniteDescription</code> 生成字节码，
所以要求我们将定义标记为 <code>noncomputable</code>。同样在 <code>Classical</code> 命名空间中，
函数 <code>choose</code> 和属性 <code>choose_spec</code> 分离了 <code>indefiniteDescription</code> 输出的两个部分：</p>
<pre><code class="language-lean"><span class="boring">open Classical
</span><span class="boring">namespace Hidden
</span>noncomputable def choose {α : Sort u} {p : α → Prop} (h : ∃ x, p x) : α :=
  (indefiniteDescription p h).val

theorem choose_spec {α : Sort u} {p : α → Prop} (h : ∃ x, p x) : p (choose h) :=
  (indefiniteDescription p h).property
<span class="boring">end Hidden
</span></code></pre>
<!--
The ``choice`` principle also erases the distinction between the
property of being ``Nonempty`` and the more constructive property of
being ``Inhabited``:
-->
<p><code>choice</code> 选择公理也消除了 <code>Nonempty</code> 特性与更加具有构造性的
<code>Inhabited</code> 特性之间的区别。</p>
<pre><code class="language-lean"><span class="boring">open Classical
</span>theorem inhabited_of_nonempty : Nonempty α → Inhabited α :=
  fun h =&gt; choice (let ⟨a⟩ := h; ⟨⟨a⟩⟩)
</code></pre>
<!--
In the next section, we will see that ``propext``, ``funext``, and
``choice``, taken together, imply the law of the excluded middle and
the decidability of all propositions. Using those, one can strengthen
the principle of indefinite description as follows:
-->
<p>在下一节中，我们将会看到 <code>propext</code>、<code>funext</code> 和 <code>choice</code>，
合起来就构成了排中律以及所有命题的可判定性。使用它们，我们可以加强如下非限定摹状词原理：</p>
<pre><code class="language-lean"><span class="boring">open Classical
</span><span class="boring">universe u
</span>#check (@strongIndefiniteDescription :
         {α : Sort u} → (p : α → Prop)
         → Nonempty α → {x // (∃ (y : α), p y) → p x})
</code></pre>
<!--
Assuming the ambient type ``α`` is nonempty,
``strongIndefiniteDescription p`` produces an element of ``α``
satisfying ``p`` if there is one. The data component of this
definition is conventionally known as *Hilbert's epsilon function*:
-->
<p>假设环境类型 <code>α</code> 非空，<code>strongIndefiniteDescription p</code> 产生一个满足 <code>p</code>
的元素 <code>α</code>（如果存在的话）。该定义的数据部分通常被称为  <strong>希尔伯特 ε 函数</strong> ：</p>
<pre><code class="language-lean"><span class="boring">open Classical
</span><span class="boring">universe u
</span>#check (@epsilon :
         {α : Sort u} → [Nonempty α]
         → (α → Prop) → α)

#check (@epsilon_spec :
         ∀ {α : Sort u} {p : α → Prop} (hex : ∃ (y : α), p y),
           p (@epsilon _ (nonempty_of_exists hex) p))
</code></pre>
<!--
The Law of the Excluded Middle
------------------------------
-->
<h2 id="排中律"><a class="header" href="#排中律">排中律</a></h2>
<!--
The law of the excluded middle is the following
-->
<p>排中律如下所示：</p>
<pre><code class="language-lean">open Classical

#check (@em : ∀ (p : Prop), p ∨ ¬p)
</code></pre>
<!--
[Diaconescu's theorem](https://en.wikipedia.org/wiki/Diaconescu%27s_theorem) states
that the axiom of choice is sufficient to derive the law of excluded
middle. More precisely, it shows that the law of the excluded middle
follows from ``Classical.choice``, ``propext``, and ``funext``. We
sketch the proof that is found in the standard library.
-->
<p><a href="https://en.wikipedia.org/wiki/Diaconescu%27s_theorem">迪亚科内斯库定理</a> 表明
选择公理足以导出排中律。更确切地说，它表明排中律源自于 <code>Classical.choice</code>，
<code>propext</code> 和 <code>funext</code>。我们概述了标准库中的证明。</p>
<!--
First, we import the necessary axioms, and define two predicates ``U`` and ``V``:
-->
<p>首先，我们导入必要的公理，并定义两个谓词 <code>U</code> 和 <code>V</code>：</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>open Classical
theorem em (p : Prop) : p ∨ ¬p :=
  let U (x : Prop) : Prop := x = True ∨ p
  let V (x : Prop) : Prop := x = False ∨ p

  have exU : ∃ x, U x := ⟨True, Or.inl rfl⟩
  have exV : ∃ x, V x := ⟨False, Or.inl rfl⟩
<span class="boring">  sorry
</span><span class="boring">end Hidden
</span></code></pre>
<!--
If ``p`` is true, then every element of ``Prop`` is in both ``U`` and ``V``.
If ``p`` is false, then ``U`` is the singleton ``true``, and ``V`` is the singleton ``false``.
-->
<p>当 <code>p</code> 为真时，<code>Prop</code> 的所有元素既在 <code>U</code> 中又在 <code>V</code> 中。
当 <code>p</code> 为假时，<code>U</code> 是单元素的 <code>true</code>，<code>V</code> 是单元素的 <code>false</code>。</p>
<!--
Next, we use ``some`` to choose an element from each of ``U`` and ``V``:
-->
<p>接下来，我们使用 <code>some</code> 从 <code>U</code> 和 <code>V</code> 中各选取一个元素：</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span><span class="boring">open Classical
</span><span class="boring">theorem em (p : Prop) : p ∨ ¬p :=
</span><span class="boring">  let U (x : Prop) : Prop := x = True ∨ p
</span><span class="boring">  let V (x : Prop) : Prop := x = False ∨ p
</span><span class="boring">  have exU : ∃ x, U x := ⟨True, Or.inl rfl⟩
</span><span class="boring">  have exV : ∃ x, V x := ⟨False, Or.inl rfl⟩
</span>  let u : Prop := choose exU
  let v : Prop := choose exV

  have u_def : U u := choose_spec exU
  have v_def : V v := choose_spec exV
<span class="boring">  sorry
</span><span class="boring">end Hidden
</span></code></pre>
<!--
Each of ``U`` and ``V`` is a disjunction, so ``u_def`` and ``v_def``
represent four cases. In one of these cases, ``u = True`` and
``v = False``, and in all the other cases, ``p`` is true. Thus we have:
-->
<p><code>U</code> 和 <code>V</code> 都是析取，所以 <code>u_def</code> 和 <code>v_def</code> 表示四种情况。
在其中一种情况下，<code>u = True</code> 且 <code>v = False</code>，在所有其他情况下，
<code>p</code> 为真。因此我们有：</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span><span class="boring">open Classical
</span><span class="boring">theorem em (p : Prop) : p ∨ ¬p :=
</span><span class="boring">  let U (x : Prop) : Prop := x = True ∨ p
</span><span class="boring">  let V (x : Prop) : Prop := x = False ∨ p
</span><span class="boring">  have exU : ∃ x, U x := ⟨True, Or.inl rfl⟩
</span><span class="boring">  have exV : ∃ x, V x := ⟨False, Or.inl rfl⟩
</span><span class="boring">  let u : Prop := choose exU
</span><span class="boring">  let v : Prop := choose exV
</span><span class="boring">  have u_def : U u := choose_spec exU
</span><span class="boring">  have v_def : V v := choose_spec exV
</span>  have not_uv_or_p : u ≠ v ∨ p :=
    match u_def, v_def with
    | Or.inr h, _ =&gt; Or.inr h
    | _, Or.inr h =&gt; Or.inr h
    | Or.inl hut, Or.inl hvf =&gt;
      have hne : u ≠ v := by simp [hvf, hut, true_ne_false]
      Or.inl hne
<span class="boring">  sorry
</span><span class="boring">end Hidden
</span></code></pre>
<!--
On the other hand, if ``p`` is true, then, by function extensionality
and propositional extensionality, ``U`` and ``V`` are equal. By the
definition of ``u`` and ``v``, this implies that they are equal as well.
-->
<p>另一方面，若 <code>p</code> 为真，则由函数的外延性和命题的外延性，可得 <code>U</code> 和 <code>V</code> 相等。
根据 <code>u</code> 和 <code>v</code> 的定义，这蕴含了它们也相等。</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span><span class="boring">open Classical
</span><span class="boring">theorem em (p : Prop) : p ∨ ¬p :=
</span><span class="boring">  let U (x : Prop) : Prop := x = True ∨ p
</span><span class="boring">  let V (x : Prop) : Prop := x = False ∨ p
</span><span class="boring">  have exU : ∃ x, U x := ⟨True, Or.inl rfl⟩
</span><span class="boring">  have exV : ∃ x, V x := ⟨False, Or.inl rfl⟩
</span><span class="boring">  let u : Prop := choose exU
</span><span class="boring">  let v : Prop := choose exV
</span><span class="boring">  have u_def : U u := choose_spec exU
</span><span class="boring">  have v_def : V v := choose_spec exV
</span><span class="boring">  have not_uv_or_p : u ≠ v ∨ p :=
</span><span class="boring">    match u_def, v_def with
</span><span class="boring">    | Or.inr h, _ =&gt; Or.inr h
</span><span class="boring">    | _, Or.inr h =&gt; Or.inr h
</span><span class="boring">    | Or.inl hut, Or.inl hvf =&gt;
</span><span class="boring">      have hne : u ≠ v := by simp [hvf, hut, true_ne_false]
</span><span class="boring">      Or.inl hne
</span>  have p_implies_uv : p → u = v :=
    fun hp =&gt;
    have hpred : U = V :=
      funext fun x =&gt;
        have hl : (x = True ∨ p) → (x = False ∨ p) :=
          fun _ =&gt; Or.inr hp
        have hr : (x = False ∨ p) → (x = True ∨ p) :=
          fun _ =&gt; Or.inr hp
        show (x = True ∨ p) = (x = False ∨ p) from
          propext (Iff.intro hl hr)
    have h₀ : ∀ exU exV, @choose _ U exU = @choose _ V exV := by
      rw [hpred]; intros; rfl
    show u = v from h₀ _ _
<span class="boring">  sorry
</span><span class="boring">end Hidden
</span></code></pre>
<!--
Putting these last two facts together yields the desired conclusion:
-->
<p>将最后两个事实放在一起可以得出期望的结论：</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span><span class="boring">open Classical
</span><span class="boring">theorem em (p : Prop) : p ∨ ¬p :=
</span><span class="boring">  let U (x : Prop) : Prop := x = True ∨ p
</span><span class="boring">  let V (x : Prop) : Prop := x = False ∨ p
</span><span class="boring">  have exU : ∃ x, U x := ⟨True, Or.inl rfl⟩
</span><span class="boring">  have exV : ∃ x, V x := ⟨False, Or.inl rfl⟩
</span><span class="boring">  let u : Prop := choose exU
</span><span class="boring">  let v : Prop := choose exV
</span><span class="boring">  have u_def : U u := choose_spec exU
</span><span class="boring">  have v_def : V v := choose_spec exV
</span><span class="boring">  have not_uv_or_p : u ≠ v ∨ p :=
</span><span class="boring">    match u_def, v_def with
</span><span class="boring">    | Or.inr h, _ =&gt; Or.inr h
</span><span class="boring">    | _, Or.inr h =&gt; Or.inr h
</span><span class="boring">    | Or.inl hut, Or.inl hvf =&gt;
</span><span class="boring">      have hne : u ≠ v := by simp [hvf, hut, true_ne_false]
</span><span class="boring">      Or.inl hne
</span><span class="boring">  have p_implies_uv : p → u = v :=
</span><span class="boring">    fun hp =&gt;
</span><span class="boring">    have hpred : U = V :=
</span><span class="boring">      funext fun x =&gt;
</span><span class="boring">        have hl : (x = True ∨ p) → (x = False ∨ p) :=
</span><span class="boring">          fun _ =&gt; Or.inr hp
</span><span class="boring">        have hr : (x = False ∨ p) → (x = True ∨ p) :=
</span><span class="boring">          fun _ =&gt; Or.inr hp
</span><span class="boring">        show (x = True ∨ p) = (x = False ∨ p) from
</span><span class="boring">          propext (Iff.intro hl hr)
</span><span class="boring">    have h₀ : ∀ exU exV, @choose _ U exU = @choose _ V exV := by
</span><span class="boring">      rw [hpred]; intros; rfl
</span><span class="boring">    show u = v from h₀ _ _
</span>  match not_uv_or_p with
  | Or.inl hne =&gt; Or.inr (mt p_implies_uv hne)
  | Or.inr h   =&gt; Or.inl h
<span class="boring">end Hidden
</span></code></pre>
<!--
Consequences of excluded middle include double-negation elimination,
proof by cases, and proof by contradiction, all of which are described
in the [Section Classical Logic](./propositions_and_proofs.md#classical-logic).
The law of the excluded middle and propositional extensionality imply propositional completeness:
-->
<p>排除中律的推论包括双重否定消除、分情况证明和反证法，
所有这些都在 <a href="./propositions_and_proofs.html#classical-logic">经典逻辑一节</a>
中描述。排除中律和命题外延性律蕴含了命题完备性：</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>open Classical
theorem propComplete (a : Prop) : a = True ∨ a = False :=
  match em a with
  | Or.inl ha =&gt; Or.inl (propext (Iff.intro (fun _ =&gt; ⟨⟩) (fun _ =&gt; ha)))
  | Or.inr hn =&gt; Or.inr (propext (Iff.intro (fun h =&gt; hn h) (fun h =&gt; False.elim h)))
<span class="boring">end Hidden
</span></code></pre>
<!--
Together with choice, we also get the stronger principle that every
proposition is decidable. Recall that the class of ``Decidable``
propositions is defined as follows:
-->
<p>有了选择公理，我们也能得到一个更强的原则，即每个命题都是可判定的。
回想一下 <code>Decidable</code> 可判定性命题集定义如下:</p>
<pre><code class="language-lean"><span class="boring">namespace Hidden
</span>class inductive Decidable (p : Prop) where
  | isFalse (h : ¬p) : Decidable p
  | isTrue  (h : p)  : Decidable p
<span class="boring">end Hidden
</span></code></pre>
<!--
In contrast to ``p ∨ ¬ p``, which can only eliminate to ``Prop``, the
type ``Decidable p`` is equivalent to the sum type ``Sum p (¬ p)``, which
can eliminate to any type. It is this data that is needed to write an
if-then-else expression.
-->
<p>与 <code>p ∨ ¬ p</code> 不同，它只能消去到 <code>Prop</code>，类型 <code>Decidable p</code> 等效于和类型
<code>Sum p (¬ p)</code>，它可以消除至任何类型。
这就是编写「if-then-else（若-则-否则）」表达式所需的数据。</p>
<!--
As an example of classical reasoning, we use ``choose`` to show that if
``f : α → β`` is injective and ``α`` is inhabited, then ``f`` has a
left inverse. To define the left inverse ``linv``, we use a dependent
if-then-else expression. Recall that ``if h : c then t else e`` is
notation for ``dite c (fun h : c => t) (fun h : ¬ c => e)``. In the definition
of ``linv``, choice is used twice: first, to show that
``(∃ a : A, f a = b)`` is "decidable," and then to choose an ``a`` such that
``f a = b``. Notice that ``propDecidable`` is a scoped instance and is activated
by the `open Classical` command. We use this instance to justify
the if-then-else expression. (See also the discussion in
[Section Decidable Propositions](./type_classes.md#decidable-propositions)).
-->
<p>作为经典推理的一个示例，我们使用 <code>choose</code> 来证明，若 <code>f : α → β</code> 是单射的，
且 <code>α</code> 是可居的，则 <code>f</code> 是左逆的。为了定义左逆 <code>linv</code>，我们使用一个依值的
if-then-else 表达式。回忆一下，<code>if h : c then t else e</code> 是
<code>dite c (fun h : c =&gt; t) (fun h : ¬ c =&gt; e)</code> 的记法。在 <code>linv</code> 的定义中，
选择公理使用了两次：首先，为了证明 <code>(∃ a : A, f a = b)</code> 是「可判定的」，
需要选择一个 <code>a</code>，使得 <code>f a = b</code>。请注意，<code>propDecidable</code> 是一个作用域实例，
它通过 <code>open Classical</code> 命令激活。我们使用此实例来证明 if-then-else 表达式。
（还可以参阅 <a href="./type_classes.html#decidable-propositions">可判命题一节</a> 中的讨论）。</p>
<pre><code class="language-lean">open Classical

noncomputable def linv [Inhabited α] (f : α → β) : β → α :=
  fun b : β =&gt; if ex : (∃ a : α, f a = b) then choose ex else default

theorem linv_comp_self {f : α → β} [Inhabited α]
                       (inj : ∀ {a b}, f a = f b → a = b)
                       : linv f ∘ f = id :=
  funext fun a =&gt;
    have ex  : ∃ a₁ : α, f a₁ = f a := ⟨a, rfl⟩
    have feq : f (choose ex) = f a  := choose_spec ex
    calc linv f (f a)
      _ = choose ex := dif_pos ex
      _ = a         := inj feq
</code></pre>
<!--
From a classical point of view, ``linv`` is a function. From a
constructive point of view, it is unacceptable; because there is no
way to implement such a function in general, the construction is not
informative.
-->
<p>从经典逻辑的视角来看，<code>linv</code> 是一个函数。而从构造性视角来看，
它是不可接受的；由于没有实现这样一种函数的通用方法，因此该构造不具备信息量。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="custom.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
